// ECA - Extremely Crude Assembler for the PDP-10

#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef unsigned long long WORD36;

#define SNIPPET_SIZE 64             // Size of code snippet in words

#define MAXSYM 258                  // Maximum symbol size -2

#define SYM_VALUE 1                 // User defined value
#define SYM_UNKNOWN 2               // Not yet known value
#define SYM_UNDEF 3                 // Symbol undefined
#define SYM_OPDEF 4                 // Opcode definition
#define SYM_LABEL 5                 // User label

// REL definitions for later version of program -- initially just an abs loader
// We'll need a linker to make a rel loader

typedef struct file_table           // What files do we have open
{
  char *ifile;                      // Filename of input file
  FILE *iov;                        // File which we are in
  int filenum;                      // Last line # read
  char *ib;                         // Input buffer for file
} FILET;

typedef struct symbol_table         // First version of this will be a brute force linear search
{
  char *symname;                    // Arbitrary length symbol
  int symtype;                      // Symbol type
  int symflags;                     // Symbol flags
  WORD36 value;                     // Value of our symbol
  struct symbol_table *next;        // Next in chain
  int use;                          // Use count
} SYMBOL;

typedef struct code_snippet         // The actual code generated by asm
{
  int startaddr;                    // Starting address if known
  int snipsize;                     // Size of snippet (how many used)
  WORD36 snippets[SNIPPET_SIZE];    // Array of code
  struct code_snippet *next;        // Next snippet in chain 
} SNIPPET;

typedef struct context_heir         // Heirarchy of context blocks
{
  int depth;                        // Depth
  int id;                           // Context at this depth
  char *contname;                   // Name
  int code_start;                   // Code block start address
  int code_end;                     // Last used address
  struct context_heir *parent;      // Link to next highest level
  struct context_heir *croot,*ctail;  // Children at this level
  int children;                     // Number of children (id for child)
  SYMBOL *sroot,*stail;               // Symbol table at this level
  SNIPPET *codebase;                // Code for this context level
} CONTEXT;


/*

  Normal instructions 

  000000000|0111|1|1111|112222222222333333
  012345678|9012|3|4567|890123456789012345
  
  ooooooooo|aaaa|i|xxxx|yyyyyyyyyyyyyyyyyy
  ppppppppp|cccc|i|xxxx|yyyyyyyyyyyyyyyyyy

  111111111 0000 0 0000 000000000000000000
            1111 0 0000 000000000000000000
                 1 0000 000000000000000000
                   1111 000000000000000000

  I/O Instructions     

  000 000 000 011 111 111 112 222 222 222 333 333
  012 345 678 901 234 567 890 123 456 789 012 345

  o-o d-- --- di- ixx xxx
  [o] [dd ddd ][i]xxxxx
  ooo ddd ddd dii ixx xxx

  ooo = 7

  000 111 111 100 000 000 = devmask
  000 000 000 011 100 000 = devopmask

  111 111 111 111 100 000 = opmask

 */

#define HIGH18B 0400000ULL
#define HIGHB 0400000000000ULL
#define ALLBHIGHB 0377777777777ULL

#define BITOVER 0100000000000ULL   // Overflow bit 

// General bit definitions

#define BIT00 0400000000000ULL
#define BIT01 0200000000000ULL
#define BIT02 0100000000000ULL
#define BIT03 0040000000000ULL
#define BIT04 0020000000000ULL
#define BIT05 0010000000000ULL
#define BIT06 0004000000000ULL
#define BIT07 0002000000000ULL
#define BIT08 0001000000000ULL
#define BIT09 0000400000000ULL
#define BIT10 0000200000000ULL
#define BIT11 0000100000000ULL
#define BIT12 0000040000000ULL
#define BIT13 0000020000000ULL
#define BIT14 0000010000000ULL
#define BIT15 0000004000000ULL
#define BIT16 0000002000000ULL
#define BIT17 0000001000000ULL
#define BIT18 0000000400000ULL
#define BIT19 0000000200000ULL
#define BIT20 0000000100000ULL
#define BIT21 0000000040000ULL
#define BIT22 0000000020000ULL
#define BIT23 0000000010000ULL
#define BIT24 0000000004000ULL
#define BIT25 0000000002000ULL
#define BIT26 0000000001000ULL
#define BIT27 0000000000400ULL
#define BIT28 0000000000200ULL
#define BIT29 0000000000100ULL
#define BIT30 0000000000040ULL
#define BIT31 0000000000020ULL
#define BIT32 0000000000010ULL
#define BIT33 0000000000004ULL
#define BIT34 0000000000002ULL
#define BIT35 0000000000001ULL

// Bit and all bits to the right 

#define RBIT00 0777777777777ULL
#define RBIT01 0377777777777ULL
#define RBIT02 0177777777777ULL
#define RBIT03 0077777777777ULL
#define RBIT04 0037777777777ULL
#define RBIT05 0017777777777ULL
#define RBIT06 0007777777777ULL
#define RBIT07 0003777777777ULL
#define RBIT08 0001777777777ULL
#define RBIT09 0000777777777ULL
#define RBIT10 0000377777777ULL
#define RBIT11 0000177777777ULL
#define RBIT12 0000077777777ULL
#define RBIT13 0000037777777ULL
#define RBIT14 0000017777777ULL
#define RBIT15 0000007777777ULL
#define RBIT16 0000003777777ULL
#define RBIT17 0000001777777ULL
#define RBIT18 0000000777777ULL
#define RBIT19 0000000377777ULL
#define RBIT20 0000000177777ULL
#define RBIT21 0000000077777ULL
#define RBIT22 0000000037777ULL
#define RBIT23 0000000017777ULL
#define RBIT24 0000000007777ULL
#define RBIT25 0000000003777ULL
#define RBIT26 0000000001777ULL
#define RBIT27 0000000000777ULL
#define RBIT28 0000000000377ULL
#define RBIT29 0000000000177ULL
#define RBIT30 0000000000077ULL
#define RBIT31 0000000000027ULL
#define RBIT32 0000000000017ULL
#define RBIT33 0000000000007ULL
#define RBIT34 0000000000003ULL
#define RBIT35 0000000000001ULL

// All bits to the left (not including bit)

#define LBIT00 (~0777777777777ULL)  // This is zero actually
#define LBIT01 (~0377777777777ULL)
#define LBIT02 (~0177777777777ULL)
#define LBIT03 (~0077777777777ULL)
#define LBIT04 (~0037777777777ULL)
#define LBIT05 (~0017777777777ULL)
#define LBIT06 (~0007777777777ULL)
#define LBIT07 (~0003777777777ULL)
#define LBIT08 (~0001777777777ULL)
#define LBIT09 (~0000777777777ULL)
#define LBIT10 (~0000377777777ULL)
#define LBIT11 (~0000177777777ULL)
#define LBIT12 (~0000077777777ULL)
#define LBIT13 (~0000037777777ULL)
#define LBIT14 (~0000017777777ULL)
#define LBIT15 (~0000007777777ULL)
#define LBIT16 (~0000003777777ULL)
#define LBIT17 (~0000001777777ULL)
#define LBIT18 (~0000000777777ULL)
#define LBIT19 (~0000000377777ULL)
#define LBIT20 (~0000000177777ULL)
#define LBIT21 (~0000000077777ULL)
#define LBIT22 (~0000000037777ULL)
#define LBIT23 (~0000000017777ULL)
#define LBIT24 (~0000000007777ULL)
#define LBIT25 (~0000000003777ULL)
#define LBIT26 (~0000000001777ULL)
#define LBIT27 (~0000000000777ULL)
#define LBIT28 (~0000000000377ULL)
#define LBIT29 (~0000000000177ULL)
#define LBIT30 (~0000000000077ULL)
#define LBIT31 (~0000000000027ULL)
#define LBIT32 (~0000000000017ULL)
#define LBIT33 (~0000000000007ULL)
#define LBIT34 (~0000000000003ULL)
#define LBIT35 (~0000000000001ULL)

// Opcode decoding bits 

#define FM  0777777777777ULL
#define LWM 0777777000000ULL
#define RWM 0000000777777ULL
#define OPM  0777000000000ULL
#define OPS 27
#define ACM  0000740000000ULL
#define ACS 23
#define IBM  0000020000000ULL
#define IBS 22
#define INM  0000017000000ULL
#define INS 18


// Byte pointer masks

#define BPP 0770000000000ULL
#define BPPS 30
#define BPS 0007700000000ULL
#define BPSS 24

#define DEVMASK   0077400000000ULL
#define DEVMASKS 24
#define DEVOPMASK 0000340000000ULL
#define DEVOPMASKS 21
#define IOOPMASK  0777740000000ULL
#define IOOPMASKS 21

#define LH(a) ((((long long int)(a))&LWM)>>18)
#define RH(a) (((long long int)(a))&RWM)

#define SWAPLR(a) (RH(a)<<18 | LH(a))

#define BLDWRD(a,b) ((long long int)(a)<<18 | (long long int)(b))

#define FW(a) (((long long int) (a))&FM)

#define OP(a) ((((long long int)(a))&OPM)>>OPS)
#define AC(a) ((((long long int)(a))&ACM)>>ACS)
#define IB(a) ((((long long int)(a))&IBM)>>IBS)
#define IN(a) ((((long long int)(a))&INM)>>INS)

/* Extend the high order bits of negative #s */
#define NORMALIZE(a) \
         if (a & HIGHB) a |= (~FM); \
            else a &= FM 

#define NORMALIZE_RH(a) \
         if (a & HIGH18B) a |= (~ RWM); \
            else a &= RWM
