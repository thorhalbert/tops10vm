UNIVERSAL S - SYSTEM PARAMETER FILE FOR 7.04 MONITOR - V1436
SUBTTL	/TH/AF/CHW/RCC/DAL/I/BGE/RLD/JBS	26-JULY-88

	SEARCH	F

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1969,1970,1971,1972,1973,
; 1974,1975,1976,1977,1978,1979,1980,1982,1984,1986,1988.
;ALL RIGHTS RESERVED.

;DEFINE A MACRO FOR INSERTING COPYRIGHT NOTICES INTO BINARY FILES
DEFINE	.CPYRT(YEARS,SHOW),<
	XLIST
IFB<SHOW>,.ORG	0	;;PUT IT IN THE AC'S OF .REL FILES TO SAVE .EXE SPACE
;;LOAD THE ACTUAL COPYRIGHT TEXT
ASCIZ &
COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 'YEARS'.
ALL RIGHTS RESERVED.
&
IFB<SHOW>,<
CPYRT.:!;IFGE .-20,<PRINTX % COPYRIGHT TEXT TOO LONG FOR ACS>
IFG .-22,<PRINTX % COPYRIGHT TEXT TOO LONG FOR A REL BLOCK>
	.ORG		;;GET BACK TO CODE SPACE
	.ORG	0	;;TO AC SPACE AGAIN
	REPEAT	CPYRT.,<EXP 0>;;ONLY ONE COPY IN THE .EXE FILE PLEASE
	.ORG>		;;AND FINALLY BACK TO CODE SPACE FOR REAL
	LIST
>

;FOR SAMPLE USAGE, SEE BELOW (AT OUR COPYRIGHT STATEMENT)

;THIS UNIVERSAL FILE IS ASSEMBLED BEFORE EACH MONITOR MODULE. THIS FILE
; MUST BE ASSEMBLED BEFORE ANY MONITOR MODULES ARE ASSEMBLED, HOWEVER,
; IT NEED BE ASSEMBLED ONLY ONCE REGARDLESS OF THE NUMBER OF MONITOR
; MODULES WHICH FOLLOW. EXAMPLE:
;
;  .COMPILE F.MAC/COMPILE,S.MAC/COMPILE,FILIO,FILFND,FILUUO,SCNSER
;
;THE FILES F.REL AND S.REL ARE NOT NEEDED AND MAY BE DISCARDED.

;THE UNIVERSAL FILE F.MAC MUST BE ASSEMBLED BEFORE S.MAC

.CPYRT<1969,1986>,.


DEFINE	XPP(A,B)	;SYSTEM PARAMETER WHICH WILL PRINT-OUT FROM DDT
<A=:B>

DEFINE	XPL(A,B)	;LOCAL PARAMETER WHICH WILL PRINT-OUT FROM DDT
<A=B>

DEFINE	XP(A,B)		;SYSTEM PARAMETER WHICH WILL NOT PRINT FROM DDT
<A==:B>

DEFINE	ND(A,B)		;DEFINE A IF NOT DEFINED
<IF2,<IFDEF A,<A=A>> IFNDEF A,<XP A,<B>>>

DEFINE	NDL(A,B)	;DEFINE A AS LOCAL IF NOT DEFINED
<IF2,<IFDEF A,<A=A>> IFNDEF A,<A==<B>>>
SALL			;SUPPRESS MACRO EXPANSIONS
;               TABLE OF CONTENTS FOR S
;
;
;                        SECTION                               PAGE
;    1. ACCUMULATOR ASSIGNMENTS...............................   4
;    2. CHANNEL DATA BLOCK....................................   7
;    3. DEVICE DATA BLOCK (DDB)...............................   9
;    4. FLAG BITS
;         4.1   S AND DEVIOS(F)...............................  16
;         4.2   UUOS..........................................  18
;	  4.3   JOBPEK........................................  19
;         4.4   PAGE ACCESSIBILITY UUO........................  20
;         4.5   PAGE. UUO.....................................  20
;    5. PAGE. UUO
;         5.1   FUNCTION CODES................................  20
;         5.2   ERROR CODES...................................  20
;    6. BITS FOR TESTING UUOS.................................  21
;    7. SCHED. UUO ERROR CODES................................  22
;    8. TRMOP. UUO ERROR CODES................................  22
;    9. DTE. UUO ERROR CODES..................................  22
;   10. SEARCH LIST PARAMETERS AND LIMITS.....................  23
;   11. BITS IN JOB TABLES
;        11.1   JOB STATUS WORD (JBTSTS)......................  27
;        11.2   JBTSCD........................................  31
;        11.3   JBTST2........................................  32
;        11.4   JBTSWP, JBTPPB AND PAGTAB.....................  33
;        11.5   MEMTAB AND SWPLST.............................  34
;        11.6   JBTSGN........................................  35
;        11.7   JBTPRV........................................  36
;        11.8   WORDS OF PROCESS DATA BLOCKS..................  36
;        11.9   JBTWCH AND JBTRSP.............................  37
;        11.10  JBTLIM, JBTSPL, .PDOBI........................  38
;        11.11  JBTSPS........................................  39
;        11.12  JBTPIA AND PSISER DEFINITIONS.................  40
;   12. ERROR CODES...........................................  42
;   13. EXTENDED I/O ERRORS...................................  43
;   14. JOB BUFFER HEADER.....................................  44
;   15. ARGUMENTS FOR EXTENDED LOOKUP/ENTER/RENAME............  45
;   16. MEM PARITY ERROR RECOVERY.............................  46
;   17. CODES FOR DAEMON ERROR REPORTING......................  48
;   18. BITS IN STATES AND DEBUGF.............................  49
;   19. TAPSER AND IORB BIT DEFINITIONS.......................  50
;   20. MTAPE AND TAPOP. DEFINITIONS..........................  53
;   21. TAPE LABEL DEFINITIONS................................  54
;   22. EVENT WAIT CODE DEFINITIONS...........................  55
;   23. CODES SENT TO THE FILE DAEMON.........................  55
;   24. BITS RETURNED TO THE MONITOR BY THE FILE DAEMON.......  55
;   25. BITS IN THE RH OF .CPSBR..............................  55
;   26. SAVE-FILE FORMAT DEFINITIONS..........................  56
;   27. BITS IN GETTAB TABLE (NUMTAB).........................  57
;   28. TELETYPE PARAMETERS...................................  58
;   29. DEFINITIONS FOR DC44, DC75, DC76, DN60 AND DAS85......  59
;   30. HARDWARE BITS
;        30.1   FOR BOTH KA10 AND KI10 PROCESSORS.............  67
;        30.2   FOR KA10 PROCESSOR (APR, PI, PC)..............  68
;        30.3   FOR KI10 PROCESSOR............................  71
;        30.4   FOR KL10 PROCESSOR............................  76
;        30.5   FOR KS10 PROCESSOR............................  81
;        30.6   FOR KS10 UBA AND DEVICES......................  84
;   31. KI10/KL10/KS10 PAGE MAP LAYOUT........................  86
;   32. FEATURE TEST SWITCHES WHICH MUST BE ON................  91
;   33. SYSTEM MACROS
;        33.1   GENERAL.......................................  92
;        33.2   NETSER INTERLOCK MANAGEMENT...................  94
;        33.3   STOPCD........................................  97
;        33.4   FRAME.........................................  99
;        33.5   TEXT CONCATENATION............................ 100
;        33.6   SOPDEF, GOPDEF, GSOPDEF....................... 102
;        33.7   METER POINT................................... 103
;        33.8   EXECUTIVE EXECUTE............................. 104
;        33.9   KL10 SPECIFIC................................. 105
;        33.10  SOFTWARE INTERRUPTS........................... 110
;        33.11  TWO SEGMENT MONITOR........................... 111
;        33.12  UUO ERROR CODE GENERATOR...................... 112
;        33.13  MULTI PROCESSING.............................. 113
;        33.14  DISK AND TAPE PI CONTROL...................... 114
;        33.15  QUEUE DEFINITIONS............................. 116
;   34. OPDEFS................................................ 117
;   35. MONITOR/USER SYMBOL PREFIXES.......................... 118
;   36. DEFINE THE SYMBOLS FOR THE LINK PSEUDO OPERATIONS..... 120
;   37. KLINIK DEFINITIONS.................................... 120
	SUBTTL	ACCUMULATOR ASSIGNMENTS -- COMMENT.

COMMENT	|
On October 13, 1983 (a thursday), all the accumulator names were
shuffled to provide an order which could be somewhat consistent with
TOPS20 usage. The TOPS10 AC names remain unchanged, only their order
has been shifted. There are now an additional two sets of AC names,
invoked by the D36SYM and T20SYM macros. The relationship of the name
sets is described below:

	NUMBER	TOPS10	TOPS20	DECNET

	(0) 	S	F	FREE0
	(1) 	P	P	P
	(2) 	T1	T1	T1
	(3) 	T2	T2	T2
	(4) 	T3	T3	T3
	(5) 	T4	T4	T4
	(6) 	W	Q1	T5
	(7) 	M	Q2	T6
	(10)	U	Q3	FREE1
	(11)	P1	P1	P1
	(12)	P2	P2	P2
	(13)	P3	P3	FREE2
	(14)	P4	P4	MS
	(15)	J	P5	MB
	(16)	F	P6(.FP)	(.FP)
	(17)	R	CX	CX

The column listed "TOPS20" is not the real TOPS20 order, merely an
order which approximates the TOPS20 order. On a true TOPS20 system,
the AC "P" is 17, and all the other ACs shift down by one. Regrettably,
TOPS10 code knows too much about where P lives to be able to shift
its stack pointer to comply with TOPS20.

	|
	SUBTTL	ACCUMULATOR ASSIGMENTS - TOPS10

DEFINE T10SYM,<
XPP S,0		;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
XPP P,1		;*PUSH DOWN POINTER (SEPERATE LIST FOR EACH PI CHANNEL
		; AND EACH USER JOB)
XPP T1,2	;TEMPORARY (OCCASIONALLY PRESERVED ACROSS SUBROUTINES)
XPP T2,T1+1	;TEMPORARY (ALSO OCCASIONALLY PRESERVED)
XPP T3,T2+1	;TEMPORARY (IN SCNSER, CURRENT CHARACTER)
XPP T4,T3+1	;TEMPORARY
		;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE
XPP W,6		;*ADDRESS OF PDB
XPP M,7		;*CURRENT UUO IN PROGRESS
XPP U,10	;LDB POINTER
		;UNIT DATA BLOCK POINTER
XPP P1,11	;PERMANENT AC'S
		;*USER I/O CHANNEL NUMBER
XPP P2,P1+1
XPP P3,P2+1
XPP P4,P3+1	;CONTENTS OF 2ND WORD OF USER BUFFER ON UUOS
XPP J,15	;JOB NUMBER
		;KONTROLLER DATA BLOCK (FILSER)
		;STATION DATA BLOCK    (NETSER)
XPP F,16	;ADDRESS OF DDB
XPP R,17	;RELOCATION REGISTER, LARGELY OBSOLETE.
		; HIGHEST ADDRESS IN USER JOB (VMSER)
		; OFTEN USED AS POINTER TO NON-0 SECTIONS

DEFINE PURGEACS,<PURGE S,T1,T2,T3,T4,W,M,U,P1,P2,P3,P4,J,F,R>

> ;END DEFINE T10SYM

	T10SYM		;SINCE THIS IS THE DEFAULT SET, INVOKE MACRO NOW.
	SUBTTL	ACCUMULATOR ASSIGNMENTS - TOPS20 COMPATIBLE

DEFINE T20SYM,<
F=0		;GENERAL FLAG REGISTER - PRESERVED
P=:1		;UNIVERSAL STACK
T1=:2		;GENERAL TEMPORARY
T2=:3
T3=:4
T4=:5
Q1=6		;SECOND SET OF PRESERVED
Q2=7
Q3=10
P1=:11		;PRESERVED ACS
P2=:12
P3=:13
P4=:14
P5=15
P6=16
 .FP=P6		;FRAME POINTER FOR TRVAR
CX=17
 .SAC=CX
 .A16=CX	;MACSYM WANTS .A16 FOR TRVAR'S CX.

OPDEF	CALL	[PUSHJ P,0]	;HAS TO BE REDEFINED 'CAUSE P CHANGES
OPDEF	RET	[POPJ  P,0]	;;ALSO HAS TO BE REDEFINED
	.NODDT CALL,RET

DEFINE JSERR(B,C,D),<PRINTX ?JSERR MACRO NOT SUPPORTED UNDER TOPS10>

DEFINE PURGEACS,<PURGE F,T1,T2,T3,T4,Q1,Q2,Q3,P1,P2,P3,P4,P5,P6,CX>

> ;END DEFINE T20SYM
	SUBTTL	ACCUMULATOR ASSIGNMENTS - DECNET-36

DEFINE D36SYM,<
T20SYM		;SET UP TOPS20 AC SET
PURGE F,Q1,Q2,Q3,P3,P4,P5,P6 ;BLOW AWAY ACS THAT DECNET REDEFINES

FREE0=0		;AVAILABLE FOR USE. CAN'T BE USED AS INDEX
P=:1		;STACK
T1=:2		;TEMPORARY
T2=:T1+1
T3=:T2+1
T4=:T3+1
T5=T4+1		;EXTRA TEMP FOR EXTEND INSTRUCTIONS.
T6=T5+1		;ANOTHER EXTRA TEMP
FREE1==10	;AVAILABLE AC
P1=:11		;FIRST PRESERVED AC
P2=:P1+1
FREE2==13	;ANOTHER AVAILABLE AC
MS=14		;MESSAGE SEGMENT POINTER
MB=15		;MESSAGE BLOCK POINTER
;16		;FRAME POINTER. USED IN DECNET,DEFINED IN T20SYM
;17		;CX. TRASH AC.

DEFINE PURGEACS,<
PURGE FREE0,P,T1,T2,T3,T4,T5,T6,MB,P1,P2,MS,FREE1,FREE2,.FP,CX
> ;END DEFINE PURGEACS
> ;END DEFINE D36SYM
	SUBTTL ACCUMULATOR ASSIGMENTS -- HISTORICAL NOTES, 1983
;THE BELOW PAGES ARE INCLUDED FOR HISTORICAL REASONS. THE AC SETS DEFINED
;BELOW ARE NO LONGER OPERATIVE, BUT REFERENCES TO THESE SEQUENCES WILL BE
;FOUND IN MANY SNOOP AND RTTRP. PROGRAMS.

REPEAT 0,<
;*** ON JUNE 1,1971 ALL ACCUMULATOR NAMES WERE CHANGED TO REDUCE TO
;*** SIXTEEN NAMES.  THE OLD ASSIGNMENTS WILL BE FOUND AFTER THE
;*** CURRENT ASSIGNMENTS, UNDER REPEAT 0.

;SEE FILSER.FLO FOR SUBROUTINE CALLING CONVENTIONS

;* MEANS LOADED BY UUO HANDLER ON ALL UUOS

;XPP S,0       	;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
;XPP P,1       	;*PUSH DOWN POINTER (SEPARATE LIST FOR EACH PI
;        	; CHANNEL AND EACH USER JOB)
;XPP J,2       	;BUFFER ITEM COUNT, OR JOB NUMBER
;        	;IN LEVEL D FILSER ADR OF CONTROLLER DATA BLOCK - ONE PER CONTROLLER
;        	;IN REMOTE COMMUNICATIONS HANDLER ADR OF STATION DATA BLOCK
;XPP R,3       	;*LH=HIGHEST RELATIVE LOCATION IN USER AREA
;XPP F,4       	;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW)
;        	; RH=ADDRESS OF DEVICE DATA BLOCK - ONE PER FILE
;XPP U,5       	;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR
;        	; MESSAGES, ETC.	;OR TEMPORARY
;        	;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
;        	;IN LEVEL D FILSER ADR OF UNIT DATA BLOCK - ONE FOR EACH DISK UNIT
;        	; (POSITIONER) EVEN IF SAME TYPE
;        	;IN TERMINAL HANDLER ADR OF LINE DATA BLOCK OF THIS TTY
;XPP T1,6	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
;XPP T2,T1+1	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
;        	;IN TERMINAL HANDLER CHARACTER ADDRESS IN CHARACTER POOL
;XPP T3,T2+1	;TEMPORARY
;		;IN TERMINAL HANDLER CHARACTER (SEVEN BIT ASCII)
;
;XPP T4,T3+1	;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE
;
;0 THRU 11 SAVED FOR LEVEL D
;
;XPP W,12	;*ADDRESS OF PDB
;XPP M,13	;*CURRENT UUO IN PROGRESS
;        	; R IN INDEX FIELD FOR RELOCATION
;XPP P1,14	;PERMANENT AC'S
;        	;*USER I/O CHANNEL NUMBER
;XPP P2,P1+1	;
;XPP P3,P2+1	;
;XPP P4,P3+1	;CONTENTS OF 2ND WORD OF USER BUFFER ON UUOS
;        	;CONTAINS ADR. OF CDB ON APR AND CLK INTERRUPTS
;
;XPP .FP,17	;FRAME POINTER AC FOR TRVAR - SEE .TRSET.
;        	;DEFINED HERE SO WE CAN MOVE IT AROUND.
	SUBTTL ACCUMULATOR ASSIGMENTS -- HISTORICAL NOTES, 1971

;*** THESE TWO PAGES ARE INCLUDED FOR HISTORICAL REASONS AS
;*** A REFERENCE. NOTE THAT THEY ARE NOT ASSEMBLED.

;ACCUMULATOR ASSIGNMENTS
;
;* MEANS LOADED BY UUO HANDLER ON ALL UUOS
;
;XP IOS,0	;*I/O DEVICE STATUS WORD (SEE BELOW FOR BITS)
;XP TAC,6	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
;XP TAC1,7	;TEMPORARY (SOMETIMES PRESERVED ACROSS SUBRTNS)
;XP PDP,1	;*PUSH DOWN POINTER (SEPARATE LIST FOR EACH PI
;		; CHANNEL AND EACH USER JOB)
;XPP ITEM,2	;BUFFER ITEM COUNT, OR JOB NUMBER
;XPP DAT,5	;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR
;		; MESSAGES, ETC.	;OR TEMPORARY
;XP JBUF,DAT	;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
;XP DEVDAT,4	;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW)
;		; RH=ADDRESS OF DEVICE DATA BLOCK
;XP PROG,3	;*LH=HIGHEST RELATIVE LOCATION IN USER AREA
;		; RH=ABSOLUTE ADDRESS OF USER AREA
;XP JDAT,PROG	;*RH=ADDRESS OF JOB DATA AREA
;		; LH=HIGHEST RELATIVE LOCATION IN USER AREA
;XP TEM,10	;TEMPORARY USED ONLY IN SCNSER I/O ROUTINE
;
;ONLY 0 THRU 10 SAVED FOR INTERRUPT SERVICE - LEVEL C AND BEFORE
;
;XP DSER,11	;*ADDRESS OF DEVICE SERVICE ROUTINE'S DISPATCH TABLE
;
;0 THRU 11 SAVED FOR LEVEL D
;
;XP BUFPNT,12	;CONTENTS OF FIRST WORD OF 3 WORD USER BUFFER HEADER
;XPP UCHN,BUFPNT	;*USER I/O CHANNEL NUMBER
;XP BUFWRD,17	;CONTENTS OF 2ND WORD OF USER BUFFER
;XPP UUO,13	;*CURRENT UUO IN PROGRESS
;		; PROG IN INDEX FIELD FOR RELOCATION
;XP AC1,14	;TEMPORARY AC'S (MORE TEMPORARY THAN TAC,TAC1)
;XP AC2,15	;
;XP AC3,16	;
;ACCUMULATOR ASSIGNMENTS (LEVEL D)
;SEE FILSER.FLO FOR SUBROUTINE CALLING CONVENTIONS
;
;GLOBAL - INTERRUPT AND UUO LEVELS
;
;XPP S,IOS	;DEVICE IO STATUS
;XPP P,PDP	;PUSH DOWN POINTER
;XP K,ITEM	;ADR. OF CONTROLLER DATA BLOCK - ONE FOR EACH CONTROLLER
;XPP R,PROG	;JOB RELOCATION (RH) PROTECTION(LH)
;XPP F,DEVDAT	;ADR. OF DEVICE DATA BLOCK - ONE FOR EACH FILE - USER PAIR
;XP U,DAT	;ADR. OF UNIT DAT BLOCK - ONE FOR EACH DISK UNIT (POSITIONER)
;		;EVEN IF SAME TYPE
;
;TEMPORARY - INTERRUPT AND UUO LEVELS - NEED NEVER BE PUSHED BEFORE USE
;
;XPP T,TAC	;FIRST OF 4 CONSECUTIVE TEMP ACS
;XPP T1,TAC1	;SECOND OF 4 CONSECUTIVE TEMP ACS
;XPP T2,TEM	;THIRD OF 4 CONSECUTIVE TEMP ACS
;XPP T3,DSER	;FOURTH OF 4 CONSECUTIVE TEMP ACS
;
;GLOBAL - UUO LEVEL ONLY
;
;XPP UCHN,UCHN	;
;XPP UUO,UUO	;
;
;PRESERVED - INTERRUPT AND UUO LEVELS - MUST BE PUSHED BEFORE BEING USED
;
;XPP P1,AC1	;4 CONSECUTIVE ACS
;XPP P2,AC2	;
;XPP P3,AC3	;
;XPP P4,BUFWRD	;
;
;
;DEFINITIONS FOR TERMINAL HANDLERS - SCNSER,BTHINT(ETC),COMCON,ERRCON,ONCE
;
;XP LINE,U	;ADDRESS OF LINE DATA BLOCK OF THIS TTY
;XP CH,TEM	;CHARACTER (SEVEN BIT ASCII)
;XP CA,T1	;CHARACTER ADDRESS IN CHARACTER POOL
;
>	;*** END REPEAT 0
	SUBTTL ABSOLUTE LOCATIONS IN LOWER MEMORY

XPP BOOTPA,20		;PHYSICAL LOCATION OF BOOTSTRAP
XPP CLKDDT,21		;JUMP TO EDDT IF DEBUG SET AND THIS NON-ZERO
XPP BOOTWD,22		;APR SERIAL NUMBER STORED BY BOOT
			;LOCATIONS 22 & 23 USED BY BOOT FOR RH10 CCW
XPP CRSDTM,24		;CRASH DATE,,TIME(SECS)
XPP CRSWHY,25		;CRASH NAME (REASON)
XPP CRSCHK,26		;CRASH CHECKSUM (24+25)
XPP CPNDDT,27		;SET NON-ZERO IF WE HIT A DDT BREAKPOINT.
			; CAUSES ALL OTHER CPU'S TO LOOP IN THE AC'S
			; UNTIL THIS WORD IS CLEARED AGAIN.
XPP CRSHWD,30		;NORMALLY THIS WORD WILL BE 0.  IF IT IS ACCIDENTALLY
			; OR PURPOSEFULLY OVERWRITTEN THE MONITOR WILL
			; ATTEMPT TO SAVE THE AC'S AND THE STATE OF
			; ALL DEVICES, THEN HALT.   [A LA 407 RESTART]

;LOCATIONS 31-35 ARE RESERVED FOR KS10 SYSTEMS.  DEFINITIONS FOR THESE
;LOCATIONS APPEAR LATER IN THIS FILE.

XPP CRSSTS,36		;RH = CONTENTS OF THE STATES WORD AS
			; SET BY THE OPR. RESTORED UPON AUTO-RELOAD
			; AFTER A CRASH.
XPP SYSSNP,37		;WHEN DEPOSITED NON-ZERO, PRINTS SNAP SHOT OF SYSTEM
			; ON LPT (SEE MOVIE SUBPROGRAM)

XPP FORTY,40		;PLACE WHERE UUOS ARE STORED ON TRAP
XPP FLTINL,50		;50-57 RESERVED FOR FAULT INSERTION
XPP SIXTY,60		;PLACE WHERE UNIMPLEMENTED INSTRUCTIONS ARE
			; STORED ON TRAP (PDP10 ONLY)

XPP ARSLOC,70		;POWER FAIL RESTART LOCATION
XPP KAFLOC,71		;KEEP ALIVE FAILURE RESTART LOCATION
XPP WRSINS,72		;WARM RESTART LOCATION
XPP LITES,77		;DUMP PERFORMANCE DATA HERE (METER UUO)
			; FOR SAMPLING WITH PROBES
XPP WRSLOC,100		;PC AND CODE STORED HERE ON WARM RESTART BY RSX-20F
	SUBTTL	DEVICE DATA BLOCK (DDB)




;;!=========================================================================!
;;!                          DEVICE NAME IN SIXBIT                          !
;;!-------------------------------------------------------------------------!
;;!LC!MD! !N!FREE !HTIME! HUNG TIMER  !F!            BUFFER SIZE          !
;;!-------------------------------------------------------------------------!
;;!                             IO STATUS WORD                              !
;;!-------------------------------------------------------------------------!
;;!              NEXT DDB              !       DEVICE SERVICE POINTER       !
;;!-------------------------------------------------------------------------!
;;!                   DEVICE CHARACTERISTICS (DEVCHR UUO)                   !
;;!-------------------------------------------------------------------------!
;;!                         LOGICAL NAME IN SIXBIT                          !
;;!-------------------------------------------------------------------------!
;;!        OUTPUT BUFFER HEADER        !        INPUT BUFFER HEADER         !
;;!-------------------------------------------------------------------------!
;;!          FLAGS           !   "R"    !       INPUT BUFFER TO FILL        !
;;!-------------------------------------------------------------------------!
;;!          FLAGS           !   "R"    !      OUTPUT BUFFER TO EMPTY       !
;;!-------------------------------------------------------------------------!
;;!                        DEVICE STATUS (LAST CONI)                        !
;;!-------------------------------------------------------------------------!
;;!SP!AV!L!R!  DEVTYP   !I! SPOOL BITS  !A!I!O!N!M!E!T!F!DSK PRI!U!-! STA # !
;;!-------------------------------------------------------------------------!
;;!                           EVM IN USE FOR I/O                            !
;;!-------------------------------------------------------------------------!
;;!IP!     IRF MASK     !    SPARE?     !   DEFER BITS    !   VECT. OFF.    !
;;!-------------------------------------------------------------------------!
;;!FO!FF!S! **FREE**  !   FOR FILSER    !     UNIT #      !      JOB #      !
;;!-------------------------------------------------------------------------!
;;!                           FILE NAME IN SIXBIT                           !
;;!-------------------------------------------------------------------------!
;;!             EXTENSION              !                                    !
;;!-------------------------------------------------------------------------!
;;!               PROJ #               !               PROG #               !
;;!=========================================================================!
	XP	DEVNAM,0	;NAME IN SIXBIT ASCII
				; C(LH)=DEVICE MNEMONIC
				; C(RH)=DEVICE NUMBER, LEFT JUSTIFIED
	XP	DEVCHR,1	;CHARACTERISTIC
;	XP	DEVSWP,DEVCHR	;WORD WHICH CONTAINS SWAPPER DDB FLAG BIT
;	XP	DEPSWP,400000	;BIT 0=SWAPPER DDB
				;BIT 0-***FREE FOR NOW***
	XP	DVCMDA,200000	;BIT 1-DEVICE IS CONTROLLED BY THE
				; MOUNTABLE DEVICE ALLOCATOR
	XP	DVLPTL,100000	;BIT 2=LOWER CASE LPT
	XP	DVDIBP,40000	;DEVICE IS A BATCH PTY
	XP	DVCNET,20000	;DEVICE CONTROLLED BY NETSER
	XP	DVOFLN,10000	;DEVICE WAS OFF-LINE THE LAST TIME THE
				; SERVICE ROUTINE WAS POLLED
	XP	DVC2IO,4000	;DEVICE CAN DO SIMULTANEOUS INPUT AND OUTPUT
	XP	HUNGST,400	;BITS 7-9 ARE A CODE FOR HUNG DEVICE
				; TIMEOUT. 0 MEANS DEVICE CANNOT BE HUNG
				; 1-7 MEANS HUNG TIME IS 2**N-1 SECONDS
				; POINTER = PDVTIM
				;BITS 10-16 ARE THE COUNTDOWN TIMER
				; FOR HUNG DEVICE. POINTER = PDVCNT
				; TRANSITION TO ZERO MEANS DEVICE HUNG
				; BITS 17-18 FREE
				; BITS 19-35=BUFFER SIZE
	XP	DEVIOS,2	;STATUS WORD.  SEE BELOW
	XP	DEVSER,3	;C(LH)=NEXT DEVICE DATA BLOCK
				; C(RH)=DEVICE SERVICE DISPATCH TABLE
;  DEVICE SERVICE DISPATCH TABLE ASSIGNMENTS
	XP	DOFL,-5		;DEVICE OFF-LINE?
	XP	DDVO,-4		;DEVOP UUO
	XP	DSZ,-3		;RETURN BUFFER SIZE
	XP	DINI,-2		;DEVICE INITILIZATION
	XP	DHNG,-1		;DEVICE IS HUNG
	XP	DRL,0		;RELEASE
	XP	DCL,1		;CLOSE
	XP	DCLO,DCL	;CLOSE OUTPUT
	;IMMEDIATE ADDRESS PART OF CLOSE UUO
		XP CLSOUT,1	;INHIBIT CLOSING OUTPUT
		XP CLSIN,2	;INHIBIT CLOSING INPUT
		XP CLSDLL,4	;INHIBIT DEALLOCATION ON CLOSE OUTPUT
		XP CLSACC,10	;INHIBIT UPDATE OF ACCESS DATE ON READS (AND BAT BLOCK ON ERR)
		XP CLSNMB,20	;INHIBIT DELETING NMB ON CLOSE WITH ONLY LOOKUP
		XP CLSRST,40	;RESET (INHIBIT SUPERSEDE/CREATE)
		XP CLSDAT,100	;DELETE ACCESS TABLE ON CLOSE
	XP	DOU,2		;OUTPUT
	XP	DIN,3		;INPUT.	SHORT DISPATCH TABLE
	XP	DEN,4		;ENTER
	XP	DLK,5		;LOOKUP
	XP	DDO,6		;DUMP MODE OUTPUT
	XP	DDI,7		;DUMP MODE INPUT
	XP	DSO,10		;SETO
	XP	DSI,11		;SETI
	XP	DGF,12		;GETF UUO
	XP	DRN,13		;RENAME
	XP	DCLI,14		;CLOSE INPUT
	XP	DCLR,15		;CALL D,[SIXBIT /UTPCLR/]
	XP	DMT,16		;MTAPE
		; END OF LONG DISPATCH TABLE
	XP	DEVMOD,4	;BIT 35-J=1 IF MODE J IS LEGAL FOR THIS DEVICE
				; BIT 18 DEVICE ASSIGNED BY CONSOLE COMMAND
				; BIT 19 DEVICE ASSIGNED BY PROGRAM (INIT)
				; SEE I/O STATUS WORD ASSIGNMENTS

;RIGHT HALF OF DEVICE CHARACTERISTICS WORD (DEVCHR UUO)
	XP	ASSCON,400000	;ASSIGNED BY CONSOLE COMMAND ASSIGN
	XP	ASSPRG,200000	;ASSIGNED BY PROGRAM (INIT UUO)
;LEFT HALF DEVICE CHARACTERISTICS (DEVCHR UUO)
	XP	DVOUT,1		;OUTPUT DEVICE
	XP	DVIN,2		;INPUT DEVICE
	XP	DVDIR,4		;HAS A DIRECTORY
	XP	DVTTY,10	;IS A TTY
	XP	DVMTA,20	;IS A MAG TAPE (REWIND)
	XP	DVAVAL,40	;1 IF DEVICE IS AVAILABLE TO THIS JOB
				; SET BY DEVCHR UUO
	XP	DVDTA,100	;IT IS A DECTAPE
	XP	DVPTR,200	;IS A PAPER TAPE READER
	XP	DVPTP,400	;IS A PAPER TAPE PUNCH
	XP	DVLNG,1000	;DEVICE HAS LONG DISPATCH TABLE
				; (OTHER UUOS BESIDES INPUT,OUTPUT,CLOSE,RELEASE)
	XP	DVDIS,2000	;IS A DISPLAY
	XP	TTYBIU,4000	;TTY DDB IN USE (AS I/O DEVICE EVEN IF
				; NOT AS USER CONSOLE)
	XP	TTYUSE,10000	;TTY DDB IN USE FLAG
	XP	TTYATC,20000	;TTY ATTACHED TO JOB IF 1
	XP	DVLPT,40000	;IS A LPT (CARRIAGE CONTROL IN FORTRAN)
	XP	DVCDR,100000	;IS A CARD READER (TRAILING SPACES FOR MACRO)
	XP	DVDSK,200000	;IS A DISK
	XP	DVDIRIN,400000	;DECTAPE DIRECTORY IN CORE IF 1 (MUST BE SIGN BIT)
	XP	DVCHN,DVMTA!DVDSK ;I/O IS DONE DIRECTLY TO MEMORY (KI10)



	XP	DEVLOG,5	;LOGICAL NAME FOR JOB DEVICE
	XP	DEVBUF,6	;C(LH)=REL. ADDRESS OF 3 WORD OUTPUT BUFFER HEADER
				; C(RH)=REL. ADDRESS OF 3 WORD INPUT BUFFER HEADER
	XP	DEVIAD,7	;C(LH)=R IN INDEX FIELD
				;BITS 1 AND 2 CONTAIN THE COUNT OF NUMBER OF USER
				; CHANNELS INIT'ED ON THIS DEVICE (DECTAPE ONLY)
				; IADPTR-COMMON BYTE POINTER TO 2 BIT COUNT
				;C(RH)=RELATIVE ADDRESS OF INPUT BUFFER THE
				; SERVICE ROUTINE IS FILLING.
	XP	DEVADR,DEVIAD
	XP	DEVOAD,10	;C(LH)=R IN INDEX FIELD
				;C(RH)=RELATIVE ADDRESS OF OUTPUT BUFFER THE
				; SERVICE ROUTINE IS EMPTYING.
	XP	DEVPTR,DEVOAD
	XP	DEVSTS,11	;WORD FOR DEVICE CONI
	XP	DEVSTA,12	;STATION NUMBER IN RIGHT 6 BITS
	XP	DEVDPR,DEVSTA	;BITS 26-29 = DISK PRIORITY
	 XP	DEPUUO,10	;PRIORITY SET BY A UUO
	 XP	MINDPR,4	;BITS 28-29 ARE NEGATIVE
				;BITS 28-29 ARE ACTUAL PRIORITY
	  XP	DEPDEL,2000	;DISABLE ERROR LOGGING ON THIS DEVICE BIT 25
	  XP	DEPDER,4000	;DISABLE ERROR RECOVERY ON THIS DEVICE BIT 24
	  XP	DEPEVM,10000	;IF 1, DEVICE DOESN'T NEED EVM ON KI10 TO DO I/O
	XP	DEVAIO,DEVSTA	;ASYNCHRONOUS IO
	 XP	DEPAIO,400000	;DOING ASYNC. IO
	 XP	DEPIND,200000	;INPUT NOT YET DONE
	 XP	DEPOND,100000	;OUTPUT NOT YET DONE

	XP	DEVMSG,DEVSTA	;MSGSER FLAGS
	 XP	DEPECS,40000	;BIT 21 ON IF A NON-SUPERSEDE ENTER
	 XP	DEPMSG,20000	;THIS DEVICE IS CONTROLLED BY MSGSER
	  XP	DEVSPL,DEVSTA	;BITS 11-17=SPOOL BITS
	 XP .SPLPT,1		;LINE PRINTER SPOOL BIT
	 XP .SPPLT,2		;PLOTTER SPOOL BIT
	 XP .SPPTP,4		;PTP SPOOL BIT
	 XP .SPCDP,10		;CDP SPOOL BIT
	 XP .SPCDR,20		;CDR SPOOL BIT
	 XP .SPALL,37		;CHANGE SPALL IF ADD NEW SPOOLING DEVS
	XP DEPIBC,200		;INHIBIT CLEARING OUTPUT BUFFERS
	 XP DERRAS,100		;RIGHT ADJUSTED.
	 XP DERLEN,200		;RIGHT-ADJUSTED
	  XP	DEVTYP,DEVSTA	;BITS 4-9=CLASS (DEVTYP UUO)
	 XP .TYEST,400		;RIGHTMOST BIT OF CLASS-BYTE
	 XP .TYDSK,0		;DISK
	 XP .TYDTA,1		;DTA
	 XP .TYMTA,2		;MTA
	 XP .TYTTY,3		;TTY
	 XP .TYPTR,4		;PTR
	 XP .TYPTP,5		;PTP
	 XP .TYDIS,6		;DISPLAY
	 XP .TYLPT,7		;LPT
	 XP .TYCDR,10		;CDR
	 XP .TYCDP,11		;CDP
	 XP .TYPTY,12		;PTY
	 XP .TYPLT,13		;PLT
	 XP .TYXTC,14		;EXTERNAL TASK
	 XP .TYMPX,15		;MPX
	 XP .TYPAR,16		;PA611R READER
	 XP .TYPCR,17		;PC-11 READER ON DC44
	 XP .TYPAP,20		;PA611P PUNCH ON DC44
	 XP .TYLPC,21		;LPC-11 TYPESET INTERFACE ON DC44
	 XP .TYPCP,22		;PC-11 PUNCH ON DC44
	 XP .TYWTY,23		;WTY DEVICE ON DC44
	 XP .TYTSK,24		;REMOTE NETWORK TASK
	 XP .TYD78,25		;DAS78 DEVICE (NOW OBSOLETE)
	 XP .TYRDA,26		;REMOTE DATA ENTRY DEVICE
	 XP .TYMCR,27		;HOST COMMAND INTERPRETER
	 XP .TYDRA,30		;DRA
	 XP .TYKDP,31		;KMC/DUP COMM GEAR
	 XP .TYDTE,32		;DTE-20 COMM DEVICE
	 XP .TYDDP,33		;ANF-NETWORK DDCMP DEVICE
	 XP .TYDMR,34		;DMR11 AS A NETWORK DEVICE
	 XP .TYRX2,35		;RX20 FLOPPY DISK CONTROLLER
	 XP .TYKLP,36		;CI20 (KLIPA)
	 XP .TYKNI,37		;NIA20 (KLNI)
	 XP .TYSAX,40		;SA10
	XP TYPMAX,40		;HIGHEST DEVICE TYPE
	 XP DEPRAS,40000	;BIT 3=1 IF DEVICE HAS RESTRICTED ASSIGNMENT
	 XP DEPLEN,100000	;BIT 2=1 IF VARIABLE LENGTH BUFFERS
				;BIT 1=1 IF A DSK IN 10/11 COMPATABILITY MODE
	XP	DEVADV,DEVSTA	;DON'T ADVANCE BUFFERS ON INTERCEPT
	 XP	DEPADV,200000	; IF DEPADV IS ON
	 XP DEPSPL,400000	;THIS DDB IS FOR A SPOOLED DEVICE
	XP	DEVXTR,13	;EXTRA WORD

;DEVXTR USEAGE BY MSGSER:
;	IF THIS IS AN MPX DDB:
;	LH = ADDRESS OF CONNECTED DEVICE TABLE
;	RH = NUMBER OF CONNECTED DEVICES
;	IF THIS IS A DDB CONTROLED BY MSGSER:
;	LH = FLAGS (SAME DEFS AS LH OF USRJDA)
;	RH = ADDRESS OF MPX DDB

;DEVXTR BITS USED BY FILSER (DEFINED IN COMMOD):

;DEVUVA=LH
;DEVPRI=BITS 18-20
;DEPWRT=BIT 21
;DEVBFN=BITS 22-30
;DEPPAL=BIT 31
;DEPALC=BIT 32

	XP	DEVEVM,14	;WORD TO KEEP TRACK OF EXEC VIRTUAL MEMORY
				; THIS DEVICE HAS

	XP	DEVPSI,15	;WORD TO KEEP TRACK OF SOFTWARE INTERRUPTS
				; FOR THIS DEVICE. LH-ENABLE COND. RH-PENDING INTS.
	XP	DEVESE,16	; 0-17 PSISER DEVICE LINK
				;18-26 PSISER VECTOR INTERRUPT
				;27-35 EXTENDED SOFTWARE ERROR STATUS
	XP	DEVHCW,17	;HARDWARE CHARACTERISTICS WORD
				;LINEPRINTER HARDWARE CHARACTERISTICS
	  XP	HC.LCP,1B0	;LOWER CASE PRINTER
	  XP	HC.PGC,1B1	;LPT HAS A PAGE COUNTER
	  XP	HC.VFT,7B5	;VFU TYPE
	    XP	  .HCVTO,0	;  OPTICAL (PAPER TAPE) VFU
	    XP	  .HCVTD,1	;  DIRECT ACCESS VFU (DAVFU)
	    XP	  .HCVTN,2	;  NO VFU (HDW HANDLES LF,FF,CR)
	  XP	HC.CST,7B8	;CHARACTER SET TYPE
	    XP	  .HCC64,0	;  64 CHARACTER SET
	    XP	  .HCC95,1	;  95 CHARACTER SET
	    XP	  .HCC28,2	;  128 CHARACTER SET
	    XP	  .HCCVR,3	;  VARIABLE CHARACTER SET
	  XP	HC.TYP,7B11	;LPT TYPE
	    XP	  .HCTUK,0	;UNKNOWN
	    XP	  .HCTBX,1	;BA10
	    XP	  .HCTLC,2	;LP100
	    XP	  .HCT20,3	;LP20
	  XP	HC.TYU,7B14	;LPT CLASS (UNIT TYPE)
	    XP	  .HCUUK,0	;UNKNOWN/UNSPECIFIED
	    XP	  .HCULP,1	;LP05/ETC.
	    XP	  .HCULN,2	;LN01/ETC.
	  XP	HC.CSN,<0,,-1>	;CHARACTER SET NAME (3 SIXBIT CHRS)

	XP	DEVCPU,20
				;BITS 0-2 CPU NUMBER FOR 1ST CPU OWNING DEVICE
				;BITS 3-5 CPU NUMBER FOR 2ND CPU OWNING DEVICE
				;BITS 6-8 QUEUE-PROTOCOL NO FOR DEVICE (=0 IF RESCHEDULE)
				;BITS 9-11 CPU ON WHICH IN OR OUT LAST DONE
	  XP	DEPCPS,40	;BIT 12=1 IF BITS 30-32 ARE VALID (DEV ON 2 CPUS)
				;BITS 13-17=0
				;RH=ADR OF INTERLOCK WORD (SET AT INTLOP)
	XP	DEVISN,21	;SECTION NUMBER FOR I/O
	  XP	DEPSOO,(1B0)	;AN IOWD IS ALLOWED TO CROSS A SECTION BOUNDARY
				; MUST BE THE SIGN BIT
IFE FTXMON,<
;NOTE THAT DEVISN IS ALLOCATED BUT NOT USED IF FTXMON IS OFF!
>
	XP	DEVDRV,22	;DRIVER DISPATCH
	XP	DEVJOB,23	;JOB AND UNIT NUMBERS

;DEVLSD SHOULD ALWAYS BE EQUAL TO DEVJOB+1 USED BY SYSTAT
;ALSO, MANY PROGRAMS BELIEVE DEVJOB+1=DEVFIL SO NEW ENTRIES
; IN THE SHORT DDB SHOULD BE BEFORE DEVJOB
	XP	DEVLSD,DEVJOB+1	;LENGTH OF SHORT DDB
	  XP	DEPFOP,(1B0)	;BIT 0 = 1 IF FILOP. UUO IS IN PROGRESS
	  XP	DEPFFA,(1B1)	;INHIBIT FULL-FILE ACCESS
	  XP	DEPSIM,(1B2)	;DDB IS ENABLED FOR SIMULTANEOUS UPDATE
	  XP	DEPSIE,(1B3)	;SYNCHRONIZE I/O ERROR (SET ON OPEN)
	 XP	DEPALW,(1B4)	;ALLOCATION IS IN WORDS
				;***BITS 5 AND 6 ARE FREE***
				;BITS 7-17 ARE USED BY FILSER
				;BITS 18-26 ARE UNIT NUMBER (PUNIT)
				;BITS 27-35 ARE THE JOB NUMBER (PJOBN)
	XP	DEVCTR,24
	XP	DEVCID,DEVCTR	;CURRENT INPUT DEVICE (USED BY MSGSER
				; TO ROUND ROBIN INPUT DEVICES)
;FOR LONG DISPATCH TABLE DEVICES ONLY:
	XP	DEVFIL,24	;FILE NAME IN SIXBIT
	XP	DEVEXT,25	;LH=EXTENSION, RH=UNUSED
	XP	DEVPPN,26	;PROJECT,PROGRAMMER NUMBER (DISK ONLY)
				; OTHER DEVICES NEED NOT HAVE THIS LOCATION IN THEM.
	XP	DEVLLD,DEVPPN+1	;LENGTH OF LONG DDB
IFN FTKL10&FTMP,<
	XP	DEVNBF,27	;NO. OF BUFFERS SWEPT FOR (QUEUED PROTOCOL ONLY)
	XP	DEVSBF,30	;COPY OF DEVNBF WHEN SWITCHING INPUT/OUTPUT
	XP	DEVCSN,31	;CACHE SWEEP NO. (QUEUED PROTOCOL)
>

	XP	DEVLEN,32	;LENGTH OF COMMON DDB
	SUBTTL	FLAG BITS -- S AND DEVIOS(F)

; I/O STATUS WORD ASSIGNMENTS - THESE ARE THE "MODE" OF DEVMOD
;DATA MODES: BITS 32-35 (BYTE POINTER=PIOMOD)
	XP	A,0		;ASCII
	XP	AL,1		;ASCII LINE
	XP	PIMMOD,2	;PACKED IMAGE MODE
	XP	BYTMOD,3	;BYTE-MODE
	XP	A8,4		;8-BIT ASCII MODE
	XP	I,10		;IMAGE
	XP	IB,13		;IMAGE BINARY
	XP	B,14		;BINARY
	XP	SD,15		;SCOPE DUMP MODE
	XP	DR,16		;DUMP BY RECORDS
	XP	D,17		;DUMP ACROSS RECORDS
; STATUS BITS
;RIGHT HALF (USER)
	XP	IOWC,20		;DON'T COMPUTE WORD COUNT
	XP	IOCON,40	;CONTINUOUS (CONT=0)
	XP	IONRCK,100	;READ WITH NO REREAD CHECK
;BITS 27,28	DENSITY OF MAG TAPE
;		00=INSTALLATION STANDARD
;		01=200 BPI
;		10=556 BPI
;		11=800 BPI
	XP	IOPAR,1000	;WRITE EVEN PARITY (BCD) IF 1 ON MAG TAPE
	  XP	IOHDER,1000	;ON IF SEARCH ERROR
				; NEVER STORED IN DDB, ONLY USED
				; IN CALLS BETWEEN CONTROLLER ROUTINES
	XP	IOTEND,2000	;END OF MAG TAPE
	  XP	IOVRUN,2000	;ON IF AN OVERRUN
				; NEVER STORED IN DDB, ONLY USED IN
				; CALLS BETWEEN CONTROLLER ROUTINES
	XP	IOBOT,4000	;BEGINNING OF MAG TAPE
	  XP	IOECCX,4000	;ECC RECOVERABLE ERROR
				; NOTE:NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER
	XP	IOACT,10000	;DEVICE ACTIVE
	  XP	IOCHNX,10000	;CHANNEL DETECTED NON-EX MEM OR DATA LATE (OVER-RUN)
				; NOTE: NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER ROUTINES
	XP	IODEND,20000	;DATA END ENCOUNTERED
	  XP	IOCHMP,20000	;CHANNEL DETECTED MEMORY PARITY ERROR
				; NOTE: NEVER STORED IN MEMORY IN DDB.
				; ONLY USED IN CALLS BETWEEN CONTROLLER ROUTINES.
	XP	IOBKTL,40000	;BLOCK TOO LARGE
	XP	IODTER,100000	;DATA ERROR-IE HARDWARE OR SOFTWARE PARITY AND/OR
				; CHECKSUM INDICATES DATA MAY BE BAD
	XP	IODERR,200000	;DEVICE ERROR-IE THE DEVICE IS BAD
				; THE DATA IS PROBABLY INTACT ON THE MEDIUM
				; IF READING (USUAL)
				; THE DATA IS PROBABLY INCORRECTLY WRITTEN
				; ON THE MEDIUM
				;  IF WRITING (UNUSUAL)
	XP	IOIMPM,400000	;IMPROPER MODE DETECTED BY UUOCON OR DEVICE
				; SERVICE ROUTINE
		IOERR=IOBKTL!IODTER!IODERR!IOIMPM  ;ALL ERROR BITS
; LEFT HALF (SYSTEM)
	XP	IOW,1		;I/O WAIT
	XP	IOBEG,2		;VIRGIN DEVICE
	XP	IOFST,4		;NEXT ITEM WILL BE THE FIRST ITEM OF A BUFFER
	XP	IOSTBL,10	;DEVICE ERROR FLAG
	XP	IO,20		;OUT=1, IN=0
	XP	IOEND,40	;SERVICE ROUTINE HAS TRANSMITTED LAST DATA
	XP	IOSDMR,100	;TSKSER ONLY. DISABLE MESSAGE RE-ASSEMBLY

;REST OF BITS IN LH ARE DEVICE DEPENDENT
;COMMAND DECODER USE OF AC S:

;RH=DISPATCH ADDRESS - SAVJOB,GETJOB,RUNJOB
;LH:
	XP	NSRBIT,400000	;HIGH SEG TO BE FLAGGED NON-SHARABLE (SAVE VS SSAVE
				; COMMAND) DO NOT CONFUSE WITH SIGN BIT OF JBTSTS
				; WHICH SAYS SEG IS SHARABLE
	SUBTTL	FLAG BITS -- UUOS

;BITS FOR DETERMINING IF UUO REFERS TO PHYSICAL DEVICES ONLY
	XP	UPHNLY,200000	;UPHNLY NOT= BIT 18 IF PHYS ONLY
	XP	PHONLY,400000	;BIT ON IN LH(W) IF PHYS ONLY


;BITS IN LH OF FIRST (0) ARG OF OPEN UUO
	XP	.OPPDO,400000	;PHYSICAL DEVICE ONLY (NO LOGICAL)
	XP	.OPDEL,200000	;DISABLE ERROR LOGGING (DAEMON
				; COUNTS NOT UPDATED - SYSERR NOT UPDATED)
				; USED BY USER MODE
	XP	.OPFSP,.OPDEL	;FULL SCNSER PTY
	XP	.OPDER,100000	;DISABLE ERROR RETRY
				; USED BY MODE DIAGNOSTIC
	XP	.OPBJP,.OPDER	;BATCH JOB PTY
	XP	.OPDMR,.OPBJP	;TSKSER ONLY. DISABLE MESSAGE RE-ASSEMBLY
	XP	.OPAIO,40000	;ASYNCHRONOUS (NON-BLOCKING) I/O
	XP	.OPIBC,20000	;INHIBIT OUTPUT BUFFER CLEARING
	XP	.OPSIE,10000	;SYNCHRONIZE I/O ERRORS
	XP	.OPRRC,4000	;REWRITE RIB ON CHANGE
	XP	.OPLBF,2000	;USE LARGE DISK BUFFERS
	XP	.OPALL,776000	;ALL THE ABOVE OPEN BITS. USED TO TEST
				; FOR UNDEFINED BITS BEING SET.
;BITS RETURNED BY DEVTYP UUO(LH)
	XP	.TYMAN,400000	;LOOKUP/ENTER MANDATORY
	XP	.TYAVL,DVAVAL
	XP	.TYSPL,20	;DEVICE BEING SPOOLED ONTO DISK
	XP	.TYINT,DVTTY
	XP	.TYVAR,4	;USER CAN SET VARIABLE-LENGTH BUFFERS
	XP	.TYIN,DVIN
	XP	.TYOU,DVOUT
	XP	TY.MPX,(1B11)	;RETURNED IF CNECT. WILL WORK
	XP	TY.LL,(1B10)	;IF LPT THEN LOWER CASE
	XP	TY.MDA,(1B9)	;DEVICE IS CONTROLLED BY MDA
	XP	TY.GEN,(1B8)	;DEVICE IS GENERIC
;BITS IN RH OF EXTENDED LOOKUP WORD 0
	XP	RB.NSE,1B18	;NON-SUPERSEDING ENTER
	XP	RB.DSL,1B19	;DON'T SEARCH LIB
	XP	RB.AUL,1B20	;ALLOW UPDATE/RENAME IN LIB
	XP	RB.NLB,1B21	;NO LOAD BALANCING
	XP	RB.BIT,RB.NSE!RB.DSL!RB.AUL!RB.NLB

;BIT IN LH (UUO) - FOR LOCAL (TEMPORARY USE) ONLY
	XP	GENSRC,400000	;BIT SET IF DVASRC SUCCESS
				;FROM UUOCON INIT CALL
;UNIVERSAL I/O INDEX VALUES, FOR STANDARDIZED I/O UUO'S
;PREFIX .UX
	XP	.UXCHN,0	;I/O CALLED BY CHANNEL NUMBER (AC OF UUO'S)
	XP	.UXTRM,200000	;I/O CALLED BY TERMINAL INDEX
;LEFT HALF USRJDA (JOB DEVICE ASSIGNMENTS) UUO'S FOR THIS CHANNEL SINCE LAST INIT
;SET IN LH OF F NOT= BIT 18 IF PHYS ONLY
	XP	PHONLY,400000	;BIT ON IN LH(W) IF PHYS ONLY


;BITS IN LH OF FIRST (0) ARG OF OPEN UUO
	XP	.OPPDO,400000	;PHYSICAL DEVICE ONLY (NO LOGICAL)
	XP	.OPDEL,200000	;DISABLE ERROR LOGGING (DAEMON
				; COUNTS NOT UPDATED - SYSERR NOT UPDATED)
				; USED BY USER MODE
	XP	.OPFSP,.OPDEL	;FULL SCNSER PTY
	XP	.OPDER,100000	;DISABLE ERROR RETRY
				; USED BY MODE DIAGNOSTIC
	XP	.OPBJP,.OPDER	;BATCH JOB PTY
	XP	.OPDMR,.OPBJP	;TSKSER ONLY. DISABLE MESSAGE RE-ASSEMBLY
	XP	.OPAIO,40000	;ASYNCHRONOUS (NON-BLOCKING) I/O
	XP	.OPIBC,20000	;INHIBIT OUTPUT BUFFER CLEARING
	XP	.OPSIE,10000	;SYNCHRONIZE I/O ERRORS
	XP	.OPRRC,4000	;REWRITE RIB ON CHANGE
	XP	.OPLBF,2000	;USE LARGE DISK BUFFERS
	XP	.OPCFS,1000	;CFP SUPPLIED ON LOOKUP
	XP	.OPALL,777000	;ALL THE ABOVE OPEN BITS. USED TO TEST
				; FOR UNDEFINED BITS BEING SET.
;BITS RETURNED BY DEVTYP UUO(LH)
	XP	.TYMAN,400000	;LOOKUP/ENTER MANDATORY
	XP	.TYAVL,DVAVAL
	XP	.TYSPL,20	;DEVICE BEING SPOOLED ONTO DISK
	XP	.TYINT,DVTTY
	XP	.TYVAR,4	;USER CAN SET VARIABLE-LENGTH BUFFERS
	XP	.TYIN,DVIN
	XP	.TYOU,DVOUT
	XP	TY.MPX,(1B11)	;RETURNED IF CNECT. WILL WORK
	XP	TY.LL,(1B10)	;IF LPT THEN LOWER CASE
	XP	TY.MDA,(1B9)	;DEVICE IS CONTROLLED BY MDA
	XP	TY.GEN,(1B8)	;DEVICE IS GENERIC
;BITS IN RH OF EXTENDED LOOKUP WORD 0
	XP	RB.NSE,1B18	;NON-SUPERSEDING ENTER
	XP	RB.DSL,1B19	;DON'T SEARCH LIB
	XP	RB.AUL,1B20	;ALLOW UPDATE/RENAME IN LIB
	XP	RB.NLB,1B21	;NO LOAD BALANCING
	XP	RB.BIT,RB.NSE!RB.DSL!RB.AUL!RB.NLB

;BIT IN LH (UUO) - FOR LOCAL (TEMPORARY USE) ONLY
	XP	GENSRC,400000	;BIT SET IF DVASRC SUCCESS
				;FROM UUOCON INIT CALL
;UNIVERSAL I/O INDEX VALUES, FOR STANDARDIZED I/O UUO'S
;PREFIX .UX
	XP	.UXCHN,0	;I/O CALLED BY CHANNEL NUMBER (AC OF UUO'S)
	XP	.UXTRM,200000	;I/O CALLED BY TERMINAL INDEX
;LEFT HALF USRJDA (JOB DEVICE ASSIGNMENTS) UUO'S FOR THIS CHANNEL SINCE LAST INIT
;SET IN LH OF F AT BEGINNING OF UUO,STORED IN MEMORY(USRJDA) IF UUO IS SUCCESSFUL
	XP	INITB,400000	;INIT-SAVEGET DEPENDS ON THIS BEING SIGN BIT
	XP	IBUFB,200000	;INIT WITH INPUT BUFFER SPECIFIED
	XP	OBUFB,100000	;INIT WITH OUTPUT BUFFER SPECIFIED
	XP	LOOKB,40000	;LOOKUP
	XP	ENTRB,20000	;ENTER
	XP	INPB,10000	;INPUT
	XP	OUTPB,4000	;OUTPUT
	XP	ICLOSB,2000	;INPUT CLOSE
	XP	OCLOSB,1000	;OUTPUT CLOSE
	XP	INBFB,400	;INBUF
	XP	OUTBFB,200	;OUTBUF
	XP	SYSDEV,100	;THIS DEVICE IS SYSTEM TAPE OR SYSPPN ON DISK
	XP	RENMB,40	;RENAME UUO IN PROGRESS (NEVER STORED IN MEMORY)
	XP	DSKRLB,20	;TO DISTINGUISH RELEASE FROM RESET UUO IN DSKSER.
				; RELEASE CLEARS THEM ALL - LEVEL C
	XP	RESETB,20	;RESET UUO IN PROGRESS - LEVEL D (NEVER STORED IN MEMORY)

;MTAPE UUO BITS
	XP	SLICE,40	;SET SLICE LEVEL IF A 1 ACCORDING TO SLEVEL
	XP	SLEVEL,20	;VALUE OF SLICE LEVEL IF SLICE A 1

	SUBTTL	FLAG BITS -- ACCLG. UUO

AC.MAX==1B0	;CHECK LOGMAX
AC.BMX==1B1	;CHECK BATMAX
AC.DCR==1B2	;DECREMENT LOGNUM COUNT

;ERROR CODES
	ACLMX%==1		;LOGMAX CHECK FAILED
	ACLBM%==2		;BATMAX CHECK FAILED
	ACLIL%==3		;ACCLG. ARGUMENT ERROR
	ACLJL%==4		;ACCLG. GOT BAD DECREMENT WITH JLOG SET
	ACLDC%==5		;ACCLG. ERROR, DECR TRIED WITHOUT INCR DONE

	SUBTTL	FLAG BITS -- JOBPEK UUO

	XP	JK.WRT,1B0	;1=WRITE, 0=READ
	XP	JK.UPM,1B1	;READ UPMP OF SPECIFIED JOB
	XP	JK.EVA,1B2	;SOURCE ADDRESS IS BETWEEN 340000 AND
				;377777.  TREAT IT AS IF IT WERE AN
				;EXEC VIRTUAL ADDRESS MAPPED THROUGH THE
				;SPECIFIED JOB'S UPMP
	XP	JK.AIO,1B3	;DO NOT BLOCK IF DATA INACCESSIBLE
				; (ONLY IF JK.UPM OR JK.EVA)
	XP	JK.ALL,777B8	;ALL POSSIBLE FLAGS

;ERROR CODES
	JKNPV%==1		;JOB NOT PRIVILEGED
	JKIJN%==2		;ILLEGAL JOB NUMBER
	JKSWP%==3		;JOB SWAPPED OR IN TRANSIT
	JKIAD%==4		;ILLEGAL ADDRESS
	JKDNA%==5		;DATA NOT ADDRESSABLE
	JKPNC%==6		;PAGE NOT IN CORE
	JKIOE%==7		;I/O ERROR READING SWAPPING SPACE
	JKABZ%==10		;ALLOCATED BUT ZERO PAGE

	SUBTTL	FLAG BITS -- JOBSTS UUO

JB.UJA==1B0	;JOB NUMBER ASSIGNED
JB.ULI==1B1	;JOB IS LOGGED IN
JB.UML==1B2	;TTY IS AT MONITOR LEVEL
JB.UOA==1B3	;OUTPUT IS AVAILABLE
JB.UDI==1B4	;TTY IS DEMANDING INPUT
JB.UJC==1B5	;JACCT IS SET
JB.URN==1B6	;JOB IS RUNNING
JB.UFC==1B7	;TTY IN FULL CHARACTER SET
JB.UBK==1B8	;TTY IN BREAK ON ALL CHARACTERS MODE
;JB.UII==1B9	;TTY IS IN IMAGE INPUT MODE
;JB.UIO==1B10	;TTY IS IN IMAGE OUTPUT MODE
JB.UNE==1B11	;TTY IS NO ECHO (A LA LOGIN, INDEPENDENT OF LOCAL COPY)
JB.UTO==1B12	;TTY IS BLOCKED IN 'TO' STATE
JB.UCC==1B13	;TTY CHARACTERISTICS (WIDTH, LC, TABS, ETC.) CHANGED
JB.UNT==1B14	;TTY IS NETWORKED (.SET HOST) TO A REMOTE HOST
JB.UHI==1B15	;TTY IS HIBERING FOR INPUT
	SUBTTL  FLAG BITS -- PAGE ACCESSIBILITY UUO

PA.NXP==1B0		;NON-EXISTENT PAGE
PA.WRT==1B1		;WRITE ACCESS
PA.RED==1B2		;READ ACCESS (OFF IFF LIP=1 & JS.XO=0)
PA.AA==1B3		;ACCESS ALLOWED
PA.ZER==1B4		;ZERO PAGE (ALLOCATED ON DSK)
PA.CPO==1B5		;CAN'T BE PAGED OUT
PA.OUT==1B6		;PAGE IS PAGED OUT
PA.GHI==1B7		;PAGE IS PART OF HIGH SEG
PA.GSH==1B8		;PAGE IS SHARABLE
PA.GSP==1B9		;PAGE IS SPYING ON RUNNING MONITOR
PA.LCK==1B10		;PAGE IS LOCKED
PA.NCS==1B11		;PAGE IS NOT CACHED
PA.NXS==1B12		;PAGE IS IN A NON-EXISTENT SECTION
PA.VSP==1B13		;PAGE IS VIRTUAL SPY PAGE
PA.IND==1B14		;PAGE IS IN INDIRECT SECTION
			;BIT 15 RESERVED
PA.ISN==37B20		;IDEPENDENT SECTION # IF PA.IND LIT
			;BIT 21 RESERVED
PA.IID==1B30
PA.SPN==37777		;SPY PAGE # IF PA.GSP LIT
PA.SGN==1777		;SEGMENT # PAGE IS IN IF PA.GHI LIT

	PA.BTS==PA.NXP!PA.WRT!PA.RED!PA.AA!PA.ZER!PA.CPO!PA.OUT!PA.GHI!PA.GSH!PA.GSP!PA.LCK!PA.NCS!PA.NXS!PA.VSP

	SUBTTL  FLAG BITS -- PAGE. UUO
PG.GAF==1B0		;GENERALIZE ARGUMENT FLAG
PG.SLO==1B1		;ON IF PAGE ONTO SLOW SWAPPING SPACE
PG.DSK==1B1		;ON IF CREATE A PAGE ON DSK
PG.IDC==1B2		;I DON'T CARE

	SUBTTL	PAGE. UUO -- FUNCTION CODES
.PAGIO==0			;SWAP A PAGE IN/OUT
.PAGCD==1			;CREATE/DESTROY A PAGE
.PAGEM==2			;MOVE/EXCHANGE A PAGE
.PAGAA==3			;CLEAR/SET ACCESS ALLOWED
.PAGWS==4			;GET THE WORKING SET
.PAGGA==5			;GET ACCESS ALLOWED
.PAGCA==6			;GET PAGE ACCESSIBILITY
.PAGRM==7			;GENERALIZED REMAP
.PAGCS==12			;CREATE A SECTION
.PAGWL==16		;WRITE LOCK/ENABLE SPECIFIED PAGES

	SUBTTL	PAGE. UUO -- ERROR CODES
PAGUF%==0			;UNIMPLEMENTED FUNCTION
PAGIA%==1			;ILLEGAL ARGUMENT
PAGIP%==2			;ILLEGAL PAGE NUMBER
PAGCE%==3			;PAGE CAN'T EXIST, BUT DOES
PAGME%==4			;PAGE MUST EXIST, BUT DOESN'T
PAGMI%==5			;PAGE MUST BE IN CORE, BUT ISN'T
PAGCI%==6			;PAGE CAN'T BE IN CORE, BUT IS
PAGSH%==7			;PAGE IS IN A SHARABLE HIGH SEGMENT
PAGIO%==10			;PAGING I/O ERROR
PAGNS%==11			;NO SWAPPING SPACE AVAILABLE
PAGLE%==12			;CORE LIMIT EXCEEDED
PAGIL%==13			;NOT ALLOWED IF LOCKED
PAGNV%==14			;ATTEMPT TO CREATE A VIRTUAL PAGE WITH CVPL=0
PAGNP%==15			;NOT PRIVILEGED
PAGSC%==16			;SECTION CAN'T EXIST
PAGSM%==17			;SECTION MUST EXIST
PAGIS%==20			;ILLEGAL SECTION
PAGAL%==21			;PAGE ALREADY LOCKED
PAGAU%==22			;PAGE ALREADY UNLOCKED (MUST BE CONTIGUOUS
				;WITH PALERR)
PAGNA%==23			;PAGE NOT AVAILABLE (E.G. PHYS PAGE REQ'D
				;TO BE LOCKED IS IN A LOCKED JOB, ETC.)
PAGNR%==24			;NO ROOM TO LOCK
PAGNE%==25			;INSUFFICIENT EVM AVAILABLE FOR LOCKING
PAGNN%==26			;NO FREE SEGMENT #S
PAGNC%==27			;NO FREE CORE
PAGWL%==30			;ALREAD WRITE-LOCKED
PAGWE%==31			;ALREADY WRITE-ENABLED
	SUBTTL	LOKCON VALUES

;ERROR CODES FOR LOKCON

LKERR1==1
LKERR2==2
LKERR3==3
LKERR4==4
LKERR5==5
LKERR6==6

;FORMAT 1 BITS (HIGH-SEG,,LOWSEG)
LKB==1
LKEB==2
LKPB==4
LKCB==10
LKAB==20

;FORMAT 2 FUNCTION CODES:
	.LKPPN==0		;SPECIFIC PHYSICAL PAGE LOCK
	.LKSGL==1		;SEGMENT LIST FORMAT
;FORMAT 2 FOR LOCK AND UNLOCK
;FUNCTION CODES:
;BITS:
	L2PPN==3777B17		;PHYSICAL PAGE (OR EVM) VALUE
	L2SGN==777B35		;SEGMENT NUMBER FIELD (0=LOW SEG)
	SUBTTL	BITS FOR TESTING UUOS

XP	UU.CP1,400000		;UUO CAN BE EXECUTED ON CPU1
XP	UU.SE1,200000		;UUO CAN BE EXECUTED IN SECTION 1
XP	UU.PCS,100000		;UUO USES SECTION-LOCAL ADDRESSES (LEAVE PCS ALONE)

;BITS 30-35 = N,  CHECK FROM START (PC+1 OR EA) TO START+N-1

XP	UU.EA,100		;CHECK EFFECTIVE ADDRESS
XP	UU.CAC,200		;USE C(AC)
XP	UU.CEA,400		;USE C(EFECT.ADR)
XP	UU.MNS,1000		;MINUS
XP	UU.LER,2000		;LOOKUP/ENTER/RENAME
XP	UU.LFT,4000		;USE LEFT HALF
XP	UU.NAL,10000		;NOT ALLOWED IF LOCKED
XP	UU.WCC,20000		;WORKING SET CAN CHANGE
XP	UU.NCL,40000		;NEGATIVE ARGUMENT (REPEAT) COUNT IS LEGAL
XP	UU.MSK,7777		;ANY CHECK AT ALL

;COMPOSITE MASKS
XP	UU.LEA,UU.EA+UU.CAC+UU.LFT ;CHECK EA TO EA+C(LH(AC))
XP	UU.MEA,UU.LEA+UU.MNS	;CHECK EA TO EA-C(LH(AC))
	SUBTTL	SCHED. UUO ERROR CODES
SCHAC%==1			;ADDRESS CHECK
SCHUF%==2			;UNKNOWN FUNCTION
SCHUJ%==3			;UNKNOWN JOB
SCHNP%==4			;NOT PRIVILEGED
SCHUC%==5			;UNKNOWN CLASS
SCHUQ%==6			;UNKNOWN QUEUE
SCHNC%==7			;NON-EXISTANT CHANNEL
SCHEB%==10			;EXPONENTIAL FACTOR BAD
SCHMI%==11			;ATTEMPT TO SET PROT WHEN MCUINT NON-ZERO
;SCHNS%==12			;ATTEMPT TO USE SCHED. UUO WHEN
				; NON-CLASS SCHEDULER WAS RUNNING (OBSOLETE)
SCHNH%==13			;NOT 100%
SCHFN%==14			;FAIRNESS NOT POSITIVE
SCHIC%==15			;ILLEGAL CPU
SCHIS%==16			;ILLEGAL SCAN ORDER

	SUBTTL	TRMOP. UUO ERROR CODES
TRMNP%==1			;NOT PRIVILEGED
TRMBR%==2			;BAD RANGE
TRMIA%==3			;ILLEGAL ADDRESS
TRMCD%==4			;CANNOT DO SPECIFIED FUNCTION
TRMDO%==5			;DIALLER OPERATION ERROR
TRMND%==6			;CANNOT GET DDB
TRMNB%==7			;NOT IN BREAK SET MODE
TRMIB%==10			;ILLEGAL BYTE SIZE
TRMNT%==11			;NOT A NETWORK TERMINAL



	SUBTTL DTE. UUO ERROR CODES

DTENP%==1			;NOT PRIVILEGED
DTEUF%==2			;UNKNOWN FUNCTION CODE
DTEDC%==3			;UNKNOWN CPU NUMBER OR DTE NUMBER
DTEAP%==4			;ALREADY RUNNING PRIMARY PROTOCOL
DTEPT%==5			;POWER FAIL TIMEOUT ERROR
DTEDE%==6			;DEAD 11 - NO DOORBELL FROM 11 DURING BOOTSTRAP SEQUENCE
DTTTE%==7			;TO-10 ERROR AFTER BOOT SEQUENCE
DTEDD%==10			;NO RESPONSE FROM 11 AFTER BOOT SEQUENCE
DTEIJ%==11			;ILLEGAL JOB NUMBER SPECIFIED.
DTEIB%==12			;ILLEGAL BYTE COUNT TO FRONT END DEVICE
DTENI%==13			;FAILURE TO DO INITIALIZE FUNCTION ON FRONT END
				; DEVICE BEFORE USING IT
DTEFB%==14			;FRONT END DEVICE BUSY FOR ANOTHER JOB
DTENF%==15			;NON-EXISTANT FRONT END DEVICE
DTEFE%==16			;FATAL ERROR ON FRONT END DEVICE
DTESE%==17			;ERROR STARTING PRIMARY PROTOCOL
DTENC%==20			;NO FREE CORE FOR FRONT END DEVICE BUFFERS
DTETE%==21			;TIMER EXPIRED FOR KL ERROR DATA CORE
DTECM%==22			;DTE TO-11 QUEUE ROUTINE COULD NOT SEND
				; A MESSAGE FOR FRONT END DEVICE
DTEIU%==23			;TRIED TO SET LINE TO ILLEGAL USER VALUE
DTEWU%==24			;WRONG LINE USER FOR FUNCTION
DTEEV%==25			;NO EVM LEFT TO PERFORM FUNCTION
DTEIP%==26			;ILLEGAL BYTE POINTER
	SUBTTL	COMMAND TABLE BIT DEFINITIONS

;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

NOCORE==:1B18	;NO CORE NEEDED FOR COMMAND
NOJOBN==:1B19	;NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN==:1B20	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT==:1B21	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
NORUN==:1B22	;AN EXPLICIT ^C MUST BE TYPED BY USER BEFORE COMMAND
		; IS EXECUTED IF JOB IS RUNNING
		; JOB MUST BE SWAPPED IN IF IT HAS LOGICAL CORE
INCORE==:1B23	;COMMAND MUST BE DELAYED IF JOB HAS LOGICAL CORE
		; WHICH IS ON DISK OR ON ITS WAY IN OR OUT.
		; JOB WILL BE SWAPPED IN (SEE DLYCOM)
		; AND IS NOT SITTING QUIETLY IN CORE(IE NO SWAPPING TRANSFER)
NXONLY==:1B24	;NOT LEGAL IF EXECUTE ONLY PROGRAM
NBATCH==:1B25	;NOT LEGAL FROM BATCH JOB
CMDERR==:1B26	;ERROR ENCOUNTERED IN COMMAND PARSING (FOR COMCON, NOT TABLES)
NORCMP==:1B27	;ALLOWED LOGGED OUT ON REMOTE TERMINAL DESPITE M.RCMP
		;BIT 28 FREE
CUSTMR==:1B29	;RESERVED TO CUSTOMERS
		;BITS 30 - 31 FREE

;UNIQUENESS BITS IN RH OF SIXBIT NAME
;NOTE:	THESE BITS MUST BE DEFINED AS THE LEAST MOST SIGNIFICANT
;	BITS TO INSURE COMPATIBILITY WITH THE USER DEFINED LOGICAL
;	NAME BITS.

UNIQ.1==:1B32	;UNIQUE TO 1 CHAR.
UNIQ.2==:1B33	;UNIQUE TO 2 CHARS.
UNIQ.3==:1B34	;UNIQUE TO 3 CHARS.
UNIQ.4==:1B35	;UNIQUE TO 4 CHARS.

;FLAG BITS IN LH(M) SET BEFORE DISPATCHING TO COMMAND ROUTINE.
;*** NOTE WELL! ***  FLMCOM *MUST* BE THE SIGN BIT OF M FOR
;CHECKS IN UUOCON AND PREVENTING ECOD FROM CALLING STOTAC.

FLMCOM==:(1B0)	;1=COMMAND, 0=UUO
FLMCLV==:(1B1)	;COMMAND RUNNING AT COMMAND LEVEL

;BITS PLACED IN LH(M) AFTER SETTING UP FOR COMMAND BUT BEFORE THE
;COMMAND-SPECIFIC DISPATCH ROUTINE IS CALLED.
;NOTE:	THESE BITS MUST BE SHIFTED BY 18 BITS WHEN GENERATING
;	TABLES OR VALUES. THEY ARE DEFINED TO BE RIGHT HALF
;	QUANTITIES ONLY TO ALLOW FOR EASIER TESTING.

		;*** BITS 18 AND 19 RESERVED FOR FLMCOM AND FLMCLV ***
NOINCK==:1B20	;NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF==:1B21	;NO PRINTING OF CRLF
NOPER==:1B22	;NO PRINTING OF PERIOD
TTYRNU==:1B23	;SET TTY TO USER MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC==:1B24	;KEEP TTY IN COMMAND MODE AND START JOB
		; WHEN COMMAND RESPONSE STOPS TYPING
TTYRNW==:1B25	;SET TTY TO USER LEVEL AND IO WAIT IF IT WAS IN IOW BEFORE
CMWRQ==:1B26	;REQUEUE JOB AFTER COMMAND WAIT
NOMESS==:1B27	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR OR TYPE WATCH BEGIN.
NOCRLP==:<NOCRLF!NOPER>		;NEEDED FOR INTERNAL
TTYRNM==:<TTYRNW!NOMESS>	;TTY TO USER MODE AND NO MESSAGE
ERRFLG==:1B28	;COMMAND ERROR
SACFLG==:1B29	;COMMAND EXECUTED IN AN ALTERNATE CONTEXT
NOFLM==:1B30	;SUPER-NOCRLF:  CALL PRPER NOT PRDOTC
PSTCST==:1B31	;POST DISPATCH RESERVED FOR CUSTOMER
		;BITS 32 - 35 FREE

;ALTERNATE NAMES FOR LAZY PEOPLE TO AVOID LOTS OF GLOBALS

LHRUNF==:NOPER!TTYRNU!NOCRLF	;HANDY LEFT HALF OF RUNFLG QUANTITY
RUNFLG==:NOCORE!NOACT!NORUN!INCORE!<LHRUNF_^D18>
ECMFLG==:<NOCRLF!NOPER!NOMESS!TTYRNC>_^D18
APPFLG==:SACFLG,,0		;FULLWORD BIT VALUE FOR MONGEN COMMANDS
	SUBTTL	SEARCH LIST PARAMETERS AND LIMITS

;PRIMARY CONSTANTS

XP	.SLMAX,^D36	;MAX.NUM.FS'S SIMULTANEOUSLY MOUNTED
XP	.SLMXJ,^D10;	;MAX.NUM.FS'S IN JOB SL.
XP	.SLMXS,.SLMAX;	;MAX.NUM.FS'S IN SYS.SL.

XP	.FSSIZ,^D9;	;SIZE OF BYTE CONTAINING FSN. & STATUS BITS
XP	.FSFSN,^D6;	;SIZE OF BYTE CONTAINING FSN. ONLY
XP	FS.MSK,777;	;MASK FOR .FSSIZ
XP	FS.NMK,077;	;MASK FOR FSN. ONLY
XP	FS.BMK,700;	;MASK FOR BITS ONLY
XP	FS.WLK,100;	;SOFTWARE WRITELOCK BIT
XP	FS.NCR,200;	;NO-CREATE BIT
;	FS.???,400;	;SPARE BIT


;SECONDARY PARAMETERS AND CONSTANTS

XP	.SLIPW,<^D36/.FSSIZ>;		;ITEMS (FSN'S, MARKERS) PER WORD
XP	.SLWDJ,<<.SLMXJ+2+.SLIPW-1>/.SLIPW>;	;WORDS PER JOB SL. (+2 FOR FNC AND STP)
XP	.SLWDS,<<.SLMXS+2+.SLIPW-1>/.SLIPW>;	;WORDS PER SYS SL.
XP	.SLPSB,<.FSSIZ-1>;		;POSITION OF FIRST BYTE IN A WORD
XP	.SLPSE,<.FSSIZ*.SLIPW-1>;	;POSITION OF LAST BYTE IN A WORD
;XP	SL.PT0,<POINT .FSSIZ,0>;		;POINTER (SANS ADDRESS) WHICH MUST IBP'D TO GET 1ST BYTE
;XP	SL.PTB,<POINT .FSSIZ,.SLPSB>;	;POINTER (SANS ADDRESS) TO 1ST BYTE IN WORD
;XP	SL.PTE,<POINT .FSSIZ,.SLPSE>;	;POINTER (SANS ADDRESS) TO LAST BYTE IN A WORD

;FILE STRUCTURE NUMBERS AND SEARCH LIST MARKERS

			;0 IS NOT USED AS A FSN. SO THERE WILL BE NO
			;  CONFUSION WITH ZEROED DATA BLOCKS
XP	.FSMIN,1	;.FSMIN TO .FSMAX ARE THE LEGAL FSN.S
XP	.FSMAX,<.FSMIN+.SLMAX-1>
XP	.FSFNC,.FSMAX+1	;FENCE MARKER (SEPERATE ACTIVE AND PASIVE LISTS)
XP	.FSEND,.FSFNC+1	;LOGICAL END MARKER
			;  ONLY FNC & FSN'S MUST BE .LT. END SO
			;  CAIL .FSEND CAN BE USED FOR END-TEST
XP	.FSTMP,.FSEND+1	;TEMPORARY SL. MARKER (PREFACED TO SL'S  WHICH
			;  MUST BE RETURNED TO FREE SORAGE)
XP	.FSXX1,.FSTMP+1	;GENERAL PURPOSE MARKER (E.G. FSNINC IN FNDFIL)
XP	.FSSTP,FS.NMK	;PHYSICAL END MARKER

E$$STS:	IFGE .FSXX1-.FSSTP,<PRINTX % S:E$$STS: .FSSIZ TOO SMALL>
;WELL FORMED SEARCH LISTS HAVE ONE OF THE FOLLOWING TWO FORMS:
;
;	(TMP) FNC ( END (?) ) STP		THE EMPTY SEARCH LIST
;	(TMP) (FSN) FNC (FSN) ( END (?) ) STP	NON-EMPTY SEARCH LIST
;
;		(X) MEANS 0 OR MORE OCCURANCES OF X
;		?  MEANS ANYTHING EXCEPT STP
;		FSN MEANS ANY F.S. NUMBER
;
;	0 IS NOT A LEGAL SEARCH LIST -- AND MEANS A SEARCH LIST
;	HAS NOT BEEN CREATED. IT WILL INVOKE DIFFERENT ACTIONS DEPENDING
;	ON CONTEXT (E.G. SUBSTITUTE SYS.SEARCH LIST, CREATE EMPTY
;	SEARCH LIST, ETC.)

;MACROS FOR DEFINING SEARCH LISTS

;AN EMPTY SEARCH LIST
;NUM=	MAX.NUM.FS'S TO ACCOMADATE (MUST BE .GE. 1)
;
DEFINE	SLEMPT (NUM)
	<XLIST
	BEGBYT(.FSSIZ)
	XBYT(.FSFNC)
	XBYT(.FSEND)
	REPEAT NUM-1,<XBYT(0)>
	XBYT(.FSSTP)
	ENDBYT;
	LIST>

;THE ALL: SEARCH LIST
;
DEFINE	SLALL
	<XLIST
	BEGBYT(.FSSIZ)
	$SLALL==.FSMIN
	REPEAT .SLMAX,<
		XBYT($SLALL)
		$SLALL==$SLALL+1
		>
	XBYT(.FSFNC)
	XBYT(.FSSTP)
	ENDBYT;
	LIST>
DEFINE	BEGBYT	(SIZ,POS)
	<XLIST
	IFB  <POS>,<$XBYP==<SIZ>-1>
	IFNB <POS>,<$XBYP==<POS>>
	$XBYS==<SIZ>
	$XBYT==0
	LIST>

DEFINE	XBYT (VAL)
	<XLIST
	$XBYT==$XBYT+<VAL>B<$XBYP>
	$XBYP==$XBYP+$XBYS
	IFG $XBYP-^D35,<
		EXP <$XBYT>
		$XBYP==$XBYS-1
		$XBYT==0
		>
	LIST>

DEFINE	ENDBYT
	<XLIST
	IFN $XBYP-$XBYS+1,<EXP <$XBYT>>
	PURGE $XBYT,$XBYP,$XBYS
	LIST>
	SUBTTL	BITS IN JOB TABLES -- JOB STATUS WORD (JBTSTS)

;JOB STATUS WORD (JBTSTS TABLE), ONE WORD FOR EACH JOB (SOME BITS ALSO
; APPEAR IN HIGH SEG STATUS WORD)


	XP	RUN,400000	;USER WANTS JOB TO RUN (MUST BE SIGN BIT)
	XP	SNA,400000	;HIGH SEG NUMBER ASSIGNED (ANALOGOUS TO JNA EXCEPT
				; MUST BE SIGN BIT)
	XP	CMWB,200000	;JOB TYPED A COMMAND WHICH NEEDS CORE
				; WHICH IS ON DISK.  SET BY COMMAND DECODER
				; CLEARED WHEN JOB IN CORE AGAIN.
	XP	SHRSEG,200000	;HIGH SEG IS SHARABLE (ALTHOUGH NAME MAY BE 0
				; IF IT HAS BEEN SUPERSEDED).  THIS BIT ALSO
				; APPEARS IN SAME PLACE IN LH OF JBTSGN FOR
				; EACH USER TO INDICATE USER IS USING A SHARABLE
				; HIGH SEG (ALSO APPEARS IN LH OF AC J WHEN
				; RH IS SEG NUMBER FOR A PARTICULAR JOB)
	XP	JXPN,100000	; LOW OR HI SEG MUST BE SWAPPED OUT BECAUSE
				; IT IS EXPANDING SIZE
				; OF CORE AND THERE WASN'T ROOM IN CORE
	XP	JNA,40000	;THIS JOB NUMBER IS ASSIGNED (JOB INITIALIZED)
	XP	SS.SYS,40000	;SEGMENT CAME FROM SYS
	XP	JERR,20000	;A MONITOR DETECTED ERROR HAS OCCURRED
				; JOB CAN NOT CONTINUE
	XP	SERR,20000	;A SWAP READ ERROR HAS OCCURRED FOR THIS HIGH SEG
	XP	NSWP,10000	;JOB OR HIGH SEG IS NOT TO BE SWAPPED
				; (REALTIME OR DISPLAY)
				; (CAN BE SHUFFLED OR NOT ACCORDING TO NSHF)
	XP	SHF,4000	;MONITOR IS WAITING FOR DEVICES FOR THIS
				; JOB TO STOP AFTER CURRENT BUFFERFULL
				; SO JOB CAN BE SHUFFLED IN CORE OR SWAPPED OUT
				; IF JOB ONLY HAS LOW SEG
	XP	SWP,2000	;0 IF JOB IN CORE, 1 IF SWAPPED OUT OR ON WAY
				; IN OR OUT.  SAME FOR LOW AND HIGH SEGMENTS
	XP	NSHF,1000	;JOB IS NOT SHUFFLABLE
	XP	CNTRLC,400	;^C WAS TYPED WHILE JOB WAS IN MONITOR MODE
				; AND NOT IN TTY WAIT - DELAY STOPPING JOB
	XP	STOPIO,SWP+CMWB+SHF	;FORCE JOB TO STOP TO EXECUTE
				; SWAP, COMMAND OR SHUFFLE
	;BITS 10-14 USED TO INDICATE JOB IN WAIT FOR A SHARABLE DEVICE
	;0 MEANS JOB NOT WAITING FOR SHARABLE DEVICE

	XP	JWSIZ,5		;SIZE OF WAIT CODE
	XP	JWPOS,^D14	;RIGHT MOST BIT POS. OF WAIT CODE
	XP	WTMASK,370	;MASK FOR CLEARING WAIT CODES

	XP	JLOG,4		;JOB SUCCESSFULLY LOGGED IN
	XP	JRQ,2		;JOB HAS CHANGED STATE AND MUST BE REQUEUED AT CLOCK
				; LEVEL BEFORE RESCHEDULING CAN TAKE PLACE
	XP	JACCT,1		;PRIVILEGED SYSTEM CUSP IS BEING RUN WHICH CANNOT
				; BE STOPPED (E.G., LOGIN
				; OR LOGOUT).  PROTECT IT FROM CURIOUS EYES.
				; DISABLE CONTROL C, MADE IT ACT LIKE ALT-MODE

;BITS IN RIGHT HALF OF JBTSTS
	XP	CLKR,400000	;JOB HAS A CLOCK REQUEST IN.
				; NEEDED SO ONLY ONE REQUEST PER JOB
	XP	LOK,200000	;JOB IS BEING LOCKED IN CORE
	XP	JDC,100000	;JOB HAS TYPED "DCORE"

	XP	UTRP,40000	;TRAP TO USER ON UUO EXIT (REENTER DDT)
				; TRAP ADR. STORED IN JOBFDV BY COMMAND
	XP	JDCON,20000	;JOB IN ^C STATE WAITING FOR DEVICE
				;TO CONTINUE FROM ERROR
	XP	JS.DEP,10000	;DAEMON ERROR PAUSE.  SET WHEN JOB
				; GETS AN ERROR.  JOB PAUSES UNTIL
				; DAEMON CAN ENTER ERROR INFO INTO LOG FILE
				; DAEMON CLEARS BIT
	XP	JS.XXX,4000	;***AVAILABLE
	XP	JS.XO,2000	;EXECUTE ONLY CORE IMAGE
	XP	JS.SFE,400000	;ON IF HIGH SEGMENT CAME FROM AN EXE FILE
	XP	JS.RUU,1000	;RUN UUO OR COMMAND IN PROGRESS
	XP	JS.MPE,400	;MEM PAR ERROR FOR JOB (LOW OR HIGH SEG)
				; BEHAVES LIKE CNTRLC. JOB RUNS TO UUO EXIT
				; IF PARITY IN UUO LEVEL CODE IN USER AREA
				; DOES NOT STOP A JOB FROM BEING RUN

	XP	JS.BPT,200	;SET DDT BREAKPOINT BIT
	XP	JS.DPM,100	;DAEMON PROBLEM MESSAGE NEEDED FOR JOB
				; PRINT ONCE A MINUTE PRINT %PROBLEM WITH DAEMON ON JOB
				; THEN SET EVERY MIN JOB IS WAITING FOR DAEMON
	  XP	JS.DEM,JDC!JS.DEP	;JOB BITS TO CHECK FOR EVERY MINUTE.
				; SET JS.DPM IF ON
	XP	JS.ASA,40	;FETCH AND STORE UUO ARGUMENTS INTO/FROM USER ADDRESSES
				; WHICH ARE LESS THAN 20 IN SHADOW AC AREA RATHER
				; THAN USERS ACS. CSET ON SAVE, GET, RUN, AND GETSEG
	XP	JS.XOR,20	; LIT IF RUN UUO OR COMMANDS IN PROGRESS A FILE IS XO.

	XP	JS.RQR,10	; RESET QUANTUM RUN-TIME. THIS BIT IS SET
				;  IF WE WANT TO ALTER QUANTUM RUNTIME.
				;  WHILE THE PDB IS ON THE DISK.

	XP	JS.SFL,4	;STOP JOB IF DISK FULL. SET (CLEARED)
				; BY SET FULL STOP (NOSTOP) COMMAND, UUO. IF OFF
				; AN ERROR BIT IS SET ON DISK FULL OR QUOTA
				; EXCEEDED.  IF ON JOB IS STOPPED, ".CONT" RETRIES
	XP	JS.NXM,2	;SOME PAGE IN THIS JOB'S ADDRESS SPACE
				; IS CONTAINED IN NON-EXISTENT MEMORY

	XP	JS.NTO,1	;THIS JOB HAS DONE SOME NON-BLOCKING
				; TTY OUTPUT.

;***********************************************************************
;ADD NEW BITS IN JOB STATUS WORD ABOVE HERE
;***********************************************************************
;BITS 9-17 ARE USED FOR ACCESS PRIVILEGE BITS FOR SHARABLE HIGH SEGMENTS
; SAME FORMAT AS ACCESS BITS FOR DISK

	XP	HSASIZ,^D9	;SIZE OF HIGH SEG ACCESS BITS
	XP	HSAPOS,^D17	;RIGHT MOST POSITION OF HIGH SEG ACCESS BITS
	XP	HSAMSK,777	;MASK TO CLEAR ACCESS PRIVILEGES
	XP	ICCSIZ,^D12	;SIZE OF HIGH SEG IN CORE COUNT FIELD
	XP	ICCPOS,^D35	;RIGHT MOST POSITION OF HIGH SEG IN
				; CORE COUNT FIELD MUST BE RIGHT MOST
				; BITS OF WORD SINCE COUNT IS AOSED
				; AND SOSED
	XP	ICCMSK,7777	;MASK FOR TESTING IN CORE COUNT


;MASKS USED TO TEST STATUS CONDITIONS:

	XP	RUNABLE,RUN+JNA	;STATUS BIT PATTERN FOR JOB TO BE RUNABLE
	XP	RUNMSK,JLOG+NSHF+JACCT+NSWP+CNTRLC
				; BITS WHICH DO NOT MATTER FOR RUNABILITY
	SUBTTL	BITS IN JOB TABLES -- JBTSCD

;BITS IN RIGHT HALF OF JBTSCD

	XP JS.TYP,777B35	;JOB'S SCHEDULER TYPE

;BITS IN LEFT HALF OF JBTSCD

	XP JS.PQ2,1B0		;JOB IS IN PQ2, THEREFORE SUBCLASS
				; (MUST BE SIGN BIT)
	XP JS.CLS,37B17		;JOB'S SCHEDULER CLASS
	SUBTTL	BITS IN JOB TABLES -- JBTST2


;;!=========================================================================!
;;!IP! ! ! ! ! !X!NN!BB!C!H!BP!FX!CF!SL!N!EX!M!A!EW.CODE!W!R!QUEUE #!O!Q!S!
;;!=========================================================================!

;BITS IN RH OF JBTST2

	XP	JS.MIG,1B18	;JOB HAS MIGRATED TO ANOTHER SWAPPING U NIT
				; WHEN A DISK CONTROLLER IS BEING TAKEN
				; OFF-LINE (FTDHIA)
	XP	JS.ABP,1B19	;AN ADDRESS BREAK PAGE FAULT OCCURRED
				; BECAUSE OF A REFERENCE TO THIS USER'S
				; VIRTUAL ADDRESS SPACE DURING UUO
				; PROCESSING
	XP	ESLPSZ,5	;ESLEEP REASON BYTE SIZE
	XP	ESLPBP,^D24	;ESLEEP REASON BYTE POSITION
	XP	EWAKEB,1B25	;EWAKE CALLED (WAKEUP WAITING)
	XP	JS.RPC,1B26	;IF=1 RUN PROGRAM IN .PDPGM ON CONTROL-C
	XP	JS.SIZ,6	;NUMBER OF BITS FOR QUEUE NUMBER
	XP	JS.POS,^D32	; RIGHTMOST BIT IN QUEUE NUMBER
	XP	JS.MSK,770	;MASK FOR STATE CODE. USED AT CLRJBT
	XP	JS.OOO,4	;USER RAN OUT OF ORDER. STOP WHEN GIVES UP
				; LAST RESOURCE.
	XP	JS.TFO,2	;JOB FORCED OUT BY TIMER
	XP	JS.SCN,1	;JOB WAS SCANNED TO RUN BY AT LEAST ONE
				; CPU DURING LAST TICK

;BITS IN THE LEFT HALF OF JBTST2

	XP	JS.EXE,1B17	;A NEW SAVE (EXE FILE) IS UNDERWAY
				; OR, ON A "GET", THIS BIT MEANS THAT A LOOKUP
				; ON THE EXE FILE FAILED. IF SO, THE
				; EXE FILE WILL NOT BE LOOKUP'ED AGAIN
				; FOR THE LOW SEGMENT
	XP	JS.NCS,1B16	;ON IF CACHE BITS ARE NOT TO BE TURNED
				; ON IN THIS JOBS MAP
	XP	JS.HIB,1B15	;THIS JOB IS HIBERNATING
	XP	JS.CFX,1B14	;CALL FILE DAEMON ON "PROGRAM EXIT"
	XP	JS.FXO,1B13	;FILE DAEMON MADE THIS CORE IMAGE EXECUTE ONLY
	XP	JS.BPR,1B12	;BYPASS PROGRAM TO RUN CHECKING IF THIS
				; FLAG IS SET THE CURRENT RUN COMMAND IS
				; ALLOWED DESPITE .PDPGM (USED FOR KJOB)
	XP	JS.HNG,1B11	;JOB STAYED IN FORCE TOO LONG, CAUSING TEMPORARY
				; OR PERMANENT SYSTEM HANG,  CLEARED WHEN SWAPPED IN
	XP	JS.IGS,1B10	;IN GETSEG (DOING A GETSEG UUO)
	XP	JS.CSQ,1B9	;IF JOB CHANGING SUBQUEUE DO TO SCHED UUO
	XP	JS.BBJ,1B8	;IF JOB IS BACKGROUND BATCH
	XP	JS.NNQ,1B7	;IF NOT TO ASSIGN NEW QUANTA ON SWAP IN.
				; SET WHEN DOING A GETSEG TO A SWAPPED HIGH SEGMENT
	XP	JS.FPS,1B6	;ON IF LONG KA10 FLOATING POINT INSTRUCTIONS SHOULD BE
				; SIMULATED
	XP	JS.SIP,1B5	;ON IF SWAPPING I/O IS IN PROGRESS FOR THIS JOB
	XP	JS.OLS,1B4	;JOB OWNS LOCKED STRUCTURE(S)
	XP	JS.SAC,1B3	;THE JOB'S CURRENT CORE IMAGE IS AN ALTERNATE
				; CONTEXT. RESTORE PREVIOUS CONTEXT WHEN THE
				; TERMINAL IS RETURNED TO MONITOR LEVEL
	XP	JS.DEB,3B2	;DEFERRED ECHO BITS
	XP	JS.IPQ,1B0	;ON IF JOB IS IN A PROCESSOR QUEUE (MUST BE SIGN BIT)
	SUBTTL	BITS IN JOB TABLES -- JBTSWP, JBTPPB AND PAGTAB

;BITS IN JBTSWP TABLE

	XP	FRGSEG,400000	;LH - 1 IF LOW OR HIGH SEG IS FRAGMENTED ON SWP


;BITS IN LH JBTPPN TABLE

	XP	JBPWLK,400000	;LEFTMOST BIT OF WRITELOCK FIELD (STR # 0)
	XP	JBPNCR,400	;LEFTMOST BIT OF NO-CREATE FIELD (STR # 0)
	XP	JBLWLK,1000	;RIGHTMOST BIT OF WRITELOCK FIELD (STR # 8)
	XP	JBLNCR,1	;RIGHTMOST BIT OF NO-CREATE FILED (STR # 8)
	XP	NCRMSK,777	;ALL NO-CREATE BITS

;BITS IN LEFT HALF OF JBTPDB
	XP	MCPSIZ,6	;SIZE OF BYTE POINTER FIELD FOR THE NUMBER
				; OF PAGES OF MONITOR FREE CORE ALLOCATED
				; TO THIS USER
	XP	MCPBPP,^D17	;POSITION
	XP	IMCPBP,^D11	;POSITION FOR NUMBER OF PAGES TO SWAP IN
	XP	MCPCNT,1B17	; FOR INCREMENTING/DECREMENTING COUNT

;BITS IN PAGTAB
	XP	FREPAG,400000	;ON IF PAGE IS NOT IN SOME JOBS ADDRESSING SPACE
	XP	LOKPHB,200000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT
				; WHICH IS LOCKED IN PHYSICALLY CONTIGUOUS MEMORY
	XP	LOKEVB,100000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT WHICH
				; IS LOCKED VIRTUALLY CONTIGUOUS IN THE
				; EXEC ADDRESSING SPACE
	XP	LOKIPB,40000	;ON IF THIS PAGE IS CONTAINED IN A SEGMENT
				; WHICH IS LOCKED IN PLACE
	XP	NXMBIT,20000	;ON IF THIS PAGE IS BELOW MEMSIZ BUT IS
				; NON-EXISTANT
	XP	MONTRB,10000	;ON IF THIS PAGE IS CONTAINED IN THE MONITOR
	XP	IPCBIT,4000	;ON IF THIS PAGE IS OWNED BY IPCF
	XP	TNCSHB,2000	;ON IF THIS PAGE IS TEMPORARILY UNCACHED
				; (MONITOR LOW PAGES ONLY ON 1099)
	XP	CONTGB,1000	;ON IF THIS RANGE OF PAGES MUST BE KEPT PHYSICALLY
				; CONTIGUOUS (DX20 MICROCODE, CI20 BSDS, ETC.)
	XP	LKBITS,LOKPHB!LOKEVB!LOKIPB!NXMBIT!MONTRB
	XP	PT.JOB,777B17	;JOB # OF PIOW JOB
	XP	PT.SJB,^D9	;SIZE OF PIOW JOB FIELD

;BITS IN PT2TAB

	XP	P2.LIP,1B1	;LOCK IN PROGRESS (PAGE TO BE RETURNED
				;TO/IS IN LOKPTR, NOT FREPTR)
	XP	P2.TRN,1B2	;PAGE IN TRANSIT (JOB IN MT.JOB)
	XP	P2.BLK,777777	;BACKWARD LINK (18 BITS FOR CONVENIENCE)
;IN SWAP REQUEST, THE BELOW ARE USED FOR THE NEXT VIRTUAL PAGE #.
;IN A PAGING QUEUE REQUEST, THE BELOW ARE USED TO REMEMBER THE VIRTUAL
;PAGE NUMBER THIS PAGE IS FOR (IN CONJUNCTION WITH MT.JOB) FOR JOB PAGES.
;FOR IPCF PAGES, THIS FIELD PROVIDES THE LOW ORDER 15 BITS OF THE ADDRESS
;OF THE IPCF QUEUE HEADER USED
;NOTE THAT FOR THE PAGING QUEUES (JOB ENTRIES), THE HIGH ORDER BIT IS
;NOT USED IN THIS FIELD AND ***MUST BE ZERO***

	XP	P2.VPN,77777B17	;NEXT VIRTUAL PAGE NUMBER
	XP	P2.SPN,^D15	;SIZE OF NEXT PAGE NUMBER FIELD
	XP	P2.RPN,777B17	;SECTION RELATIVE PAGE #
	XP	P2.SRN,^D9	;SIZE OF ABOVE
	XP	P2.VSN,37B8	;SECTION FIELD
	XP	P2.SSN,5
	XP	P2.MBZ,1B3	;MUST BE ZERO (FOR JOB ENTRIES ONLY)
	XP	P2.SBZ,1	;SIZE OF FIELD

;THE FOLLOWING ARE USED WHEN A PAGE IS ON THE IP QUEUE
	SUBTTL	BITS IN JOB TABLES --  MEMTAB AND SWPLST

;BITS IN MEMTAB
MT.LEF==1B0		;LAST ENTRY IN FRAGMENT-CHAIN
MT.GPB==1B1		;RETURN SWAPPING SPACE WHEN I/O COMPLETES ON "IP" QUEUE
MT.IPC==1B2		;IPCF PAGE, ADDRESS OF PACKET+.ICPFI IN MEMTAB
MT.JOB==777B14		;JOB # IF PAGE IN PAGING QUEUE
			;HIGH ORDER 9 (REALLY 3) BITS OF IPCF HEADER ADDRESS FOR
			;IPCF PAGE WHEN PAGES GOES TO THE "IP" QUEUE
MT.SJB==^D9		;SIZE OF JOB FIELD

;THE FOLLOWING ARE USED WHEN THE PAGE IS IN TRANSIT TO/FROM THE DISK
MT.DAD==7,,777777	;DISK ADDRESS FIELD IN MEMTAB
MT.SAD==^D21		;SIZE
MT.UNT==7,,0		;UNIT SUBFIELD OF DISK ADDRESS
MT.SUN==^D3

;THE FOLLOWING USED FOR PAGES LOCKED IN CORE (SPECIFIC PAGES)

MT.EVM==7,,777777	;PAGE NUMBER OF EVM THIS PHYSICAL PAGE IS IN

;THE FOLLOWING ARE USED WHEN THE PAGE IS ON ONE OF THE "IN" QUEUES


HLGPNO==777
HLGSNO==37
HLGPGS==<<HLGSNO+1>*<HLGPNO+1>>-1
IFE FTXMON,<
HLGPGS==HLGPNO		;NO EXTENDED ADDRESSING
>

PA.PME==1B35
PA.PMI==1B34
PA.PCE==1B33
PA.PCI==1B32
PA.IHB==1B31
PA.PWE==1B30		;MUST BE WRITE ENABLE FOR SIGN BIT OFF
PA.PWL==1B29		;MUST BE WRITE-LOCKED FOR SIGN BIT ON


;BITS IN SWPLST
SL.FRG==1B0		;FRAGMENTED ENTRY
SL.DIO==1B1		;DIRECTION OF IO (1=OUT)
SL.SIO==1B2		;SWAPPING/PAGING (1=SWAPPING)
SL.IOP==1B3		;IO IN PROGRESS
SL.IOD==1B4		;IO DONE (THIS SWPLST ENTRY IS DONE)
SL.IPC==1B5		;ON IF AN IPCF PAGE
SL.DFM==1B6		;KEEPS FNDSLE FROM FINDING THE SWPLST ENTRY.
SL.CHK==1B7		;SWAPPING CHECKSUM ERROR
SL.ERR==1B8		;IO ERROR (IODTER,IODERR, OR IOIMPM)
SL.CHN==1B9		;CHANNEL ERROR (IOCHMP OR IOCHNX)
SL.MAP==1B10		;MAP INFO THIS ENTRY (FRAGMENT)
SL.PIW==1B11		;JOB WAITING FOR PAGING QUEUE
SL.FRE==3B12		;**FREE**
SL.PPN==17777B26	;PHYSICAL PAGE #
SL.SPN==^D13		;SIZE OF PHYS PAGE # FIELD
SL.CNT=777B35		;PAGE COUNT
SL.SCT==^D9		;SIZE OF COUNT FIELD

;BITS IN THE PDB
PD.IPV==1B1		;JOB IS IN PQV
PD.PLS==1B18		;JOB HAS A PHYSICAL LIMIT (AS OPPOSED TO GUIDELINE) SET
PD.DPS==1B9		;JOB HAS A DEFAULT PROTECTION SET
PD.FSP==1B10		;FILE DAEMON SPECIFIED THE PROTECTION FOR THIS CREATE
PD.UDS==1B11		;USE DEFAULT FILE SPEC ON RUN, GET
PD.DAD==1B12		;DON'T ASK ABOUT DETACHED JOBS AT LOGIN TIME
PD.LGN==1B13		;LOGIN BIT, IF SET DO INCR AND CLEAR,
			;IF CLEAR DO DECR AND SET, THIS IS FOR ACCLG. UUO
PD.PGR==1B14		;.STPGM RUN IN PROGRESS. IF RUN FAILS, RUN LOGOUT
PD.LGO==1B15		;A LOGOUT UUO IS IN PROGRESS
	SUBTTL	BITS IN JOB TABLES -- JBTSGN

;VIRTUAL ADDRESSING SPACE DESCRIPTOR WORD (JBTSGN) ONE WORD FOR EACH JOB
;THIS WORD APPEARS IN AC J
;LH BITS
;BITS 13-17=0 SO CAN DO CAI @JBTSGN TO COMPARE RH.
;RH IS HIGH SEG NUMBER (NUMBER GREATER THAN JOB MAX AND LESS THAN OR EQUAL TO JBTMAX)
; OR IF SPYSEG IS SET, RH IS HIGHEST PHYSICAL ADR USER MAY SPY INTO
; BITS 26-35 ALWAYS=1777 SO CANNOT WORK LIKE A SEGMENT NUMBER

;THESE BITS ALSO APPEAR IN THE HIGH SEG DATA BLOCK FOR A JOB/SEGMENT PAIR
;(SEE .HBSGN)
;THE BITS WHICH ALSO APPEAR ARE THE IOR ACROSS ALL OF THE JOB'S HIGH SEGMENTS

;	XP	REDOMP,100000	;ON IF THE HIGH SEGMENT PART OF THIS
				; JOB'S MAP MUST BE REDONE
;	XP	LOKSEG,10000	;SOME HIGH SEGMENT THIS JOB IS SHARING IS LOCKED
				; IN CORE.

;THESE BITS DO NOT APPEAR IN THE HIGH SEG DATA BLOCK:

	XP	CONSEG,200000	;THIS JOB HAS A CONCEALED HIGH SEGMENT
	XP	SCHKM,1777	;COUNT OF HIGH SEGS IN TRANSITION WHICH
				;THIS JOB OWNS.  SCHEDULAR WON'T RUN
				;JOB WHEN THIS FIELD IS NON-ZERO
	SUBTTL	BITS IN JOB TABLES -- JBTPRV

;JOB PRIVILEGE BITS - JBTPRV TABLE
;SET BY LOGIN FROM ACCT.SYS FILE AS MODIFIED BY CUSTOMER FOR
; HIS PARTICULAR INSTALLATION
;RH RESERVED FOR SPECIAL CUSTOMER DEFINED PRIVILEGES (PLEASE START
; AT BIT 35 AND WORK TO THE LEFT)
;LH RESERVED FOR DIGITAL STANDARD PRIVILEGES

;BITS IN LEFT HALF
	XP	PVSPYM,1	;JOB ALLOWED TO SPY AT MONITOR USING PEEK/SPY UUOS
	XP	PVSPYA,2	;JOB ALLOWED TO SPY AT ALL OF CORE USING PEEK/SPY UUOS
	XP	PVTRPS,4	;JOB ALLOWED TO USE TRPSET UUO
	XP	PVLOCK,10	;JOB ALLOWED TO USE LOCK UUO
	XP	PVRTT,20	;JOB IS ALLOWED TO USE RTTRP (REAL-TIME TRAPPING) UUO
	XP	JP.ADM,40	;JOB HAS SYSTEM ADMINISTRATOR PRIVILEGES
	XP	JP.ENQ,100	;JOB HAS ENQ PRIVILEGES
	XP	PVNSPL,200	;JOB IS ALLOWED TO UNSPOOL DEVICES
	XP	PVHPQ,7400	;LARGEST HPQ RUN QUEUE
	XP	JP.CCC,10000	;JOB IS ALLOWED TO CHANGE CPU SPECIFICATION
				; VIA COMMAND AND UUO
	XP	JP.POK,20000	;POKE AT MONITOR
	XP	JP.MET,40000	;JOB IS ALLOWED TO USE METER. UUO
	XP	JP.DPR,300000	;LARGEST DISK PRIORITY ALLOWED
	XP	JP.IPC,400000	;IPCF PRIV. FUNCTIONS


	SUBTTL	BITS IN JOB TABLES -- WORDS OF PROCESS DATA BLOCKS


	XP	PDMQNT,7777	;MASK FOR QUANTUM RUN TIME
				;MUST BE LOW ORDER BITS FOR SOS

	XP	PDSQNT,^D12	;SIZE OF QNT BYTE
	XP	PDNQNT,^D35	;BYTE PTR POSITION

	XP	PDSIPT,^D17	;BYTE SIZE OF INCORE PROTECT TIME
	XP	PDNIPT,^D17	;BYTE POSITION.
	XP	PDMSWP,400000	;BIT ZERO FOR SKIPS ON .PDIPT
				;IF ON, INCORE-PROTECT TIME HAS EXPIRED
	XP	NWSCTX,^D24	;NUMBER OF WORDS OF MONITOR FREE CORE
				; REQUIRED TO SAVE A JOBS CONTEXT
;LAYOUT OF SAVED CONTEXT BLOCK
	XP	.SCCIT,0	;ITEM TO BE RETURNED TO THE CALLER
	XP	.SCCPC,1	;PC OF CALLER TO SAVCTX
	XP	.SCJST,2	;JBTSTS OF PREVIOUS CONTEXT
	XP	.SCPPC,3	;DOUBLE WORD PC OF PREVIOUS CONTEXT
	XP	.SCDAC,5	;DUMP ACS OF PREVIOUS CONTEXT
	XP	.SCCCF,25	;FLAGS IN M AT CALL TO SAVCTX
	SUBTTL	BITS IN JOB TABLES -- JBTWCH AND JBTRSP

;BITS IN JBTWCH    -	WATCH SYSTEM RESPONSE COMMAND
;LH BITS:	(BITS 13-35 = TIME OF DAY IN JIFFIES USER STARTS TO WAIT)
;MUST BE IN FOLLOWING ORDER WITH JW.WDJ AS LEFT MOST BIT OF ALL OF THEM
	XP	JW.WCX,400000	;WATCH CONTEXT CHANGES
	XP	JW.WDY,200000	;WATCH TIME OF DAY STARTED TO WAIT
	XP	JW.WRN,100000	;WATCH RUN TIME WHEN RETURN TO COMMAND LEVEL
	XP	JW.WWT,40000	;WATCH WAITING TIME RETURN TO COMMAND LEVEL
	XP	JW.WDR,20000	;WATCH NO. 128 WORD DISK BLOCKS READ
	XP	JW.WDW,10000	;WATCH NO. 128 WORD DISK BLOCKS WRITTEN
	XP	JW.WVR,4000	;WATCH VERSIONS
	XP	JW.WMT,2000	;WATCH MTA PERFORMANCE STATISTICS
	XP	JW.WFL,1000	;WATCH FILE ACTIVITY
	XP	JW.WLM,400	;LONG ERROR MESSAGES
	XP	JW.WNM,200	;NORMAL ERROR MESSAGES
	XP	JW.WPM,100	;PREFIX ERROR MESSAGES
				; IF ABOVE 3-BITS=0, ASSUME =3.
		;ADD NEW DATA HERE (ALSO INCLUDE IN WCHALL)
	XP	WCHALL,JW.WCX!JW.WDY!JW.WRN!JW.WWT!JW.WDR!JW.WDW!JW.WVR!JW.WMT!JW.WFL	


;BITS IN JBTRSP - RESPONSE TIME MEASURE
;LH BITS - REST OF WORD IS UPTIME IN JIFFIES WHEN USER
; TYPED IN COMMAND WHICH STARTED JOB OR BREAK CHAR
; WHICH TOOK JOB OUT OF IO WAIT

;BITS SET TO 1 WHEN TYPE OF RESPONSE IS RECORDED. SET TO 0 WHEN USER TYPES IN
	XP	JR.RCR,1B0	;RECORDED FIRST CPU USE
	XP	JR.ROR,1B1	;RECORDED TTY OUTPUT UUO
	XP	JR.RIR,1B2	;RECORDED TTY INPUT UUO
	XP	JR.RRR,1B3	;RECORDED CPU QUANTUM EXCEEDED REQUEUE
	XP	JR.RXR,1B4	;RECORDED FIRST OF ABOVE THREE RESPONSES
				; (NOT JR.RCR)
	XP	JR.RXX,JR.RCR!JR.ROR!JR.RIR!JR.RRR!JR.RXR

;BITS IN C(JOBERR+2) (ERROR INTERCEPTING)
;LEFT HAND BITS:
	XP	.ERMSG,400000	;DONT TYPE ERROR MESSAGE IF BIT=1

;RIGHT HAND BITS:
	XP	.ERIDV,1	;INTERCEPT "DEV OK?" ERRORS (HNGSTP)
	XP	.ERICC,2	;CONTROL-C INTERCEPT
	XP	.EROFL,4	;UNIT DROPPED OFF-LINE
	XP	.ERFUL,10	;FILE STRUCTURE IS FULL
	XP	.ERQEX,20	;QUOTA EXHAUSTED
	XP	.ERTLX,40	;TIME LIMIT EXCEEDED
	XP	.EREIJ,100	;ERROR IN JOB
	SUBTTL	BITS IN JOB TABLES -- JBTLIM, JBTSPL, .PDOBI

;BITS, FIELDS IN JBTLIM
	XP	JB.LTL,1B0	;0--TIME LIMIT SET FROM FORCED DETACH
	XP	JB.LCR,777B9	;1-9--CORE LIMIT
	XP	JB.LBT,1B10	;10-BATCH JOB
	XP	JB.LSY,1B11	;11--GOTTEN FROM SYS:
	XP	JB.LTM,77777777	;12-35--TIME LIM TO GO IN JIF. (0=INF.)

;BITS, FIELDS IN JBTSPL
	XP	JB.SIN,777777B17  ;0-17 SPOOLED INPUT NAME
	XP	JB.DPR,7B26	;24-26 DISK PRIORITY
				; DEFINED IN COMMOD,JBXPRI
	XP	JB.SPL,777	;SPOOLING BITS
	XP	JBSSIZ,^D9	;SIZE OF BYTE
	XP	JB.DFR,1B27	;27 DEFFERRED SPOOLING
				;28-30 RESERVED FOR MORE SPOOLING DEVICES
	XP	JB.CDR,.SPCDR	;31 SPOOLED CDR
	XP	JB.CDP,.SPCDP	;32 SPOOLED CDP
	XP	JB.PTP,.SPPTP	;33 SPOOLED PTP
	XP	JB.PLT,.SPPLT	;34 SPOOLED PLT
	XP	JB.LPT,.SPLPT	;35 SPOOLED LPT

;BITS, FIELDS IN .PDOBI
	XP	JB.WTO,3B1	;WRITE TO OPERATOR VALUES
		XP	JB.WRA,0 ;WTO/WTOR ALLOWED
		XP	JB.WRO,1 ;WTO ALLOWED
		XP	JB.WNA,2 ;NEITHER WTO OR WTOR ALLOWED
	XP	JBPWTO,<<POINT 2,0,1>>
	SUBTTL	QUEUE. UUO

;DEFINITIONS FOR QUEUE. UUO
	XP	QU.FLG,7777B11	;QUEUE UUO FLAGS
	XP	QU.RSR,1B0	;USER IS REQUESTING A RESPONSE
	XP	QU.PRP,1B1	;USER IS PRIVILIGED AND IS REQUESTING PRIVS
	XP	QU.NBR,1B2	;USER IS REQUESTING NON-BLOCKING
;ADD NEW LEGAL QUEUE UUO FLAG BITS TO THE DEFINITION BELOW (QU.LFB)
	XP	QU.LFB,QU.RSR+QU.PRP+QU.NBR
;HEADER BLOCK LENGTH
	XP	QU.HLN,77B17	;TOTAL LENGTH OF HEADER (BEFORE ARGS)
;FIELD IN .QUTIM (4):
	QU.TIM==7777B35		;FIELD FOR TIMEOUT REQUEST
;DEFINITIONS FOR WTO/WTOR UUO
	XP	.WTORR,200012	;WTOR RESPONSE
	XP	.OMACK,700000	;OPERATOR MESSAGE ACK
	XP	WT.WTR,1B0	;WTOR AS OPPOSED TO WTO
	XP	WT.SND,1B10	;WTO AS A RESULT OF A SEND COMMAND
	XP	WT.RWT,1B18	;WTOR TEXT WAS TRUNCATED
	XP	WT.RBR,1B19	;RESPONSE BLOCK RETURNED
	XP	WT.NRW,777B35	;LENGTH OF WTOR RESPONSE MESSAGE
	XP	.WTTXT,40	;WTO TEXT
	XP	.WTDES,25	;NODE NAME OF WTO OPERATOR
	XP	.WTACT,23	;ACCOUNT STRING
	XP	.WTUFC,24	;QUEUE UUO FUNCTION
	XP	.WTNAM,26	;USER'S NAME
	XP	.WTTTY,53	;USER'S TTY (FOR 'SEND OPR')
	XP	.CMTXT,17	;OPERATOR RESPONSE TO WTOR
	XP	WT.NOR,1B2	;NORMAL RESPONSE FROM ORION
	XP	JP.OPP,7B4	;OPER PRIVS
	XP	JBPOPP,<<POINT 3,0,4>>
	XP	JB.BSS,1B10	;BATCH STREAM NUMBER SET
	XP	JB.BSN,177B17	;BATCH STREAM NUMBER
	XP	JBPBSN,<<POINT 7,0,17>> ;POINTER TO BSN
;QUEUE. UUO OFFSETS (FIXED)
;GALAXY HEADER

QUELNH==0		;LENGTH,,FUNCTION
QUEFLG==1		;FLAGS
QUEJOB==2		;ACK CODE,,JOB NUMBER
QUEMBZ==3		;0
QUEARC==4		;ARGUMENT COUNT

;QUEUE. UUO OFFSETS (MAY CHANGE)
;MONITOR SUPPLIED DATA

QUEONH==5		;OPR NODE NAME HEADER
QUEONN==QUEONH+1	;OPR NODE NAME
  QUEONL==2		;LENGTH OF OPR NODE NAME
QUEUNH==QUEONH+QUEONL	;USER NAME HEADER
QUEUSN==QUEUNH+1	;USERS NAME
  QUEUNL==3		;LENGTH OF USERS NAME
QUEACH==QUEUNH+QUEUNL	;ACCOUNT STRING HEADER
QUEACS==QUEACH+1	;ACCOUNT STRING
IFNDEF ACTSTL,<EXTERN ACTSTL>
  QUEACL==ACTSTL+1	;LENGTH OF ACCOUNT STRING


;***QUEFCH MUST BE LAST, ADD MONITOR GENERATED ARGUMENTS ABOVE HERE
QUEFCH==QUEACH+QUEACL	;FUNCTION BLOCK HEADER
QUEFCN==QUEFCH+1	;FUNCTION
  QUEFCL==2		;LENGTH OF FUNCTION BLOCK

;***NUMBER OF MONITOR GENERATED ARGUMENTS, MUST BE UPDATED IF ANOTHER
; BLOCK IS ADDED TO THE OUTPUT OF THE QUEUE. UUO
QUEIGL==4

;LENGTH OF STATIC DATA
QUESDL==5+QUEONL+QUEUNL+QUEACL+QUEFCL
	SUBTTL	BITS IN JOB TABLES -- JBTSPS

;BITS IN JBTSPS - SECOND PROCESSOR STATUS TABLE.  INDEXED BY JOB NO.
;BITS DEFINED AS 36 BIT MASKS USING NEW SP.XXX CONVENTION
;NOT DEFINED FOR USERS (YET):
	XP	SP.NR0,1B5	;NOT RUNABLE ON CPU0
	XP	SP.NR1,1B4	;NOT RUNABLE ON CPU1
	XP	SP.NRA,77B5	;NOT RUNABLE ANYWHERE
;BITS 3-0 RESERVED FOR FUTURE CPUS
	XP	SP.CJ0,1B11	;CURRENT JOB ON CPU 0
	XP	SP.CJ1,1B10	;CURRENT JOB ON CPU 1
	XP	SP.CJA,77B11	;CURRENT JOB SOMEWHERE
;BITS 6-9 RESERVED FOR FUTURE CPUS
	XP	SP.ROP,1B12	;JOB FORCED TO POLICY CPU
				; FIX SP.NR? BITS WHEN POLICY CPU DIES
	XP	SP.CC1,1B14	;CONTROL C ON CPU 1, STOP RUNNING JOB
				;ON SLAVE

;DEFINED FOR USERS:
	XP	SP.CR0,1B35	;CAN RUN ON CPU 0.  SET BY SETUUO, RESET, EXIT
				; IE CURRENT JOB CPU SPECIFICATION BIT.
	XP	SP.CR1,1B34	;CAN RUN ON CPU 1. SET BY SETUUO, RESET, EXIT
				; IE CURRENT JOB CPU SPECIFICATION BIT.
	XP	SP.CRA,77B35	;CAN RUN ANYWHERE
;BITS 33-30 RESERVED FOR FUTURE CPUS
	XP	SP.SC0,1B29	;"SET CPU COMMAND" BIT FOR CPU 0
				; 1 MEANS OK AS FAR AS USER IS CONCERNED
				; TO RUN JOB ON THIS CPU (EVEN IF CPU HAS
				; BEEN STOPPED OR IS NOT SCHEDULING).
	XP	SP.SC1,1B28	;"SET CPU COMMAND" BIT FOR CPU 1
				; 1 MEANS OK AS FAR AS USER IS CONCERNED
				; TO RUN JOB ON THIS CPU (EVEN IF CPU HAS
				; BEEN STOPPED OR IS NOT SCHEDULING).
	XP	SP.SCA,77B29	;"SET CPU ALL"
;BITS 27-24 RESERVED FOR FUTURE CPUS
SP.CP0==1B35			;CPU0'S BIT IS RIGHTMOST IN ALL FIELDS
SP.CPA==77B35			;BITS FOR ALL CPUS
	SUBTTL	BITS IN JOB TABLES --  JBTPIA AND PSISER DEFINITIONS

;BITS IN JBTPIA -- PROGRAMMED SOFTWARE INTERRUPT POINTER TABLE
	XP	SI.ON,1B0	;PI SYSTEM IS TURNED ON
	XP	SI.DBK,1B1	;PI SYSTEM IS OFF UNTIL DEBRK OF CURRENT
	XP	SI.UEA,1B2	;PI SYSTEM WILL USE EXTENDED ADDRESSING

;BITS IN LH OF PIINI. UUO
	XP	PS.IEA,1B1	;USER WANTS PI SYSTEM TO USE EXTENDED ADDRESSING

;BITS IN AC OF PISYS. UUO
	XP	PS.OFF,1B1	;TURN SYSTEM OFF
	XP	PS.ON,1B2	;TURN SYSTEM ON
	XP	PS.CPI,1B3	;CLEAR ALL PENDING INTERRUPTS
	XP	PS.CSI,1B4	;CLEAR SELECTED INTERRUPT
	XP	PS.RDV,1B5	;REMOVE DEVICE OR CONDITION
	XP	PS.ADV,1B6	;ADD DEVICE OR CONDITION
	XP	PS.ALL,77B6	;ALL VALID BITS

;BITS IN THE INTERRUPT REASON WORD
;*** 1B18 IS RESERVED TO PSISER AND NOT AVAILABLE ***
	XP	IR.IND,1B19	;INPUT DONE
	XP	IR.OUD,1B20	;OUTPUT DONE
	XP	IR.EOF,1B21	;END OF FILE
	XP	IR.IER,1B22	;INPUT ERROR
	XP	IR.OER,1B23	;OUTPUT ERROR
	XP	IR.DOL,1B24	;DEVICE OFF LINE
	XP	IR.DFL,1B25	;DEVICE IS FULL
	XP	IR.QTE,1B26	;QUOTA EXCEEDED
	XP	IR.IOW,1B27	;I/O WAIT
	XP	IR.ONL,1B28	;DEVICE ON LINE
	XP	IR.RHC,1B29	;RIB HAS CHANGED
	XP	IR.HNG,1B30	;HUNG DEVICE
	XP	IR.RSW,1B31	;REEL SWITCH
	XP	IR.IAL,1B32	;INPUT AVAILABLE
	XP	IR.ALL,37777B32
;BITS IN THE DECNET EVENT INTERRUPT REASON WORD
	XP	DR.EVT,1B35	;A DECNET EVENT IS WAITING FOR NETWORK MGMT
;TABLE OF CONDITION CODES THAT CAN CAUSE INTERRUPTS

	DEFINE	COND(COD),<
	XP	C$MIN,C$MIN-1		;DECREMENT MINIMUM CODE
	IFNB	<COD>,<XP COD,C$MIN>	;SET NEW CODE = NEW MIN
>


	XP	C$MIN,0		;INITIAL VALUE OF MOST NEGATIVE CONDITION.


	COND	C$TLE,		;(-1) TIME LIMIT EXCEEDED
	COND	C$TMR,		;(-2) TIMER REQUEST
	COND	C$CTLC,		;(-3) CONTROL-C INTERCEPT
	COND	C$AUUO,		;(-4) ANY MUUO
	COND	C$IUUO,		;(-5) ILLEGAL UUO
	COND	C$IMR,		;(-6) ILL MEM REF
	COND	C$ADCK,		;(-7) ADDRESS CHECK
	COND	C$ARIT,		;(-10) ARITHMETIC EXCEPTION
	COND	C$PLOV,		;(-11) PDL OV
	COND	C$NSP,		;(-12) DECNET NSP. INTERRUPTS
	COND	C$NXM,		;(-13) NON-EX MEM
	COND	C$APRC,		;(-14) APR CLOCK
	COND	C$UEIJ,		;(-15) USER INDUCED ERROR IN JOB
	COND	C$XEIJ,		;(-16) EXTERNAL ERROR IN JOB
	COND	C$KSYS,		;(-17) KSYS WARNING
	COND	C$DSET,		;(-20) DATASET STATUS CHANGE
	COND	C$DATT,		;(-21) DETACH/ATTACH
	COND	C$WAKE,		;(-22) WAKE UUO
	COND	C$ADRB,		;(-23) ADDRESS BREAK
	COND	C$IPC,		;(-24) IPCF (MESSAGE AVAILABLE)
	COND	C$DEVT		;(-25) DECNET EVENT
	COND	C$QUE,		;(-26) ENQ/DEQ (RESOURCE AVAILABLE)
	COND	C$NTC,		;(-27) NETWORK TOPOLOGY CHANGE
	COND	C$JBI,		;(-30) CROSS JOB INTERRUPTS
	COND	C$DTC,		;(-31) DATE/TIME CHANGE
	COND	C$OOB,		;(-32) OUT-OF-BAND INTERRUPT CHARACTER
	COND	C$R2C1,		;(-33) RESERVED TO CUSTOMER
	COND	C$R2C2,		;(-34) RESERVED TO CUSTOMER
	COND	C$SCS,		;(-35) SCS EVENT
	COND	C$ETH,		;(-36) ETHERNET EVENT
	COND	C$LLM,		;(-37) LLMOP EVENT
	COND	C$LAT,		;(-40) LAT EVENT
	SUBTTL	FILE (FILOP./OPEN/LOOKUP/ENTER/RENAME) ERROR CODES

;ERROR CODES RETURNED TO USERS ON FILOP./LOOKUP/ENTER/RENAME FAILURES
;ERROR CODE RETURNED IN AC FOR FILOP.; IN RH OF EXTENSION WORD FOR OTHERS.

	XP	FNFERR,0	;FILE OR SEGMENT NOT FOUND OR 0 FILE NAME
	XP	IPPERR,1	;INCORRECT PROJECT,PROGRAMMER NUMBERS
	XP	PRTERR,2	;PROTECTION FAILURE (OR DIRECTORY FULL ON DTA)
	XP	FBMERR,3	;FILE BEING MODIFIED
	XP	AEFERR,4	;ALREADY EXISTING FILE ON ENTER/RENAME
				; OR DIFFERENT FILE NAME ON UPDATE ENTER
	XP	ISUERR,5	;ILLEGAL SEQUENCING OF UUOS
				; (RENAME WITHOUT LOOKUP OR ENTER; LOOKUP AFTER ENTER)
	XP	TRNERR,6	;TRANSMISSION ERROR OR BAD UFD
	XP	NSFERR,7	;NOT A SAVE FILE (RUN,GETSEG UUO ONLY)
	XP	NECERR,10	;NOT ENOUGH CORE (RUN,GETSEG,SEGOP. UUO ONLY)
	XP	DNAERR,11	;DEVICE NOT AVAILABLE
	XP	NSDERR,12	;NO SUCH DEVICE
	XP	ILUERR,13	;ILLEGAL UUO (GETSEG,SEGOP. ONLY)
	XP	NRMERR,14	;NO ROOM ON THIS FILE STRUCTURE ON ENTER
				; OR ALLOCATION OR USER QUOTA EXCEEDED
				; (OVERDRAW DOESN'T COUNT ON ENTER)
	XP	WLKERR,15	;WRITE LOCK ERROR - CAN'T WRITE HIGH SEGMENT OR
				; ON FILE STRUCTURE. EITHER HARDWARE
				; OR SOFTWARE WRITE PROTECTED.
	XP	NETERR,16	;NOT ENOUGH MONITOR TABLE SPACE
	XP	PAOERR,17	;PARTIAL ALLOCATION ONLY
	XP	BNFERR,20	;BLOCK NOT FREE ON ALLOCATION WHERE STARTING
				; LOGICAL BLOCK NUMBER OF FILE STRUCTURE SPECIFIED.
	XP	CSDERR,21	;CAN'T SUPERCEDE A DIRECTORY
	XP	DNEERR,22	;CAN'T DELETE A NON-EMPTY DIRECTORY
	XP	SNFERR,23	;SFD NOT FOUND
	XP	SLEERR,24	;SEARCH LIST EMPTY
	XP	LVLERR,25	;NESTING TO TOO DEEP A LEVEL
	XP	NCEERR,26	;NO-CREATE OR READ-ONLY ON FOR ALL STR'S IN LIST
	XP	SNSERR,27	;SEGMENT NOT ON SWAPPING SPACE (GETSEG ONLY)
	XP	FCUERR,30	;FILE CAN'T BE UPDATED
	XP	LOHERR,31	;LOW SEGMENT OVERLAPS HIGH SEGMENT (GETSEG ONLY)
	XP	NLIERR,32	;NOT LOGGED IN (RUN UUO ONLY)
	XP	ENQERR,33	;FILE STILL HAS OUTSTANDING LOCKS ON IT
	XP	BEDERR,34	;BAD EXE FILE DIRECTORY (GETSEG, RUN UUO)
	XP	BEEERR,35	;BAD EXTENSION FOR EXE FILE
				; ".EXE" ISN'T AN EXE FILE,
				;  OR ".ANYTHING ELSE"
				; IS (GETSEG, RUN UUO)
	XP	DTBERR,36	;EXE DIRECTORY IS TOO BIG (GETSEG, RUN UUO)
	XP	ENCERR,37	;TSK - EXCEEDED NETWORK CAPACITY
	XP	TNAERR,40	;TSK - TASK NOT AVAILABLE
	XP	UNNERR,41	;TSK - UNKNOWN NETWORK NODE (WENT DOWN DURING LOOKUP/ENTER)
	XP	SIUERR,42	;RENAME - SFD IS IN USE BY ANOTHER JOB
	XP	NDRERR,43	;DELETE - FILE HAS AN NDR LOCK
	XP	TMYERR,44	;TOO MANY READERS
	XP	SLLERR,45	;RENAME - SFD TO LOWER LEVEL
	XP	CNOERR,46	;CHANNEL NOT OPEN (FILOP.)
	XP	DDUERR,47	;DEVICE DOWN AND UNUSEABLE (DETACHED)
	XP	DRSERR,50	;DEVICE IS RESTRICTED
	XP	DCMERR,51	;DEVICE IS CONTROLLED BY THE MDA
	XP	DAJERR,52	;DEVICE BELONGS TO ANOTHER JOB
	XP	IDMERR,53	;ILLEGAL DATA MODE
	XP	UOBERR,54	;UNDEFINED/UNKNOWN OPEN BITS SET
	XP	DUMERR,55	;DEVICE IN USE ON MPX CHANNEL
	XP	NPCERR,56	;NO (NOT ENOUGH) PER PROCESS SPACE FOR
				; THE EXTENDED I/O CHANNEL TABLE
	XP	NFCERR,57	;NO FREE CHANNELS AVAILABLE
	XP	UFFERR,60	;UNKNOWN FILOP. FUNCTION
	XP	CTBERR,61	;CHANNEL NUMBER TOO BIG
	XP	CIFERR,62	;CHANNEL ILLEGAL FOR OPERATION
	XP	ACRERR,63	;ADDRESS CHECK READING ARGUMENTS
	XP	ACSERR,64	;ADDRESS CHECK STORING ANSWER
	XP	NZAERR,65	;NEGATIVE OR ZERO OR ILLEGAL ARGUMENT COUNT
	XP	ATSERR,66	;ARGUMENT BLOCK TOO SHORT
	XP	LBLERR,67	;MAGTAPE LABELING ERROR
	XP	DPSERR,70	;DUPLICATE SEGMENT ERROR
	XP	NFSERR,71	;NO FREE SECTION AVAILABLE ERROR (SEGOP.)
	XP	SIIERR,72	;SEGMENT INFO INCONSISTANT (NAME AND NUMBER DON'T AGREE)
	SUBTTL	EXTENDED I/O ERRORS

;CODES RETURNED BY DEVOP. FUNCTION 3
	IOPLE%==1		;PAGE LIMIT EXCEEDED (LPT)
	IOVFE%==2		;VFU FORMAT ERROR (LPT)
	IOLTE%==3		;LABEL TYPE ERROR (MTA)
	IOHLE%==4		;HEADER LABEL ERROR (MTA)
	IOTLE%==5		;TRAILER LABEL ERROR (MTA)
	IOVLE%==6		;VOLUME LABEL ERROR (MTA)
	IODER%==7		;HARD DEVICE ERROR
	IOPAR%==10		;PARITY ERROR
	IOWLE%==11		;WRITE LOCK ERROR
	IOIPO%==12		;ILLEGAL POSITIONING OPERATION (MTA)
	IOBOT%==13		;BEGINING OF TAPE (MTA)
	IOIOP%==14		;ILLEGAL OPERATION (MTA
	IOFNF%==15		;FILE NOT FOUND (MTA)
	IOCAN%==16		;OPR CANCELLED REEL SWITCH (MTA)
	IOTMV%==17		;TOO MANY VOLUMES IN VOLUME-SET (MTA)
	IONND%==20		;NETWORK NODE DOWN
	IOUNC%==21		;UNDEFINED CHARACTER INTERRUPT (LP20)
	IORPE%==22		;RAM PARITY ERROR (LP20)
	IOLRA%==23		;LABELER REQUEST ABORTED BY RESET UUO (MTA)
	IOVPF%==24		;VOLUME PROTECTION FAILURE (MTA)
	IOFPF%==25		;FILE PROTECTION FAILURE (MTA)
	IOUEF%==26		;UNEXPECTED FILE (MTA)
	IONDD%==27		;NETWORK DEVICE DISCONNECTED
	IOMAX%==27		;HIGHEST LEGAL EXTENDED ERROR CODE

;BITS RETURNED BY DEVOP. FUNCTION 5
	XP	DV.OFL,1B0	;DEVICE IS OFF-LINE
	XP	DV.VLE,1B34	;VFU LOAD ENABLED
	XP	DV.VFE,1B35	;VFU ERROR
	SUBTTL	JOB BUFFER HEADER

; JOB BUFFER AREA HEADER
	XP	JBFADR,0	;BIT 0=1 IF THIS BUFFER RING HAS NEVER BEEN
				; REFERENCED FROM THE USER'S PROGRAM BY
				; AN INPUT OR OUTPUT COMMAND.
				; BITS 1-17=UNUSED
				; BITS 18-35=CURRENT BUFFER ADDRESS
	XP	JBFPTR,1	;BYTE POINTER TO NEXT BYTE -1
	XP	JBFCTR,2	;POSITIVE ITEM COUNT
	XP	JBFUDX,3	;UDX FOR MSGSER
; JOB BUFFER HEADER
	XP	IOUSE,400000	;1 IF BUFFER IS FULL (OR BEING EMPTIED)
				; 0 IF BUFFER IS EMPTY (OR BEING FILLED)
				; BITS 1-17=BUFFER SIZE
				; BITS 18-35=NEXT BUFFER ADDRESS
	XP	IOIBC,200000	;INHIBIT CLEARING OUTPUT BUFFERS BEFORE
				; GIVING THEM TO THE USER IF .OPIBC WAS
				; SPECIFIED IN THE OPEN STATEMENT FOR THIS CHANNEL
	XP	IONER,700000	;PRESENTLY ONLY USED BY TSK DEVICE. SET MEANS
	XP	IOSIZ,177777	; MASK OF BUFFER SIZE OF THIS BUFFER
				; THE DATA IN THE BUFFER DOES NOT INCLUDE END OF RECORD.

; DEFINITIONS FOR TRANSPOSING EXTRA DATA BIT IN CLOCK QUEUE DATA ITEMS
	XP	CLKEXB,400000	;EXTRA DATA BIT IN LH OF REQUEST WORD
	XP	CLKDB7,100	;DATA BIT 7 OF DATA ITEM RH
	SUBTTL	ARGUMENTS FOR EXTENDED LOOKUP/ENTER/RENAME

;SYMBOLS FOR MAKING PARTS OF WORDS BE A CONSTANT OF ZERO
; SO THAT FUTURE PROGRAMMERS WILL KNOW THAT THAT BYTE MUST BE ZERO.

	XP	ZERO36,0	;36 BITS OF ALWAYS ZERO
	XP	ZERO18,0	;18 BITS (LH OR RH DEPENDING ON WHICH FIELD OF XWD.
	XP	ZERO13,0	;INDIRECT BIT
	XP	ZERO5,0		;5 BITS (USUALLY LH BITS 13 THRU 17, I.E., @ AND INDEX FIELD
			; OF POINTERS WHICH WANT TO BE REFERENCED USING INDIRECTION

	XP	UUNNAM,0
	XP	UUNEXT,1
	XP	UUNATT,2
	XP	UUNPPN,3
	XP	UUXNUM,0
	XP	UUXPPN,1
	XP	UUXNAM,2
	XP	UUXEXT,3
	XP	UUXPRV,4
	XP	UUXSIZ,5
	XP	UUXVER,6
	XP	UUXFUT,7
	XP	UUXEST,10
	XP	UUXALC,11
	XP	UUXPOS,12
	XP	UUXFT1,13
	XP	UUXNCA,14
	XP	UUXLNA,UUXNCA
	XP	UUXMTA,15
	XP	UUXDEV,16
	XP	UUXSTS,17
	XP	UUXELB,20
	XP	UUXEUN,21
	XP	UUXQTF,22
	XP	UUXTYP,UUXQTF
	XP	UUXQTO,23
	XP	UUXBSZ,UUXQTO
	XP	UUXQTR,24
	XP	UUXRSZ,UUXQTR
	XP	UUXUSD,25
	XP	UUXFFB,UUXUSD
	XP	UUXAUT,26
	XP	UUXNXT,27
	XP	UUXPRD,30
	XP	UUXPCA,31
	XP	UUXUFD,32
	XP	UUXFLR,33
	XP	UUXXRA,34
	XP	UUXTIM,35
	XP	UUXLAD,36
	XP	UUXDED,37
	XP	UUXENX,UUXDED	;LAST "REGULAR VALUE"
	XP	UUXACT,40
	XP	UUXENT,UUXACT	;LAST ARG OR VALUE FOR EXTENDED UUOS
	SUBTTL	MEM PARITY ERROR RECOVERY

;MEM PARITY COMMUNICATION BITS BETWEEN CPUS AND INTERRUPT LEVELS
;THE FOLLOWING BITS ARE DEFINED HERE AND ARE STORED IN LH OF VARIABLE .CPAEF
; AND CONSTANT .CPMPS
	XP	CP.PXX,1B0	;SOME CPU OR CHANNEL REQUESTED A MEMORY SCAN FOR
				; PARITY OR NXM TO BE DONE ON THIS CPU
	XP	CP.PS0,1B1	;CPU0 REQUESTED THIS CPU TO SCAN
	XP	CP.PS1,1B2	;CPU1
	XP	CP.PS2,1B3	;CPU2
	XP	CP.PS3,1B4	;CPU3
	XP	CP.PS4,1B5	;CPU4
	XP	CP.PS5,1B6	;CPU5
	XP	CP.PSX,CP.PS0!CP.PS1!CP.PS2!CP.PS3!CP.PS4!CP.PS5 ;ANY CPU REQ SCAN
	XP	CP.CS0,1B7	;CHANNEL 0 REQUESTED THIS CPU TO SCAN
	XP	CP.CS1,1B8	;CHN 1
	XP	CP.CS2,1B9	;CHN 2
	XP	CP.CS3,1B10	;CHN 3
	XP	CP.CS4,1B11	;CHN 4
	XP	CP.CS5,1B12	;CHN 5
	XP	CP.CS6,1B13	;CHN 6
	XP	CP.CS7,1B14	;CHN 7
	XP	CP.CSX,CP.CS0!CP.CS1!CP.CS2!CP.CS3!CP.CS4!CP.CS5!CP.CS6!CP.CS7  ;ANY CHAN REQ SCAN
	 SUBTTL CPU UP/DOWN BITS
;BITS IN .CPRUN DETERMINING RUNNABILITY STATE OF A CPU
	XP CR.NRN,1B0	;NO RUN (NOT RUNNING), MUST BE THE SIGN BIT
	XP CR.RMV,1B1	;REMOVE(D)
	XP CR.DET,1B2	;DETACH(ED)
	XP CR.SPD,1B3	;SUSPEND(ED)
	XP CR.TSS,1B4	;TAKE A SNAP SHOT/SNAP SHOT FAILED
	XP CR.ATO,1B5	;WAITING FOR AUTCON TO RUN
;THE FOLLOWING DEFINITIONS ARE USED AS LOCAL SYMBOLS
; IN KLSER FOR AR-ARX PARITY ERROR RECOVERY
	TRPTRY==4	;# OF RETRIES BEFORE FAILURES ARE NON-RECOVERABLE
	CCHEMX==3	;# OF HARD CACHE ORIENTED FAILURES TO ALLOW
			; DURING A MONITOR LOAD PERIOD BEFORE TURNING
			; THE CACHE OFF AND TELLING OPERATOR

;LOCAL FLAG WORD DEFINITIONS
	PFCPF0==1B18	;A LOCAL RETRY TEST REFERENCE IS IN PROGRESS
	PFCPF1==1B19	;ERROR IS NON-RECOVERABLE
	PFCPF2==1B20	;ERROR DURING RETRY TEST REFERENCE
	PFCPF3==1B21	;CACHE WAS ENABLED WHEN TRAP OCCURRED
	PFCPF4==1B22	;ERROR OCCURRED DURING CACHE SWEEP TO CORE
	PFCPF5==1B23	;CACHE WAS TURNED OFF (DISABLED) BECAUSE
			; .GT. CCHEMX FAILURES HAVE OCCURED
DMACLR==110000		;LEFT HALF VALUE TO CLEAR ERROR BITS IN
			; DMA20 WITH SBDIAG.

.SBNMC==21		;NUMBER OF MEMORY CONTROLLERS FOR SBDIAG
			; (0-3 ARE MA20 OR MB20, 4 IS DMA20, 5-7 UNUSED, 10-20 ARE MF20)
.SBFNC==2		;NUMBER OF SBDIAG FUNCTIONS (0 AND 1)
SB.CLR==(1B5)		;LEFT-HALF BIT TO CLEAR ERROR FLAGS IN SBDIAG
			; FUNCTION 0
.PMMER==1		;CODE SENT TO TGHA INDICATING SINGLE BIT MOS ERROR
	SUBTTL  CODES FOR DAEMON ERROR REPORTING

;ERROR CODES FOR DAEMON ERROR REPORTING
;PASSED IN LH OF AC RETURNED ON ERRPT. UUO


.ERWHY==1	;RELOAD MONITOR ERROR
.ERMSE==2	;NON-RELOAD MONITOR ERROR
.ERMPE==3	;CPU MEMORY PARITY ERROR
.ERNXM==4	;NON-EXISTENT MEMORY ERROR
.ERCPE==6	;CHANNEL ERROR
.ERDPE==10	;DISK ERROR
	.FIRBE==1	;FILIO-DETECTED RIB ERROR
	.FIBOS==2	;FILIO-DETECTED "BUSY ON WHEN WE STARTED"
	.FIER3==3	;FILIO-DETECTED DISK ERROR
	.FIER4==4	;FILIO-DETECTED DISK ERROR
	.FICKE==5	;FILIO-DETECTED CHECKSUM ERROR
	.FIUOF==6	;FILIO-DETECTED UNIT OFFLINE
.ERDXE==12	;DX20 DEVICE ERROR
;.ERSEB==13	;SYSTEM ERROR BLOCK AVAILABLE (OBSOLETE)
.ERSWE==14	;SOFTWARE EVENT OF INTEREST
	.SWEPK==1	;EVENT WAS A POKE
	.SWESN==2	;EVENT WAS A SNOOP.
	.SWETP==3	;EVENT WAS A TRPSET
	.SWERT==4	;EVENT WAS A RTTRAP
	.SWMS1==5	;MISC EVENT 1 (FOR DEBUGGING)
	.SWMS2==6	;MISC EVENT 2 (FOR DEBUGGING)
.ERCSC==15	;CONFIGURATION STATUS CHANGE
	.CSCAT==0	;ATTACH
	.CSCDT==1	;DETATCH
	.CSCXC==2	;EXCHANGE
	.CSCTC==3	;DATE/TIME CHANGE
	.CSCCF==4	;SET CPU OFF-LINE
	.CSCCO==5	;SET CPU ON-LINE
	.CSCNF==6	;NODE OFF-LINE
	.CSCNO==7	;NODE ON-LINE
	.CSCMO==10	;SET MEMORY ON-LINE
	.CSCMF==11	;SET MEMORY OFF-LINE
	.CSCPO==12	;MONITOR (PARITY RECOVERY) SET MEM OFF-LINE
.ERMAG==20	;MAGTAPE ERROR
.ERTAP==21	;TAPSER MAGTAPE ERROR
.ERDTA==25	;DECTAPE ERROR
.ERKLE==30	;KL CPU ERROR INFO FROM FRONT END
.ERMSC==41	;MAGTAPE STATISTICS
.ERTPS==42	;TAPSER MAGTAPE STATISTICS
.ERDSC==45	;DISK STATISTICS (USUALLY FROM A CRASH)
.ERDLE==50	;DL10 HARDWARE ERROR
.ERKIP==51	;KI PARITY/NXM INTERRUPT (7.01)
.ERKLP==52	;KL PARITY/NXM INTERRUPT (7.01)
.ERKSM==53	;KS MEMORY ERROR
.ERKSN==54	;KS NXM TRAP (7.01)
.ERKPT==55	;KL/KS PARITY TRAP (7.01)
.ERSNX==56	;NXM MEMORY SCAN (7.01)
.ERSPR==57	;PARITY MEMORY SCAN (7.01)
.ERKDT==61	;KL10 DATA PARITY TRAP
.ERCSB==63	;CPU STATUS BLOCK
.ERDSB==64	;DEVICE STATUS BLOCK
.ERLPT==71	;LPT ERROR
.ERHCC==72	;HARD COPY CONTROLLER ERROR
.ERULD==73	;MICROCODE LOAD
.ERCIE==74	;CI DISK ERROR
.ERICD==75	;IPA20 CHANNEL DUMP
.ERDTC==100	;DATE/TIME CHANGE
	SUBTTL	SYSTEM ERROR BLOCK DEFINITIONS


	PHASE	0		;DEFINE AS OFFSETS

.EBLNK:!BLOCK	1		;LINK TO NEXT BLOCK (MUST BE FIRST WORD)

.EBTYP:!BLOCK	1		;BYTE (9) TYPE CODE,0,0,LENGTH OF BLOCK (EXCL. HEADER)

.EBDTM:!BLOCK	1		;UNIVERSAL DATE/TIME OF ERROR

.EBUPT:!BLOCK	1		;SYSTEM UPTIME WHEN ERROR OCCURRED

.EBASN:!BLOCK	1		;APR SERIAL NUMBER OF CPU ON WHICH ERROR OCCURRED

.EBSEQ:!BLOCK	1		;DAEMON FILLS IN THE SEQUENCE NUMBER.  THIS WORD
				; ONLY APPEARS HERE FOR DAEMON'S EASE IN COPYING
				; THE ERROR BLOCK INTO THE ERROR FILE BUFFER.

.EBHDR:!			;LENGTH OF HEADER

	DEPHASE
	SUBTTL	SYSTEM ERROR BLOCK ENTRY FORMATS


;***********************************
;CI DISK/TAPE  ENDPACKET CODE
;***********************************

SEC%CI==242			;CI EVENT
  CI%NOD==0			;PORT NUMBER,,NODE NUMBER
  CI%VID==1			;VOLUME ID
  CI%RED==2			;BLOCKS/FRAMES READ
  CI%WRT==3			;BLOCKS/FRAMES WRITTEN
  CI%PS1==4			;POSITION 1
  CI%PS2==5			;POSITION 2
  CI%UDB==6			;REQUIRED FOR BAT BLOCK LOGIC
  CI%LOC==7			;LINEAR ADDRESS FROM ERROR BLOCK
  CI%PAK==10			;START OF PACKET WITH ERROR BIT ON
CI%SIZ==CI%PAK+^D9		;SIZE OF DATA BLOCK
CI%LEN==CI%SIZ			;TOTAL LENGTH, CURRENTLY NO STRINGS REPORTED


;***********************************
;CI DISK/TAPE  ERROR LOG CODE
;***********************************

SEC%EL==243			;MSCP ERROR LOG EVENT
  EL%NOD==0			;PORT,,NODE
  EL%PAK==1			;START OF THE PACKET
EL%SIZ==^D97			;SIZE OF DATA BLOCK
EL%LEN==EL%SIZ			;TOTAL LENGTH, CURRENTLY NO STRINGS REPORTED


;***********************************
;KLIPA ERROR CODE
;***********************************

SEC%KP==244			;KLIPA ERROR EVENT
  KP%CSR==0			;CONI STATUS
  KP%VER==1			;MICROCODE VERSION
	KP%NI==1B0		;SET IF THIS IS A KLNI
  	KP%CHN==7B17		;PORT'S RH20 CHANNEL
  KP%DSP==2			;ERROR DISPOSITION
  KP%CRA==3			;CRAM ADDRESS
  KP%CRD==4			;CRAM DATA (2 WORDS)
  KP%LG0==6			;LOGOUT WORD 0
  KP%LG1==7			;LOGOUT WORD 1
  KP%LG2==10			;LOGOUT WORD 2
  KP%ECW==11			;PORT'S ERROR WORD
  KP%PE0==12			;PORT'S ERROR LOGOUT WORD 0
  KP%PE1==13			;PORT'S ERROR LOGOUT WORD 1
KP%SIZ==14			;SIZE OF DATA BLOCK
KP%LEN==KP%SIZ			;TOTAL LENGTH, CURRENTLY NO STRINGS REPORTED
;***********************************
;KLIPA STATISTICS PACKET
;***********************************

SEC%KS==241			;KLIPA STATISTICS EVENT
  KS%OFF==0			;OFFSET TO COUNTERS
  KS%VER==1			;U-CODE VERSION WORD
  	KS%NI==1B0		;0=CI, 1=NI
	KS%RSN==17B14		;REASON FOR DOING READ-COUNTERS
				; 0=ILLEGAL
		KS%PCP==1	; PORT CRAM PARITY ERROR
		KS%AGB==2	; WIRE A WENT FROM GOOD TO BAD
		KS%ABG==3	; WIRE A WENT FROM BAD TO GOOD
		KS%BGB==4	; WIRE B WENT FROM GOOD TO BAD
		KS%BBG==5	; WIRE B WENT FROM BAD TO GOOD
		KS%PER==6	; PERIODIC READING OF COUNTERS
		KS%GUC==7	; GET U-CODE VERSION
		KS%DIA==10	; DIAG% DID IT
	KS%CHN==7B17		;KLIPA CHANNEL #
	KS%VSN==777777B35	;U-CODE VERSION
KS%AAK==2			;PATH A ACKS
KS%ANK==3			;PATH A NACKS
KS%ANR==4			;PATH A NO-RESPONSES
KS%BAK==5			;PATH B ACKS
KS%BNK==6			;PATH B NACKS
KS%BNR==7			;PATH B NO-RESPONSES
KS%DGD==10			;DATAGRAMS DISCARDED
KS%PXM==11			;PACKETS TRANSMITTED
KS%PRC==12			;PACKETS RECEIVED
KS%DPT==13			;DESIGNATED PORT WORD
	KS%PRT==377B31		;DESIGNATED PORT
KS%CRC==14			;PACKETS RECEIVED WITH CRC ERRORS
KS%EW1==15			;ERROR WORD 1
	KS%MPE==777777B17	;MOVER PAR PRE ERRORS
	KS%CPE==777777B35	;CBUS PARITY ERRORS
KS%EW2==16			;ERROR WORD 2
	KS%RPE==777777B17	;REGISTER PLIPE ERRORS
	KS%DPE==777777B35	;DATA PLIPE ERROS
KS%EW3==17			;ERROR WORD 3
	KS%CHE==777777B17	;CHANNELS ERRORS
	KS%EPE==777777B35	;EBUS PARITY ERRORS
KS%EW4==20			;ERROR WORD 4
	KS%SCE==777777B17	;SPURIOUS CHANNEL ERRORS
	KS%CAT==777777B35	;CBUS AVAILABLE TIMEOUTS
KS%EW5==21			;ERROR WORD 5
	KS%SRA==777777B17	;SPURIOUS RECEIVE ATTENTIONS
	KS%STA==777777B35	;SPURIOUS TRANSMIT ATTENTIONS
KS%EW6==22			;ERROR WORD 6
	KS%TBP==777777B17	;TRANSMIT BUFFER PARITY ERRORS
	KS%TTM==777777B35	;TRANSMITTER TIMEOUTS
KS%SIZ==23			;SIZE OF EVENT BLOCK
KS%LEN==KS%SIZ			;NO ADDITIONAL STRINGS
;***********************************
;KLIPA ERROR-LOG PACKET (PPD BYTE 5 FROM HSC50)
;***********************************

SEC%KE==246			;KLIPA ERROR-LOG PACKET CODE
  KE%SRC==0			;SOURCE WORD
  	KE%CHN==7B17		;KLIPA CHANNEL #
	KE%NOD==17B35		;HSC50 NODE #
  KE%LEN==1			;LENGTH OF DATA AREA
  KE%ELG==1			;BEGINNING OF ERROR LOG INFO
	SUBTTL	WARM RESTART

;WARM RESTART REASON CODES


.WRCES==1	;CLOCK ERROR STOP
.WREPE==2	;EBUS PARITY ERROR
.WRDEX==3	;DEX FAILURE
.WRKAC==4	;KEEP ALIVE CEASED
.WRPTO==5	;PROTOCOL TIMEOUT
.WRFMP==6	;FAST MEMORY PARITY ERROR
.WRCRP==7	;CRAM PARITY ERROR
.WRDRP==10	;DRAM PARITY ERROR


;WRSINS==72	;LOCATION OF INSTRUCTION EXECUTED BY RSX20F ON A WARM RESTART
;WRSLOC==100	;LOCATION WHERE RSX20F STORES PC AND CODE ON A WARM RESTART
	SUBTTL	BITS IN STATES AND DEBUGF

;SYSTEM STATE WORD (STATE)
;  LH CHANGED ONLY BY ONCE
;  RH CHANGED BY SCHED COMMAND

ST.DSK==1B0			;DISK SYSTEM
ST.SWP==1B1			;SWAPPING SYSTEM
ST.LOG==1B2			;LOGIN
ST.FTT==1B3			;FULL DUPLEX TTY SOFTWARE
ST.PRV==1B4			;PRIVILEGES
ST.TWR==1B5			;DUAL SEGMENT SOFTWARE
ST.CYC==1B6			;50 HERTZ CLOCK
ST.TDS==7B9			;TYPE OF DISK SYSTEM
ST.IND==1B10			;IND. PPNS ON DISK
ST.IMG==1B11			;IMAGE MODE TTYS
ST.DUL==1B12			;DUAL PROCESSOR SYSTEM
ST.MRB==1B13			;MULTIPLE RIBS SUPPORTED
ST.HPT==1B14			;HIGH PRECISION TIME ACCOUNTING (DK10)
ST.EMO==1B15			;EXCLUDE MONITOR OVERHEAD FROM RUN TIMES
ST.RTC==1B16			;REAL TIME CLOCK (DK10)
ST.MBF==1B17			;MONITOR BUILT FOR FOROTS
				; (5.06 AND AFTER, 504B, 505A)
ST.DDL==1B26			;NO AUTO DOWN LINE DC72,DC71,DAS 80 SERIES
ST.NOP==1B27			;NO OPERATOR IN ATTENDANCE
ST.NSP==1B28			;UNSPOOL DEVICES
ST.ASS==1B29			;ASSIGN/INIT DEVICES
ST.NRT==1B32			;NO REMOTE TTY'S
ST.BON==1B33			;BATCH ONLY
ST.NRL==1B34			;NO REMOTE LOGINS
ST.NLG==1B35			;NO LOGINS EXCEPT CTY/OPR
;BITS IN CNFST2

ST%EXE==1B21			;SAVE AND SSAVE CREATE .EXE FORMAT FILES
ST%EMR==1B20			;EBOX/MBOX RUNTIME IN EFFECT
ST%XPI==1B19			;EXCLUDE PI TIME IN USER RUNTIME
ST%ITA==1B17			;INTERVAL TIMER AVAILABLE (ON KL10 ONLY)
ST%NCS==1B16			;IF SET, SCHEDULER IS NOT CLASS SYSTEM
				; SCHEDULER.
ST%NER==1B15			;MONITOR SUPPORTS 6.03 ERROR REPORTING
ST%ACV==1B14			;SYSTEM DOES ACCOUNT-STRING VERIFICATION
ST%LSC==1B13			;MONITOR LOW SEGMANT IS CACHED
ST%MDA==1B12			;MOUNTABLE DEVICE ALLOCATOR WILL RUN
ST%KLP==1B11			;MONITOR USES KL STYLE PAGING
ST%D36==1B10			;MONITOR HAS DECNET LOADED
ST%EXA==1B9			;MONITOR SUPPORTS USER MODE EXTENDED ADDRESSING
ST%RCM==1B8			;RESTRICTED COMMANDS MONITOR
ST%NPP==1B7			;PREVENT STARTING PRIMARY PROTOCOL ON DTE'S
ST%END==1B6			;RUNNING AS DECNET ENDNODE
ST%NSE==1B5			;NO OPERATOR NOTIFICATION OF SOFT MEMORY ERRORS

;BITS IN DEBUGGING WORD
DF.SBD==1B0			;SYSTEM BEING DEBUGGED
DF.RDC==1B1			;RELOAD ON DEBUG STOPCD'S
DF.RJE==1B2			;RELOAD ON JOB ERRORS
DF.NAR==1B3			;NO AUTO RELOADS
DF.CP1==1B4			;STOP SYSTEM ON CPU STOPCD ON ANY CPU
DF.DDC==1B5			;DON'T DO CONTINUABLE STOPCD DUMP ON DEBUG STOPCDS
DF.DJE==1B6			;DON'T DO CONTINUABLE STOPCD DUMP ON JOB STOPCDS
DF.DCP==1B7			;DON'T DO CONTINUABLE STOPCD DUMP ON CPU STOPCDS
DF.RQC==1B8			;CALL CRSCPY ON NEXT CLOCK TICK ON BOOT CPU
DF.RQK==1B9			;CALL KDPLDR ON NEXT CLOCK TICK
DF.RQN==1B10			;CALL KNILDR ON NEXT CLOCK TICK (OBSOLETE)
DF.WFL==1B11			;COPY OUTPUT TO FRCLIN TO SYSTEM CTY
DF.DCC==1B12			;DISABLE NEXT CRSCPY REQUEST
DF.RIP==1B13			;RELOAD IN PROGRESS (RECON. FUNCTION .RCRLD)
DF.RAD==1B14			;RELOAD AFTER DUMP (DON'T DUMP TWICE IN MONBTS)
DF.RLD==1B15			;STOPCD CAUSED A RELOAD (FOR CRSCPY)

DF.BP0==1B18			;CAN ENTER EDDT ON CPU0 USING XCT .C0DDT
DF.BP1==1B19			;CAN ENTER EDDT ON CPU1 USING XCT .C1DDT
DF.BP2==1B20			;CAN ENTER EDDT ON CPU2 USING XCT .C2DDT
DF.BP3==1B21			;CAN ENTER EDDT ON CPU3 USING XCT .C3DDT
DF.BP4==1B22			;CAN ENTER EDDT ON CPU4 USING XCT .C4DDT
DF.BP5==1B23			;CAN ENTER EDDT ON CPU5 USING XCT .C5DDT
DF.BPT==DF.BP0!DF.BP1!DF.BP2!DF.BP3!DF.BP4!DF.BP5 ;MASK OF CPU BPT BITS
	SUBTTL	MTAPE AND TAPOP. DEFINITIONS

XP MT.DEC,100		;DEC COMPATIBLE
XP MT.IND,101		;WORLD COMPATIBLE
XP MT.STL,200		;SET TO LOW THRESHOLD (TM10 ONLY)

XP MT.MAX,17		;MAXIMUM MTAPE OPERATION CODE

XP MT.WAT,0		;WAIT
XP MT.REW,1		;REWIND
XP MT.WTM,3		;WRITE TAPE MARK
XP MT.FSR,6		;FORWARD SKIP RECORD
XP MT.BSR,7		;BACK SKIP RECORD
XP MT.SET,10		;SKIP TO LEOT
XP MT.UNL,11		;REWIND & UNLOAD
XP MT.WLG,13		;WRITE LONG GAP (3" BLANK TAPE)
XP MT.FSF,16		;FORWARD SKIP FILE
XP MT.BSF,17		;BACK SPACE FILE

;TD2KON TUBIEP/TUBFEP BLOCK SIZES
XP .TD2MC,25		;# WORDS CONTAINING MISC VALUES
XP .TD2ES,24		;# WORDS CONTAINING DX20 EXTENDED STATUS REGISTERS
XP .TD2MR,27		;# WORDS CONTAINING MASSBUS REGISTERS
	SUBTTL TAPE LABEL DEFINITIONS

IFN FTTLAB,<
;LABEL TYPE CODES

XP LT.BLP,0		;BYPASS LABEL PROCESSING
XP LT.SL,1		;STANDARD DEC (ANSI) LABELS
XP LT.SUL,2		;STANDARD WITH USER LABELS
XP LT.IL,3		;IBM STANDARD LABELS
XP LT.IUL,4		;IBM STANDARD WITH USER LABELS
XP LT.LTM,5		;LEADING TAPE MARK
XP LT.NSL,6		;NON-STANDARD LABELS
XP LT.NL,7		;NO LABELS
XP LT.CBA,10		;DEC COBOL ASCII LABELS
XP LT.CBS,11		;DEC COBOL SIXBIT LABELS
XP LT.NLV,12		;NO-LABELS, USER SEES EOT
XP LT.MAX,12		;MAXIMUM LABEL TYPE DEFINED

;REASON CODES FOR LABEL PROCESSING

XP LR.FIN,1		;FIRST INPUT
XP LR.FOU,2		;FIRST OUTPUT
XP LR.POS,3		;POSITIONING REQUEST
XP LR.TM,4		;TAPE MARK SEEN
XP LR.EOT,5		;EOT SEEN
XP LR.CLI,6		;CLOSE INPUT
XP LR.CLO,7		;CLOSE OUTPUT
XP LR.EOV,10		;FORCE END OF VOLUME
XP LR.URQ,11		;USER REQUEST SERVICE
XP LR.ABO,12		;ABORT OPERATION (RELEASE DONE)

;ERROR CODES RETURNED BY LABEL PROCESS

XP LE.CON,1		;DIDN'T DO POSITIONING REQUEST
XP LE.EOF,2		;RETURN END OF FILE
XP LE.LTE,3		;LABEL TYPE ERROR
XP LE.HDE,4		;HEADER LABEL ERROR
XP LE.TRE,5		;TRAILER LABEL ERROR
XP LE.VLE,6		;VOLUME LABEL ERROR
XP LE.DER,7		;DEVICE ERROR
XP LE.DTE,10		;DATA ERROR
XP LE.WLK,11		;WRITE LOCKED
XP LE.PSE,12		;POSITIONING ERROR
XP LE.BOT,13		;BEGINNING OF TAPE
XP LE.IOP,14		;ILLEGAL I/O OPERATION
XP LE.FNF,15		;FILE NOT FOUND
XP LE.CAN,16		;OPR CANCELLED VOLUME SWITCH
XP LE.TMV,17		;TOO MANY VOLUMES IN VOLUME SET
XP LE.LRA,23		;LABELER REQUEST ABORTED BY RESET UUO

>
	SUBTTL EVENT WAIT CODE DEFINITIONS

;TYPES OF EVENTS

DEFINE EWCODE,<
	X	EV.TKW,SJ	;TAPE KONTROLLER WAIT
	X	EV.REW,SJ	;REWIND WAIT
	X	EV.LBL,SJ	;LABEL PROCESSING WAIT
	X	EV.NET,SJ	;NETWORK DEVICE WAIT
	X	EV.NTC,DJ	;NETWORK TERMINAL CONNECT WAIT
	X	EV.STC,DJ	;NETWORK STATION CONTROL WAIT
	X	EV.DTE,SJ	;DTE IO WAIT
	X	EV.KDP,SJ	;KDP IO WAIT
	X	EV.IPC,SJ	;IPCF SYSTEM PROCESS RECEIVE WAIT
	X	EV.FEI,SJ	;FRONT END DEVICE INPUT WAIT
	X	EV.FEO,SJ	;FRONT END DEVICE OUTPUT WAIT
	X	EV.D60,DJ	;DN60 DEVICE WAIT (WAITING FOR THE PDP11)
	X	EV.DCN,SJ	;DECNET CONNECT/IO WAIT.
	X	EV.DMR,SJ	;DMR IO WAIT
	X	EV.DTI,SJ	;DISTRIBUTED TERMINAL INPUT
	X	EV.DTO,SJ	;DISTRIBUTED TERMINAL OUTPUT
	X	EV.ETH,SJ	;ETHERNET FUNCTION WAIT
	X	EV.LLM,SJ	;LLMOP FUNCTION WAIT
	X	EV.LAT,SJ	;LATOP FUNCTION WAIT
>	;END DEFINE EWCODE
DEFINE X(SYM,CNTLC),<
	XP	SYM,XX
	XX==XX+1
	IFG	<XX>-<-1_<-<^D36-ESLPSZ>>>,<PRINTX	?TOO MANY EVENT WAIT STATE CODES.>
>	;END DEFINE X

;NOW GENERATE THE EVENT WAIT CODES
;
	XX==1			;START EVENT WAIT CODES AT 1
	EWCODE
	SUBTTL CODES SENT TO THE FILE DAEMON

IFN FTFDAE,<
XP .FDCAC,1		;CHECK IF ACCESS IS ALLOWED
XP .FDCLI,2		;CLOSE INPUT
XP .FDCLO,3		;CLOSE OUTPUT
XP .FDXIT,4		;PROGRAM EXECUTION TERMINATED
XP .FDCPA,5		;CHECK IF PROGRAM ACCESS IS ALLOWED
XP .FDCAD,6		;CHECK DIRECTORY ACCESS ALLOWED
XP .FDPSH,7		;PUSHING FROM PROGRAM
XP .FDPOP,10		;POPPING BACK INTO PROGRAM
>

SUBTTL BITS RETURNED TO THE MONITOR BY THE FILE DAEMON

IFN FTFDAE,<
XP FD.CAA,1B0		;CALL THE FILE DAEMON ON EVERY ACCESS TO THE FILE
XP FD.COC,1B1		;CALL THE FILE DAEMON WHEN THE FILE IS CLOSED
XP FD.COX,1B2		;CALL THE FILE DAEMON WHEN PROGRAM EXECUTION TERMINATES
XP FD.SCP,1B3		;FILE DAEMON SPECIFIED CREATE PROTECTION
>

SUBTTL BITS IN THE RH OF .CPSBR

XP SR.CSB,1B35		;CPU STATUS BLOCK READ AT SOME POINT ON THIS CPU
XP SR.DSB,1B34		;DEVICE STATUS BLOCK READ AT SOME POINT ON THIS CPU
XP SR.STS,1B33		;MACHINE STATUS SAVED ON THIS CPU.  USED TO AVOID SAVING
			; STATUS ON SECOND AND SUBSEQUENT 407 STARTS
XP SR.DIE,1B32		;LAST STOPCD WAS CPU.  OPERATOR MUST RESTART PROCESSOR
			;MANUALY
XP SR.ACL,1B31		;THIS CPU IS LOOPING IN THE AC'S. DON'T
			;SAVE THIS AC BLOCK IN SYSTOP
XP SR.LBH,1B30		;LOAD BOOT (OR GO TO MONBTS) ON THIS CPU
			;REGARDLESS OF WHO IS THE BOOT CPU
	SUBTTL	SAVE-FILE FORMAT DEFINITIONS


;DEFINITIONS OF BLOCK TYPES IN SAVE-FILE DIRECTORY
SV.END==1777		;END BLOCK CODE
SV.DIR==1776		;DIRECTORY BLOCK CODE
SV.STA==1775		;ENTRY VECTOR BLOCK

;LENGTHS OF VARIOUS END BLOCKS
LN.END==1		;END BLOCK IS ONLY 1 WORD LONG
LN.STA==3		;ENTRY VECTOR IS 3 WORDS LONG


;BITS IN THE LEFT HALF OF 1ST WORD OF EACH DIRECTORY ENTRY
SV%HIS==(1B0)		;THIS PAGE IS PART OF THE HIGH SEGMENT
SV%SHR==(1B1)		;THIS PAGE IS SHARABLE
SV%WRT==(1B2)		;THIS PAGE IS WRITABLE
SV%CON==(1B3)		;THIS PAGE IS CONCEALED
SV%SYM==(1B4)		;THIS PAGE IS PART OF SYMBOL TABLE (NOT IMPLEMENTED)
SV%ABZ==(1B5)		;THIS PAGE IS ALLOCATED BUT ZERO (INTERNAL FLAG)

;MISCELLANEOUS DEFINITIONS
NTRYSZ==2		;SIZE OF EACH DIRECTORY ENTRY
EXESIZ==^D512		;SIZE OF EXE FILE PAGES
	SUBTTL	EXEC DATA VECTOR DEFINITIONS


; THESE QUANTITIES ARE POINTED TO BY .JBEDV IN JOBDAT

.EDCNT==0	;'EDV',,COUNT (INCLUDES THIS WORD)
.EDHSB==1	;POINTER TO HIDDEN SYMBOL MAP SWITCHING BLOCK
.EDSYM==2	;.JBSYM IN SYMBOL SPACE
.EDUSY==3	;.JBUSY IN SYMBOL SPACE
.EDHSF==4	;POINTER TO SYMBOLS HIDDEN FLAG WORD
.EDDAT==5	;CPU/PAGING/HARDWARE DATA
   ED.KLP==1B0	   ;KL PAGING
   ED.XKL==1B1	   ;EXTENDED KL10
   ED.CPU==0,,-1   ;CPU TYPE CODE (KI10=3, KL10=4, KS10=5, ETC.)
.EDEPT==6	;PHYSICAL ADDRESS OF THE BOOT CPU'S EPT
.EDSPT==7	;PHYSICAL ADDRESS OF THE BOOT CPU'S SPT
.EDCST==10	;PHYSICAL ADDRESS OF THE BOOT CPU'S CST
.EDCPN==11	;PHYSICAL ADDRESS OF CPNDDT
.EDCPU==12	;AOBJN POINTER TO CPU SERIAL NUMBERS
.EDCAC==13	;PHYSICAL ADDRESS OF VIRTUAL ADDRESS OF CRASH ACS
.EDLNK==14	;VIRTUAL RING POINTER TO EDV OF NEXT CPU
.EDLEN==15	;LENGTH OF THE EXEC DATA VECTOR
	SUBTTL	EXTENDED SYMBOL TABLE FORMAT

;BLOCK POINTED TO BY POSITIVE CONTENTS OF .JBSYM

.SYCNT==0	;COUNT (INCLUDES THIS WORD)
.SYSTB==1	;OFFSET TO FIRST SUB-TABLE

;THE COUNT WORD IS FOLLOWED BY A NUMBER OF SUB-TABLES, EACH
;OF LENGTH .SYSTL.  EACH SUB-TABLE IN THE SYMBOL VECTOR HAS
;THE FOLLOWING FORM:

.SYTYP==0	;TYPE AND LENGTH
   SY.TYP==77B5	   ;TYPE
	.SYR5D==1	;RADIX-50 DEFINED
	.SYR5U==2	;RADIX-50 UNDEFINED
   SY.LEN==^-SY.TYP ;LENGTH OF TABLE
.SYADR==1	;ADDRESS OF TABLE
.SYSTL==3	;SUB-TABLE LENGTH

;CURRENTLY THERE ARE 2 BLOCKS (DEFINED AND UNDEFINED SYMBOLS)
;IN THE EXTENDED SYMBOL VECTOR.
	SUBTTL	BITS IN GETTAB TABLE (NUMTAB)

;BITS 0-8 = MAXIMUM SIZE OF TABLE IF REGULAR TABLE
XP	GT.COD,7B11	;TYPE OF GETTAB TABLE
	XP GT.UND,0	;UNDEFINED IN THIS MONITOR
	XP GT.ITM,1	;INDEX BY ITEM TYPE
	XP GT.JOB,2	;INDEX BY JOB NUMBER
	XP GT.SEG,3	;INDEX BY JOB OR SEGMENT
	XP GT.PDB,4	;INDEX BY JOB DATA IS IN PDB
	XP GT.RNG,5	;INDEX BY NEGATIVE AND POSITIVE OFFSETS
	SUBTTL	TELETYPE PARAMETERS

	XP	STTYBF,20	;SIZE OF TTY BUFFER
	XP	STTYB1,STTYBF+1	;LENGTH+1
	SUBTTL	DATA STRUCTURES  --  EXTENSIBLE BITMAP MEMORY


;AN ALLOCATION CONTROL BLOCK IS USED BY CORE ALLOCATION ROUTINES
;IN CORE1 TO MANAGE THE NEEDS OF SPECIFIC CORE ALLOCATION USERS.
;THESE BLOCKS ARE BUILT AT ASSEMBLY TIME AND LINKED TOGETHER BY
;THE .LKACB LINK CHAIN.

	PHASE	0

ACBNXT:! BLOCK	1		;ADDRESS OF NEXT ALLOCATION CONTROL BLOCK

ACBNAM:! BLOCK	1		;SIXBIT NAME OF ALLOCATION USER

ACBCSZ:! BLOCK	1		;ALLOCATION CHUNK SIZE IN WORDS
ACBSEC:! BLOCK	1		;SECTION NUMBER OF ALLOCATION

ACBUSD:! BLOCK	1		;CURRENT USED AMOUNT IN WORDS
ACBHWM:! BLOCK	1		;HIGH WATER MARK USED AMOUNT IN WORDS

ACBINI:! BLOCK	1		;INITIAL ALLOCATION AMOUNT IN WORDS
ACBTHR:! BLOCK	1		;THRESHOLD ALLOCATION AMOUNT IN WORDS
ACBINC:! BLOCK	1		;INCREMENTAL ALLOCATION AMOUNT IN WORDS
ACBMIN:! BLOCK	1		;MINIMUM ALLOCATION AMOUNT IN WORDS
ACBMAX:! BLOCK	1		;MAXIMUM ALLOCATION AMOUNT IN WORDS

ACBAHB:! BLOCK	1		;ADDRESS OF ALLOCATION HEADER BLOCK

ACBLEN:!			;LENGTH OF ALLOCATION CONTROL BLOCK

	DEPHASE
;AN ALLOCATION HEADER BLOCK IS USED BY THE CORE ALLOCATION ROUTINES
;TO MANAGE INDIVIDUAL POOLS OF BITMAP MEMORY WITH A SPECIFIC CHUNK
;SIZE.

	PHASE	0

AHBNXT:! BLOCK	1		;ADDRESS OF NEXT ALLOCATION HEADER BLOCK

AHBCSZ:! BLOCK	1		;ALLOCATION CHUNK SIZE IN WORDS
AHBSEC:! BLOCK	1		;SECTION NUMBER OF ALLOCATION

AHBFRE:! BLOCK	1		;CURRENT FREE AMOUNT IN WORDS
AHBLWM:! BLOCK	1		;LOW WATER MARK AMOUNT IN WORDS

AHBINI:! BLOCK	1		;INITIAL ALLOCATION AMOUNT IN WORDS
AHBTHR:! BLOCK	1		;THRESHOLD ALLOCATION AMOUNT IN WORDS
AHBINC:! BLOCK	1		;INCREMENTAL ALLOCATION AMOUNT IN WORDS
AHBMIN:! BLOCK	1		;MINIMUM ALLOCATION AMOUNT IN WORDS
AHBMAX:! BLOCK	1		;MAXIMUM ALLOCATION AMOUNT IN WORDS

AHBCUR:! BLOCK	1		;CURRENT ALLOCATION AMOUNT IN WORDS
AHBPND:! BLOCK	1		;PENDING ALLOCATION AMOUNT IN WORDS

AHBAEB:! BLOCK	1		;ADDRESS OF FIRST ALLOCATION EXTENT BLOCK

AHBLEN:!			;LENGTH OF ALLOCATION HEADER BLOCK

	DEPHASE
;AN ALLOCATION EXTENT BLOCK IS USED BY CORE ALLOCATION ROUTINES
;TO KEEP TRACK OF INDIVIDUAL ALLOCATION EXTENTS.  THESE BLOCKS
;MAY BE DYNAMICALLY CREATED/DESTROYED AS ALLOCATION NEEDS CHANGE.

	PHASE	0

AEBNXT:! BLOCK	1		;ADDRESS OF NEXT ALLOCATION EXTENT BLOCK

AEBFRE:! BLOCK	1		;CURRENT FREE AMOUNT IN WORDS
AEBLWM:! BLOCK	1		;LOW WATER MARK AMOUNT IN WORDS

AEBSIZ:! BLOCK	1		;EXTENT SIZE IN WORDS
AEBADR:! BLOCK	1		;EXTENT ADDRESS
AEBBMP:! BLOCK	1		;AOBJN POINTER TO EXTENT BIT MAP

AEBLEN:!			;LENGTH OF ALLOCATION SERVICE BLOCK

	DEPHASE
	SUBTTL FEK FRONT END KONTROLLER DATA BLOCKS

;MACRO FOR DEFINING THE FIELDS OF THE VARIOUS NETWORK DATA BLOCKS

DEFINE	X(NAME,SIZE)<			;;DEFINE A MACRO TO MAKE THINGS EASY
  IFNB <NAME>,<NAME==:%%%OFF>		;;DEFINE THE SYMBOL
  IFNB <SIZE>,<%%%OFF==%%%OFF+SIZE>	;;INCREMENT THE SIZE
  IFB  <SIZE>,<%%%OFF==%%%OFF+1>	;;  BY ONE IF "SIZE" NOT SPECIFIED
>

;FEK BLOCK OFFSETS

	%%%OFF==0		;INITIALIZE FOR X MACRO

	X	FEKBLK		;XWD FLAGS,LINK TO NEXT FEK
	X	FEKDSP		;"JRST DSP(T1)" DSP == FEK'S DISPATCH VECTOR.
	X	FEKNNM,0	;(RH) NODE NUMBER ON OTHER SIDE OF FEK (IF UP)
	X	FEKCST		;(LH) COST FROM -10 TO PORT
	X	FEKHTM		;HUNG TIMER
	X	FEKUNI		;XWD CPU,"FEK SPECIFIC UNIT ID"

	X	FEKIAD		;HEAD OF LIST OF PCBS FOR FEK TO FILL
	X	FEKIDN		;INPUT-DONE FEK ADDRESS (FI.IDN ONLY)
	X	FEKBSI		;FLAG FOR THE FEK TO INTERLOCK ITSELF

	X	FEKOAD		;HEAD OF LIST OF OUTPUT PCBS
	X	FEKOCT		;LENGTH OF "FEKOAD"
	X	FEKODN		;"SENT" PCBS GO HERE FOR NETSER
	X	FEKBSO		;INTERLOCK FOR FEK TO USE
	X	FEKBJN		;XWD TIMER,BOOT-JOB-NUMBER (FOR STC)
	X	FEKICT		;XWD TIMER,STC-MSG (FOR INCOMING STC)

IFN FTKL10,<			;TWO DTE-20 SPECIFIC LOCATIONS
	X	FEKAKC		;COUNT OF QPR-ACK'S TO SEND
	X	FEKIBP		;"INPUT" BYTE POINTER FOR DTE-20 FEK'S
	X	FEKDLX		;BACK-POINTER TO BASE TABLE
	X	FEKETD		;BACK-POINTER TO ETD (DTE-20 FEK'S)
>

IFN	FTENET,<		;SOME ETHERNET-SPECIFIC STUFF
	X	FEKNIA,2	;REMOTE ETHERNET ADDRESS
	X	FEKNIC		;ETHERNET "CHANNEL" ID
	X	FEKNID		;ETHERNET "PORTAL" ID
	X	FEKNIF		;ETHERNET MASTER FEK ADDRESS
	X	FEKNIQ		;ETHERNET INPUT PCBS QUEUED
	X	FEKNIS		;ETHERNET BROADCAST NODEID SERIAL NUMBER
	X	FEKNIT		;ETHERNET TIMER VALUES
>

	X	FEKLEN,0	;LENGTH OF A FEK
;BITS IN LEFT HALF OF FEKBLK

	XP	FK.ONL,(1B0)	;ONLINE SAME AS NOT DOWN
				;MUST BE THE SIGN BIT
	XP	FK.NID,(1B1)	;NODE ID HAS BEEN SENT
	XP	FK.STI,(1B2)	;THIS FEK WANTS INPUT STARTED NEXT TICK
	XP	FK.STO,(1B3)	;THIS FEK WANTS OUTPUT STARTED NEXT TICK
	XP	FK.NUL,(1B4)	;THIS IS A NULL (LOCAL LOOP BACK) FEK
	XP	FK.IAC,(1B5)	;INPUT ACTIVE (USED BY D85INT)
	XP	FK.OAC,(1B6)	;OUTPUT ACTIVE (")
	XP	FK.CPD,(1B7)	;CPU WENT DOWN. (CLEAN UP IN 1/SEC CODE)
	XP	FK.MAI,(1B8)	;THIS FEK IS IN DDCMP MAINT MODE
	XP	FK.ETH,(1B9)	;THIS FEK IS AN ETHERNET FEK
	XP	FK.ETM,(1B10)	;THIS FEK IS A MASTER ETHERNET FEK
	XP	FK.LUB,FK.ETM	;LOWEST USED BIT.

;OFFSETS INTO EACH FEK'S DISPATCH VECTOR. (NETSER CALLING THE FEK)

	XP	FF.ONC,0	;ONCE-ONLY CODE
	XP	FF.SEC,1	;ONCE/SECOND CODE
	XP	FF.RDD,2	;ENTRY TO POST A READ REQUEST
	XP	FF.WRT,3	;ENTRY TO POST A WRITE REQUEST
	XP	FF.CRS,4	;ENTRY TO REQUEST A FEK TO CRASH
	XP	FF.DWN,5	;ENTRY CALLED WHEN FE DIES
	XP	FF.UP,6		;ENTRY CALLED WHEN FE COMES UP
	XP	FF.STC,7	;ENTRY CALLED WITH "U" := STC TO SEND
	XP	FF.CPS,10	;ENTRY CALLED WHEN CPU IS GOING TO SLEEP
	XP	FF.CPW,11	;ENTRY CALLED WHEN CUP WAKES UP
	XP	FF.CFK,12	;ENTRY TO CREATE A NEW (SLAVE) FEK
	XP	FF.DFK,13	;ENTRY TO DESTROY AN OLD (SLAVE) FEK

;OFFSETS INTO FEKINT (FEKS CALLING NETSER)

	XP	FI.RDD,0	;READ DONE. PCB AT FEKIAD HAS BEEN FILLED
	XP	FI.ODN,1	;OUTPUT DONE, PCB AT FEKODN HAS BEEN SENT
	XP	FI.STC,2	;INCOMING STATION CONTROL MSG (STC IN "U")
	XP	FI.DWN,3	;THIS FEK JUST CRASHED
	XP	FI.IDN,4	;INPUT DONE (PCB ADDRESS IN FEKIDN)
	SUBTTL	DEFINITIONS FOR SYNC LINE TYPES (INCLUDING DTE)

;THESE SYMBOLS ARE USED IN COMNET.MAC TO SET UP THE LINE'S "USER"
;TABLES FOR ANY NETWORK LINE.

	XP	DD.NOB,0	;NOBODY (DEFAULT)
	XP	DD.ANF,1	;ANF-10
	XP	DD.DEC,2	;DECNET-10
	XP	DD.PRO,3	;PROGRAM MODE (FOR KDP: OR DTE:)
	XP	DD.IBM,4	;IBM COMM
		DD.MAX==DD.IBM	;MAX USER TYPE
	SUBTTL	DEFINITIONS FOR DC44, DC75, DC76, DAS78, DN60 AND DAS85
;MACRO .DLTYP GENERATES SYMBOL TP.DL'PORT FOR PORT PORT
;WHERE TP.DL'PORT REPRESENTS THE SYSTEM FOR WHICH THE PORT
;WAS MONGENED. IN ADDITION IT GENERATES WARNINGS TO NOTIFY
;FOR INADVERTENTLY CREATED CONFLICTS. MOREOVER XXICHN IS REDEFINED
;IF NON DAS78/DN60 PORTS ARE PRESENT TO EQUAL SCNCHN

DEFINE	.DLTYP(PORT,ZZZ,CH),<
	IFNDEF	M0'PORT'D85,<M0'PORT'D85==0>	;;DC75 FOR THIS PORT
	IFNDEF	M0'PORT'D78,<M0'PORT'D60==0>	;;DAS78 FOR THIS PORT
	IFNDEF	M0'PORT'D60,<M0'PORT'D60==0>	;;DN60 FOR THIS PORT
	IFNDEF	TYPNU'PORT,<TYPNU'PORT==0>	;;DC44 FOR THIS PORT
	IFNDEF	M.D7'PORT'N,<M.D7'PORT'N==0>	;;DC76 FOR THIS PORT
ZZZ=TYPNU'PORT+M.D7'PORT'N+M0'PORT'D85+M0'PORT'D78 ;;DC44 DC76 DC75 & DAS78
IFN CH,< IFN	ZZZ,<XXICHN==SCNCHN>>	;;GET OPTIONS ON THE SAME CHANNEL
TP.DL'PORT==0			;;ASSUME NO USE FOR THIS PORT
ZZZ==0
IFN TYPNU'PORT,<ZZZ==ZZZ+1>
IFE TYPNU'PORT,<IFN M.D7'PORT'N,<ZZZ==ZZZ+1>>
IFN M0'PORT'D85,<ZZZ==ZZZ+1>
IFN M0'PORT'D78,<ZZZ==ZZZ+1>
IFN M0'PORT'D60,<ZZZ==ZZZ+1>
IFG ZZZ,<
ZZZ=ZZZ-1
IFG ZZZ,<
	IF1,	<
	PRINTX	WARNING: DL10 PDP-11 NUMBER PORT HAS MORE THAN ONE OPTION
	PRINTX	FROM THE SET: DC44, DC76, DAS85 (OR DC75), DAS78, AND DN60.
	> ;;END OF IF1
> ;END OF IFG ZZZ
IFN M0'PORT'D85,<
	TP.DL'PORT==TP.D85
	DLX.75==DLX.75+1
> ;;END IFN M0'PORT'D85
IFE TP.DL'PORT,<
	IFN	TYPNU'PORT,<TP.DL'PORT==TP.DL'PORT+TP.D44
	DLX.44=DLX.44+1>
	IFN	M.D7'PORT'N,<TP.DL'PORT==TP.DL'PORT+TP.D76
DLX.76=DLX.76+1>
> ;END OF IFE TP.DL'PORT
IFE TP.DL'PORT,<
IFN M.KL10,<
		IFN M0'PORT'D78,<
			TP.DL'PORT=TP.D78
			DLX.78==DLX.78+1
		> ;;END IFN M0'PORT'D78
	> ;; END IFN M.KL10
> ;;END IFE TP.DL'PORT
IFE TP.DL'PORT,<
IFN M.DN60,<
		IFN	M0'PORT'D60,<
			TP.DL'PORT==TP.D60
			DLX.60==DLX.60+1
		> ;;END OF IFN M.'PORT'D60
	> ;;END IFN M.DN60
> ;END OF IFE TP.DL'PORT
IFN TP.DL'PORT,<PDP11N==PDP11N+1>
> ;END OF IFG ZZZ
>	;END OF .DLTYP
;MACRO DLX.CK WHEN CALLED WILL GENERATE THE FOLLOWING SET OF SYMBOLS
;DLX.44 = NUMBER OF 44 OPTIONS ON DL10
;DLX.60 = NUMBER OF DN60 OPTIONS ON DL10
;DLX.75 = NUMBER OF 75 OPTIONS ON DL10
;DLX.76 = NUMBER OF 76 OPTIONS ON DL10
;DLX.78 = NUMBER OF 78 OPTIONS ON DL10
;MOREOVER A CONSISTENCY CHECK OF THE PORT USAGE WILL BE DONE
;FOR EACH PORT A SYMBOL "P.DL'PORT WILL BE GENERATED ITS
;VALUE DEFINES THE OPTION ON THIS PORT.

	DEFINE	DLX.CK(CH),<

	XLIST

DLX.44=0		;;ASSUME NOTHING THERE
DLX.60=0
DLX.75=0
DLX.76=0
DLX.78=0
PDP11N=0
ZZ=0
	REPEAT	10,<
	.DLTYP(\ZZ,ZZZ,CH)
ZZ=ZZ+1
>
DL10XI==PDP11N		;;DL10XI IS NUMBER OF PDP11'S ON DL10'S
	LIST
	XP	DLX.44,DLX.44	;;SO VALUE IS LISTED
	XP	DLX.60,DLX.60	;;VALUES DEFINED BY .DLTYP
	XP	DLX.75,DLX.75	;;AND SHOWS UP IN GLOBS
	XP	DLX.76,DLX.76
	XP	DLX.78,DLX.78
>	;END OF DLX.CK
DEFINE	MAP76(CPU,PORT),<

;;THIS MACRO IS USED IS SEVERAL PLACES. THEY ARE:
;;
;;	1. COMMON.MAC CALLS IT TO BUILD THE REAL DL10 MEMORY
;;	    MAP.
;;
;;	2. TEST76 CALLS IT TO BUILD A DL10 MAP TO RUN THE DC76
;;	    WITHOUT THE HELP OF THE MONITOR.
;;
;;	3. IT IS CALLED BY THE PDP-11 CODE TO BUILD THE MATCHING
;;	    SYMBOL DEFINITIONS.
;;
;;	4. IT IS CALLED BY D76INT TO BUILD SYMBOL DEFS.
;;
;;MAP76 HAS 1 ARGUMENT WHICH IS THE DL10 PORT NUMBER IT WILL BE
;; USED WITH. THIS IS USED IS BUILDING SOME OF THE SYMBOLS
;;
;;
;;THIS MACRO CONTAINS ONLY MACRO CALLS. THE MACROS IT
;; CALLS ARE:
;;
;;	WORD	SYM,	;;DEFINE SYM AS A 1 WORD QUANTITY. SYM
;;			;; SHOULD BE NO MORE THAN 3 LETTERS. THE
;;			;; WORD IS SET TO ZERO IN THE MAP.
;;
;;	DATA	SYM,THING
;;			;;SAME AS WORD EXECPT THING IS PLACED IN
;;			;; THE WORD.
;;
;;	PNTR	SYM,PLACE
;;			;;SAME AS WORD EXCEPT A 16 BIT READ ONLY
;;			;; INDIRECT POINTER IS PLACED IN THE MAP. THE
;;			;; POINTER POINTS TO PLACE.
;;
;;	BLK	SYM,SIZE
;;			;;SAME AS WORD EXCEPT IT LEAVES SIZE WORD
;;
	..P==PORT	;;USED SO MACRO DOES NOT PRODUCE AN 'A' ERROR
			;; ON IFNDEF THING

	DATA	KII,<XPCW D70'PORT'KI>;;EXETNDED KL10 VECTORS HERE

					;; INTERUPT SYSTEM EXECUTES
					;; THIS INSTRUCTION.
	WORD	ESA,	;;ELEVEN STARTING ADDRESS. USED TO FORCE
			;; THE ELEVEN TO START AT A GIVEN PLACE.

	WORD	WNU,	;;WORD NOT USED


	WORD	NAM,	;;6-BIT DL10 BYTE POINTER TO NAME OF PROGRAM
			;; IN THE ELEVEN. TELL DC75 FROM DC76.
	DATA	EPN,<..P>;;ELEVEN PORT NUMBER. THIS IS USED BY THE
			;; 10 TO MAKE CONI/CONO INSTRUCTIONS FOR
			;; THE DL10. IT IS USED TO HELP DEBUG THE -11
	WORD	OK,	;;FLAG SET TO ZERO BY THE DC76 AND COUNTED
			;; UP ONCE A SECOND BY THE -10. IF THE FLAG
			;; IS .GE. 2 THE DC76 IS DEAD.

	WORD	HLT,	;;WHEN THE DC76 HALTS IT PLACES THE HALT
			;; ADDRESS HERE.

	WORD	DWN,	;;A FLAG WHICH INDICATES THE UPNESS OF THE -11
			;; -1 DOWN , NO MESSAGES
			;; 0  DOWN , COMPLAIN ONCE A MIN
			;; +1 UP

	PNTR	UPT,.C0UPT,	;;NUMBER IN THE TEN WHICH COUNTS UP
				;; ONCE A JIFFY.
	IFDEF	M'CPU'PORT'D85,<
	IFE	M'CPU'PORT'D85+M'CPU'PORT'D60,<  ;;NOT AN 85 OR DN60
	WORD	TTP,	;;POINTER TO LAST ITEM PLACED IN THE TO -10
			;; QUEUE.

	WORD	TTG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -10
			;; QUEUE

	WORD	TEP,	;;POINTER TO LAST ITEM PLACED IN THE TO -11
			;; QUEUE

	WORD	TEG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -11
			;; QUEUE

	DATA	EBS,<TEBS'PORT'> ;;SIZE OF TO ELEVEN QUEUE

	DATA	TBS,<TTBS'PORT'> ;;SIZE OF TO TEN QUEUE

	DATA	LTO,<D7'PORT'OFS> ;;THE NUMBER ONE ADDS TO DC76 LINE
			;; ZERO TO GET A LINTAB INDEX

	DATA	DTO,<D7'PORT'DSO> ;;OFFSET TO DSCTAB
	PNTR	STS,STATES,	;;WORD WHICH HAS THE BIT WHICH SAYS
				;; IF WE SHOULD ANSWER DATASETS

	PNTR	FRN,TTFREN,	;;NUMBER OF FREE TTY CHUNKS. USED
				;; TO ALLOW THE DC76 TO COOL IT
				;; INSTEAD OF GETTING A DING.

	DATA	AOM,<M7'PORT'KII>;;ADDRESS OF THE FIRST WORD OF THE
				;; MAP. USED SO THAT THE -11 CAN UNDERSTAND
				;; TTA AND TEA.

	DATA	TEA,<M7'PORT'TEQ>;;ADDRESS OF THE TO -11 QUEUE
				;; USED ONLY BY D76INT

	DATA	TTA,<M7'PORT'TTQ>;;ADDRESS OF THE TO -10 QUEUE

	DATA	MAX,<M.D7'PORT'N+TYPNU'PORT> ;;TOTAL NUMBEER OF FRONT END LINES
	DATA	NTT,<M.D7'PORT'N> ;;NUMBER OF LINES ON THIS DC76
	DATA	PIO,<M7'PORT'NIP>	;;AREA OF NON IMMEDIATE BYTE POINTERS
;;ALL BLK MACROS SHOULD COME AT THE END OF THE MAP SO THAT OFFSETS
;; CAN BE COMPUTED WITHOUT KNOWING ANY MONGEN SYMBOLS.

	BLK	TTQ,<TTBS'PORT>,;;THE TO TEN QUEUE

	BLK	TEQ,<TEBS'PORT>,;;THE TO ELEVEN QUEUE

	BLK	NIP,<TYPNU'PORT>	;;POOL OF NONIMMEDIATE BYTE POINTERS
>	;;END OF IFE M'CPU'PORT'D85+M'CPU'PORT'D60
	IFN	M'CPU'PORT'D85+M'CPU'PORT'D60,<  ;;I.E., 85 OR DN60 MAP
	WORD	SWD,	;GLOBAL STATUS WORD
			;1=DEPOSIT
			;2=EXAMINE
			;4=ADDRESS IS GARBAGE
			;10=HOLD EVERYTHING
	WORD	ADR,	;EXAMINE/DEPOSIT ADDRESS
	WORD	DAT,	;EXAMINE/DEPOSIT DATA
	WORD	REC,	;MAXIMUM RECORD LENGTH
	WORD	MOD,	;VERSION OF SOFTWARE
	WORD	TA,	;10 ALIVE IF .LE. 1 (11 INCREMENTS, 10 SETS TO -1)
	WORD	TS,	;10 STATUS (0=INITIAL,1=STARTED INIT,-1=RUNNING)
	WORD	ES,	;11 STATUS (0=INITIAL,1=STARTED INIT,-1=RUNNING)
IFN M'CPU'PORT'D60,< ;;THIS IS A DN60 PORT
	XP	D60WVR,3	;DN60 WINDOW VERSON
	WORD	MXL,	;MAX LINES ON THIS CPU
	WORD	LT1,	;FIRST LIGHTS WORD
	WORD	LT2,	;SECOND LIGHTS WORD
	WORD	OPE,	;11-OPERATION:
			; 0 = IDLE
			; 1 = REQUEST TO READ DATA
			; 2 = REQUEST TO WRITE DATA
			; 3 = REQUEST TO READ DEVICE STATUS
			; 4 = REQUEST TO WRITE DEVICE STATUS
			; 5 = REQUEST TO READ LINE STATUS
			; 6 = REQUEST TO WRITE LINE STATUS
	WORD	LNE,	;LINE NUMBER OF ABOVE OPERATION
	WORD	DVE,	;DEVICE NUMBER OF ABOVE OPERATION
	WORD	OPX,	;10-OPERATION CODE
			; 0 = IDLE
			; 1 = READ DATA INTO 10
			; 2 = WRITE DATA FROM 10
			; 3 = READ DEVICE STATUS
			; 4 = WRITE DEVICE STATUS
			; 5 = READ LINE STATUS
			; 6 = WRITE LINE STATUS
	WORD	LNX,	;LINE NUMBER OF ABOVE OPERATION
	WORD	DVX,	;DEVICE NUMBER OF ABOVE OPERATION (1-4)
	WORD	RST,	;RESULT CODE
	WORD	XFR,	;NUMBER OF BYTES TRANSFERRED
	BLK	CBP,40,	;COUNTS AND BYTE POINTERS (16 OF EACH)
> ;IFN M'CPU'PORT'D60
IFE M'CPU'PORT'D60,<  ;;THIS IS A DN85 PORT
	WORD	IFL,	;INPUT FLAGS
	WORD	IC1,	;INPUT COUNT (PART 1)
	WORD	ID1,	;INPTA POINTER (PART 1)
	WORD	IC2,	;INPUT COUNT
	WORD	ID2,	;INPUT DATA BYTE POINTER
	WORD	OFL,	;OUTPUT FLAGS
			;1=HEADER THERE
			;2=FIRST HALF THERE
			;4=SECOND HALF THERE
	WORD	OC1,	;OUTPUT HEADER COUNT
	WORD	OD1,	;OUTPUT HEADER POINTER
	WORD	OC2,	;OUTPUT DATA COUNT
	WORD	OD2,	;OUTPUT DATA POINTER
	WORD	OC3,	;OUTPUT DATA COUNT (PART 2)
	WORD	OD3,	;OUTPUT DATA POINTER (PART 2)
>	;IFE M'CPU'PORT'D60
>	;IFN	M'CPU'PORT'D85+M'CPU'PORT'D60
>	;;END OF IFDEF M'CPU'PORT'D85
	IFNDEF	M'CPU'PORT'D85,<
	WORD	TTP,	;;POINTER TO LAST ITEM PLACED IN THE TO -10
			;; QUEUE.

	WORD	TTG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -10
			;; QUEUE

	WORD	TEP,	;;POINTER TO LAST ITEM PLACED IN THE TO -11
			;; QUEUE

	WORD	TEG,	;;POINTER TO LAST ITEM TAKEN FROM THE TO -11
			;; QUEUE

	DATA	EBS,<TEBS'PORT'> ;;SIZE OF TO ELEVEN QUEUE

	DATA	TBS,<TTBS'PORT'> ;;SIZE OF TO TEN QUEUE

	DATA	LTO,<D7'PORT'OFS> ;;THE NUMBER ONE ADDS TO DC76 LINE
			;; ZERO TO GET A LINTAB INDEX
	DATA	DTO,<D7'PORT'DSO> ;;OFFSET TO DSCTAB
	PNTR	STS,STATES,	;;WORD WHICH HAS THE BIT WHICH SAYS
				;; IF WE SHOULD ANSWER DATASETS

	PNTR	FRN,TTFREN,	;;NUMBER OF FREE TTY CHUNKS. USED
				;; TO ALLOW THE DC76 TO COOL IT
				;; INSTEAD OF GETTING A DING.

	DATA	AOM,<M7'PORT'KII>;;ADDRESS OF THE FIRST WORD OF THE
				;; MAP. USED SO THAT THE -11 CAN UNDERSTAND
				;; TTA AND TEA.

	DATA	TEA,<M7'PORT'TEQ>;;ADDRESS OF THE TO -11 QUEUE
				;; USED ONLY BY D76INT

	DATA	TTA,<M7'PORT'TTQ>;;ADDRESS OF THE TO -10 QUEUE

	DATA	MAX,<M.D7'PORT'N+TYPNU'PORT> ;;TOTAL NUMBEER OF FRONT END LINES
	DATA	NTT,<M.D7'PORT'N> ;;NUMBER OF LINES ON THIS DC76

	IFNB	<PORT>,<ZZZZ==PAR'PORT'N>
	IFB	<PORT>,<ZZZZ==0>
	DATA	PAR,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PA611R READERS
	IFNB	<PORT>,<ZZZZ==ZZZZ+PCR'PORT'N>

	DATA	PCR,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PC-11 READERS
	IFNB	<PORT>,<ZZZZ==ZZZZ+PAP'PORT'N>
	DATA	PAP,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PA611P PUNCHES
	IFNB	<PORT>,<ZZZZ==ZZZZ+LPC'PORT'N>
	DATA	LPC,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF LPC 11 DEVICES
	IFNB	<PORT>,<ZZZZ==ZZZZ+PCP'PORT'N>
	DATA	PCP,<ZZZZ>	;;LAST COMTEX LINE NUMBER+1 OF PC-11 PUNCHES
	DATA	PIO,<M7'PORT'NIP>	;;AREA OF NON IMMEDIATE BYTE POINTERS
;;ALL BLK MACROS SHOULD COME AT THE END OF THE MAP SO THAT OFFSETS
;; CAN BE COMPUTED WITHOUT KNOWING ANY MONGEN SYMBOLS.

	BLK	TTQ,<TTBS'PORT>,;;THE TO TEN QUEUE

	BLK	TEQ,<TEBS'PORT>,;;THE TO ELEVEN QUEUE

	BLK	NIP,<TYPNU'PORT>	;;POOL OF NONIMMEDIATE BYTE POINTERS
>	;;END OF IFNDEF M'CPU'PORT'D85
>;;END OF THE MAP76 MACRO
;MACRO DLMAP WILL GENERATE VALUES FOR THE MNEMONICS USED
; TO ADDRESS THE DL10 MAP
;WE NOW WANT TO EXPAND MAP76 TO DEFINE OFFSETS IN THE MAPPED AREA.
;OFFSETS ARE DEFINED ONLY FOR "DATA" OR "WORD" SYMBOLS. THIS IS DONE
; SO THAT ONE CAN NOT REFERENCE A DL10 INDIRECT POINTER OR A MONGEN
; DEPENDANT VARIABLE IN THIS MODULE.
	DEFINE	DLMAP
<	XLIST

DEFINE	WORD(SYMBOL)<SYMBOL==.I	;;DEFINE OFFSET
			.I==.I+1>

DEFINE	DATA(SYMBOL,DATUM)<SYMBOL==.I
			.I==.I+1>

DEFINE	PNTR(SYMBOL,WORD),<.I==.I+1>

DEFINE	BLK(SYMBOL,SIZE),<IFDEF SIZE,<.I==.I+SIZE>
			  IFNDEF SIZE,<PURGE .I>>

	.I==0
	MAP76		;DEFINE PARAMETERS
	LIST
>


;LINE PARAMETER CONTROL MESSAGES FOR THE DC76
XP	LPCSPD,2	;SET LINE SPEED (RECEIVE*10+TRANSMIT)
XP	LPCABR,4	;ENABLE AUTO BAUD RATE DETECT
XP	LPCELE,6	;SET TYPE ELEMENT
XP	LPCAPL,10	;SET/CLEAR APL MODE
XP	LPCRVB,12	;SET/CLEAR REVERSE BREAK
XP	LPCUKB,14	;UNLOCK KEYBOARD
XP	LPCTDY,16	;SET/CLEAR TIDY BIT

;TYPES OF DL-10 FRONT ENDS
XP	TP.D76,1	;FRONT END IS A DC76
XP	TP.D44,2	;FRONT END IS A DC44
XP	TP.D47,3	;FRONT END COMBINES DC44 AND DC76
XP	TP.D75,4	;OLD DECSYNC PROTOCOL
XP	TP.D60,5	;DN60 FRONT END
XP	TP.D85,6	;NEW DDCMP FRONT END
XP	TP.D78,7	;FRONT END IS A DAS78

;TYPES OF DTE-20 FRONT ENDS
XP	DT.RSX,1	;RSX20F
XP	DT.ANF,2	;ANF10
XP	DT.IBM,3	;IBM (DN60)
XP	DT.DNT,4	;DECNET

;TYPES OF KMC/DUP FRONT ENDS
XP	KD.ANF,1	;ANF10
XP	KD.DNT,2	;DECNET
XP	KD.USR,3	;USER
XP	KD.IBM,4	;IBM (DN60)

;TYPES OF DMR FRONT ENDS
XP	RD.ANF,1	;ANF10
XP	RD.DNT,2	;DECNET
XP	RD.USR,3	;USER
XP	RD.IBM,4	;IBM (DN60)


;DN60 CALL11 ENTRY VECTOR OFFSETS (FOR COMMUNICATION BETWEEN D60SER AND
;D6?INT MODULES
XP	D6F.UD,0	;SEE IF PDP11 IS UP OR DOWN
XP	D6F.QU,1	;THE CALL11 QUEUE DATA FUNCTION
XP	D6F.ED,2	;THE CALL11 EXAMINE/DEPOSIT FUNCTION
;THIS MACRO DEFINES THE INTERPROCESSER
;WINDOW USED BETWEEN THE PDP10 AND THE PDP11.
;
DEFINE MAP78	(CPU,PORT),<

	Q78SYM	<.DL'PORT'BS>;			;;FOR WINDOW MAP TABLE
	Q78SYM	<M8'PORT'KII>;			;BEGINNING WINDOW ADDRESS

	PHASE	0

IFN FTKL10,<
	Q78DAT	M78KII,<XPCW D80'PORT'KI>	;KL PAGING STYLE INTERUUPT

>;END IFN FTKL10
	Q78WRD	<M78ESA>,			;
	Q78WRD	<M78WNU>,			;
	Q78WRD	<M78NAM>,			;PROGRAM NAME (DAS78 IN SIXBIT)
	Q78WRD	<M78EPN>,			;
	Q78WRD	<M78OK>,			;PDP11 ALIVE INDICATOR.  INCREMENTED
						; BY 10 ONCE A SECOND. SET 0 BY 11.
						;  IF .LT. 2, 11 IS ALIVE
	Q78WRD	<M78HLT>,			;11 TO 10 STOP CODE
	Q78WRD	<M78DWN>,			;1=UP, 0=DOWN & TELL OPR, -1=DOWN
						; AND QUITE
	Q78WRD	<M78UPT>,			;
	Q78WRD	<M78GLB>,			;GLOBAL STATUS WORD
	Q78WRD	<M78MOD>,			;MODIFICATION NUMBER
	Q78WRD	<M78XXI>,			;10 TO 11 ACTIVTY INDICATOR
	Q78WRD	<M78XIX>,			;11 TO 10 ACTIVITY INDICATOR
	Q78WRD	<M78ALI>,			;PDP10 ALIVE INDICATOR.  INCREMENTED
						; BY 11 ONCE A SECOND.  SET -1 BY 10.
						;  IF .LE.1, 10 IS ALIVE.
	Q78WRD	<M7810S>,			;STATUS OF 10.	0 INITIALLY
						;1 STARTED INITIALIZATION
						;-1 RUNNING
	Q78WRD	<M7811S>,			;STATUS OF 11.	0 INITIALLY
						;1 STARTED INITIALIZATION
						;-1 RUNNING
	Q78WRD	<M78ADR>,			;ADDRESS FOR LOAD/STORE IN 11 CORE
	Q78WRD	<M78DTA>,			;CONTENTS OF CONTENTS OF M78ADR.
	Q78DAT	M78NLI,<M'CPU'PORT'D78>		;NUMBER OF LINES ON THIS PORT

	Q78SYM	<M78WIN>;			;BEGINNING OF WINDOW FOR EACH LINE
	DEPHASE
;THIS IS THE BEGINNING OF THE WINDOW SLOTS AND
;THERE IS ONE FOR EACH LINE
;
REPEAT	<M'CPU'PORT'D78>,<
	Q78SYM	<WS8L>,\<ZZD78L>;		;BEGINNING OF WINDOW SLOT
	PHASE	0
	Q78SYM	<SUBW78>;	;FIRST ADDR IN SUB WINDOW
	Q78WRD	<WS8LS0>,	;GENERAL LINE STATUS (OWNED BY 10 FOR CALL78 UUO)
	Q78WRD	<WS8LS1>,	;2ND LINE STATUS WORD
	Q78WRD	<WS8MSZ>,	;MESSAGE SIZE
	Q78WRD	<WS8RSZ>,	;RECORD SIZE
	WS8SET==:<.-SUBW78>	;NUMBER OF WORDS WE ALLOW
				; THE CALL78 TO SET
	Q78WRD	<WS810S>,	;STATUS OWNED BY THE PDP10
	Q78WRD	<WS811S>,	;STATUS OWNED BY THE PDP11
	Q78WRD	<WS8ICC>,	;INPUT TO 10 CHARACTER COUNT
	Q78WRD	<WS8IBP>,	;INPUT TO 10 BYTE POINTER
	Q78WRD	<WS8OCC>,	;OUTPUT FROM 10 CHARACTER COUNT
	Q78WRD	<WS8OBP>,	;OUTPUT FROM 10 BYTE POINTER
	M78SIZ==:<.-SUBW78>	;WINDOW SLOT SIZE
	Q78INC	<ZZD78L>,<1>;	;NEXT LINE NUMBER
	DEPHASE

>	;END REPEAT
>;END MAP78
	SUBTTL	CAL11. UUO DEFINITIONS


.C11FC==0	;FUNCTION WORD
;	C1.1NO==777B17  ;(OLD FORMAT) WHICH -11
;	C1.1NT==77B14	;(OLD FORMAT) TYPE
;	C1.1NN==7B17	;(OLD FORMAT) NUMBER

	C1.1NF==1B0	;NEW FORMAT ARGUMENTS
	C1.1XX==377B8	;RESERVED FOR DEC
	C1.1TY==7B11	;TYPE
		.C11DL==0	;DL-10
		.C11DT==1	;DTE-20
		.C11KD==2	;KMC/DUP
		.C11DR==3	;DMR
	C1.1CN==7B14	;CPU NUMBER
	C1.1PN==7B17	;PORT NUMBER
	C1.1FC==777777	;WHICH FUNCTION
		.C11DP==0	;DEPOSIT FUNCTION
		.C11EX==1	;EXAMINE FUNCTION
		.C11QU==2	;QUEUE A REQUEST
		.C11NM==3	;RETURN NAME OF FRONT END PROG
		.C11UP==4	;RETURN 0 IF DOWN, 1 IF UP
		.C11SM==5	;SEND MESSAGE
		.C11RM==6	;RECEIVE MESSAGE
		.C11TY==7	;RETURN TYPE/NODE NUMBER
			.C1D76==1	;DC76
			.C1D75==2	;DC75/DN87
			.C1D60==3	;DN60
			.C1D8S==4	;DN87S
			.C1CFE==5	;CONSOLE FRONT END
			.C1MCB==6	;DECNET MCB
			.C1D22==7	;DN22 ON A KMC/DUP
.C11AD==1	;ADDRESS OF EXAMINE/DEPOSIT
.C11CN==2	;CONTENTS TO DEPOSIT
.C11EN==1	;START OF QUEUE ENTRY


;CAL11.	ERROR CODES
C11NP%==1	;NOT PRIVILEGED
C11UF%==2	;UNKNOWN FUNCTION
C11ND%==3	;NOT DC76
C11IU%==4	;EXAM/DEP IN USE
C11NA%==5	;NO ANSWER TO EXAM/DEP
C11TS%==6	;QUEUE ENTRY TOO SHORT
C11NE%==7	;NOT ENOUGH ARGS
C11IA%==10	;INVALID EXAMINE/DEPOSIT ADDRESS
C11IQ%==11	;INVALID QUEUE FUNCTION ARGUMENT
C11IC%==12	;INSUFFICIENT CORE
C11RP%==13	;DTE RELOAD BIT SET OR PRIMARY PROTOCOL NOT RUNNING
C11IE%==14	;INSUFFICIENT EVM
C11NC%==16	;CPU NOT RUNNING
C11IT%==17	;ILLEGAL TYPE CODE
C11IP%==20	;ILLEGAL PORT NUMBER
C11DL%==21	;NO DL10 SUPPORT IN THIS MONITOR
C11DT%==22	;NO DTE SUPPORT IN THIS MONITOR
C11KD%==23	;NO KDP SUPPORT IN THIS MONITOR
C11DM%==24	;NO DMR SUPPORT IN THIS MONITOR
	SUBTTL	ADDRESSING DEFINITIONS

;DEFINITIONS WHICH LIVED IN COMMON PRIOR TO 7.04:

XP	PAGSIZ,1000		;SIZE OF A PAGE
XP	PG.BDY,<PAGSIZ-1>	;BODY OF A PAGE
XP	P2WLSH,11		;SHIFT TO CONVERT PAGES TO WORDS
XP	W2PLSH,-11		;SHIFT TO CONVERT WORDS TO PAGES
XP	K2WLSH,12		;SHIFT TO CONVERT K TO WORDS
XP	W2KLSH,-12		;SHIFT TO CONVERT WORDS TO K
XP	P2KLSH,-1		;SHIFT TO CONVERT PAGES TO K
XP	K2PLSH,1		;SHIFT TO CONVERT K TO PAGES
XP	S2PLSH,11		;SHIFT TO CONVERT SECTION NUMBER TO PAGE NUMBER
XP	P2SLSH,-11		;SHIFT TO CONVERT PAGE NUMBER TO SECTION NUMBER
XP	BLKSPK,^D3		;SHIFT LEFT TO CONVERT BLOCKS TO K
XP	MBKSPK,-BLKSPK		;SHIFT RIGHT TO CONVERT K TO BLOCKS
XP	BLKSPP,BLKSPK-K2PLSH	;SHIFT TO CALCULATE # OF BLOCKS/PAGE
	SUBTTL	HARDWARE BITS --  FOR BOTH KA10 AND KI10 PROCESSORS
;OLD NAMES FOR SEVERAL RANDOM BITS:

	XP	UWP,1		;IN LH OF DATAO APR TO TURN ON
				; USER-MODE WRITE-PROTECT OF HIGH SEG
	XP	USRMOD,10000	;LH PC WORD, MACHINE WAS IN USER MODE WHEN
				; PC WAS STORED
	XP	UIOMOD,4000	;LH PC WORD, MACHINE WAS IN USER I/O MODE WHEN
				; PC WAS STORED, I.E., ALL INSTRUCTIONS WERE LEGAL.
	XP	POV,200000	;PUSH DOWN OVERFLOW
	XP	ILM,20000	;ILLEGAL MEMORY
;RIGHT HALF APR CONI BITS

XP.LTH==1B18		;LOOP DETECTED IN TRAP HANDLER
			; USED TO PREVENT SAC STOPCDS IN APRLIM
			; THIS IS A SOFTWARE BIT NOT A HARDWARE ONE
XP.CLK==1B26		;CLOCK (HAS INTERRUPTED)

;RIGHT HALF APR CONO BITS

XP.DDU==1B18		;DON'T DISABLE USER ENABLED INTERRUPTS WHEN
			; THEY OCCUR.  THIS IS A SOFTWARE BIT, NOT A HARDWARE
			; ONE.
XP.CCF==1B26		;CLEAR CLOCK FLAG

;PI CONO BITS

XI.CPE==1B19		;CLEAR PARITY ERROR

;LEFT HALF PC FLAG BITS

XC.OVF==1B0		;OVERFLOW
XC.FOV==1B3		;FLOATING OVER FLOW
XC.USR==1B5		;USER MODE
XC.UIO==1B6		;USER IOT MODE
IFN FTKL10,<
XC.PUB==1B7		;LAST INSTRUCTION PUBLIC
>
XC.AFI==1B8		;ADDRESS FAILURE INHIBIT
XC.TRP==3B10		;TRAPS 1 AND 2
	XC.ARI==1		;ARITHMETIC TRAP
	XC.PDL==2		;PUSHDOWN LIST OVERFLOW
	XC.TT3==3		;RESERVED FOR DEC
XC.FUF==1B11		;FLOATING UNDER FLOW
XC.NDV==1B12		;NO DIVIDE

;OTHER RANDOM PC DEFINITIONS

SECMSK==37,,0		;PC SECTION NUMBER
SECWID==5		;WIDTH OF SECTION NUMBER IN BYTE POINTER
SECPOS==^D17		;POSITION OF RIGHTMOST BIT IN SECTION NUMBER
MCSEC0==0,,0		;MONITOR CODE SECTION
MDSEC0==0,,0		;MONITOR DATA SECTION
IFN FTXMON,<
MCSEC1==1,,0		;1ST NON-ZERO MONITOR CODE SECTION
MS.FMD==:2,,0		;FIRST NON-ZERO/NON-ONE MONITOR DATA/CODE SECTION
			; (SYMBOL USED TO REFERENCE FIRST NON-ZERO/NON-ONE
			;  SECTION, ALA "MOVEI AC,(MS.FMD)" VS "MOVEI AC,2")
MS.HGH==:2,,0		;NON-ZERO MONITOR CODE SECTION FOR MAPPING
			; PORTIONS OF THE HIGH SEGMENT AT FIXED ADDRESSES
			; (CODE FROM MONTOP THROUGH MONEND IS ADDRESSED
			; THROUGH THIS SECTION)
MS.MEM==:3,,0		;NON-ZERO MONITOR DATA SECTION (PAGTAB, PT2TAB, MEMTAB)
MS.DCN==:MS.MEM		;NON-ZERO MONITOR DATA SECTION (DECNET DATA BASE)
MS.SCN==:4,,0		;NON-ZERO MONITOR DATA SECTION (SCNSER DATA BASE)
MS.SCA==:5,,0		;NON-ZERO MONITOR DATA SECTION (SCA DATA BASE)
MS.RLC==:6,,0		;NON-ZERO MONITOR CODE/DATA SECTION FOR MAPPING
			; RELOCATABLE CODE (BOOT, ETC.)
MS.SAT==:7,,0		;NON-ZERO MONITOR DATA SECTION (SATS)
MS.SYM==:35,,0		;SECTION 35 STORES SYMBOLS WHEN EXEC DDT IS LOADED
MS.SNP==:36,,0		;SECTION 36 IS USED BY SNOOPY FOR MONITOR PC HISTOGRAM
MS.MAP==:37,,0		;SECTION 37 MAPS SECTION MAPS
>
IFE FTXMON,<
MCSEC1==0,,0
MS.FMD==0,,0
MS.SAT==0,,0
MS.MEM==0,,0
MS.SCN==0,,0
MS.SCA==0,,0
MS.RLC==0,,0
MS.HGH==0,,0
MS.DCN==0,,0
MS.MAP==0,,0
>

;RIGHT HALF BITS FOR USER ENABLING AND TESTING VIA APRENB UUO
UE.NXM==1B23		;NXM ERROR ENABLE AND INTERRUPT (SAME AS KA10 NXM FLAG)
UE.PEF==1B24		;PARITY ERROR ENABLE AND INTERRUPT
			;(SAME AS DISABLE CLOCK WHICH MONITOR NEVER USES
	SUBTTL	HARDWARE BITS --  FOR KA10 PROCESSOR (APR, PI, PC)

;APR CONI BITS:

AP.POV==1B19		;PUSH DOWN OVERFLOW
AP.UIO==1B20		;USER IN-OUT
AP.ABK==1B21		;ADDRESS BREAK
AP.ILM==1B22		;ILLEGAL MEMORY
AP.NXM==1B23		;NON-EXIST. MEMORY
;UE.PEF==1B24		;PARITY ENABLE (AND INTERRUPT) FOR APRENB UUO
			; MONITOR MAKES PARITY BIT APPEAR HERE FOR USER
AP.CIE==1B25		;CLOCK INTERRUPT ENABLED
;AP.CLK==1B26		;CLOCK (HAS INTERRUPTED)
AP.PPV==1B27		;FLAG FOR PROPRITARY PAGE VIOLATION NOT REALLY
			; A CONI BIT.  USED FOR IMPROVED ERROR MESSAGE
AP.FOE==1B28		;FLOATING OVERFLOW ENABLED
AP.FOV==1B29		;FLOATING OVERFLOW (HAS INTERRUPTED)
AP.TOS==1B30		;TRAP OFF SET - MASTER VS. SLAVE
AP.AOE==1B31		;ARITHMETIC OVERFLOW ENABLED
AP.AOV==1B32		;ARITHMETIC OVERFLOW

;APR CONO BITS:
;(DIFFERENT NAMES FROM CONI ONLY BECAUSE SOME HAVE DIFFERENT FUNCTIONS)
AP.CPO==1B18		;CLEAR PDL OVF
;AP.DDU==1B18		;DON'T DISABLE USER ENABLED INTERRUPTS WHEN
			; THEY OCCUR.  THIS IS A SOFTWARE BIT, NOT A HARDWARE
			; ONE.
AP.IOR==1B19		;IO RESET (CLEAR ALL DEVICES)
AP.CAB==1B21		;CLEAR ADDRESS BREAK
AP.CMP==1B22		;CLEAR MEMORY PROTECTION
AP.CNM==1B23		;CLEAR NON-EXISTENT MEMORY
AP.DCI==1B24		;DISABLE CLOCK INTERRUPT
AP.ECI==1B25		;ENABLE CLOCK INTERRUPT
;AP.CCF==1B26		;CLEAR CLOCK FLAG
AP.DFO==1B27		;DISABLE FLOAT. OVERFLOW
AP.EFO==1B28		;ENABLE FLOAT. OVERFLOW
AP.CFO==1B29		;CLEAR FLOATING OVERFLOW
AP.DAO==1B30		;DISABLE ARITH. OVERFLOW
AP.EAO==1B31		;ENABLE ARITH. OVERFLOW
AP.CAO==1B32		;CLEAR ARITH. OVERFLOW
;AP.PI0==7B35		;PI CHANNEL FOR CPU 0 (REDEFINED IN COMMON)
;AP.PI1==7B35		;PI CHANNEL FOR CPU 1 (REDEFINED IN COMMON)

;APR DATAO BITS:
AP.UWP==1B17		;USER MODE WRITE PROTECT FOR HIGH SEGMENT
;PC FLAGS

;PC.OVF==1B0		;OVERFLOW
PC.CY0==1B1		;CARRY 0
PC.CY1==1B2		;CARRY 1
;PC.FOV==1B3		;FLOATING OVER FLOW
PC.BIS==1B4		;BYTE INCREMENT SUPPRESSION
;PC.USR==1B5		;USER MODE
;PC.UIO==1B6		;USER IO MODE
;PC.FUF==1B11		;FLOATING UNDER FLOW
;PC.NDV==1B12		;NO DIVIDE

;PI CONI BITS:

PI.PWF==1B18		;POWER FAILURE
PI.PAR==1B19		;PARITY ERROR IN MEMORY
PI.PEE==1B20		;PARITY ERROR ENABLED
PI.IP1==1B21		;INTERRUPT IN PROGRESS ON CHANNEL 1
PI.IP2==1B22		;     "           "               2
PI.IP3==1B23		;     "           "               3
PI.IP4==1B24		;     "           "               4
PI.IP5==1B25		;     "           "               5
PI.IP6==1B26		;     "           "               6
PI.IP7==1B27		;     "           "               7
PI.IPA==PI.IP1+PI.IP2+PI.IP3+PI.IP4+PI.IP5+PI.IP6+PI.IP7 ;INTERRUPTING PROG ON ALL
PI.PIA==1B28		;PI ACTIVE
PI.CO1==1B29		;CHANNEL ON 1
PI.CO2==1B30		;    "    " 2
PI.CO3==1B31		;    "    " 3
PI.CO4==1B32		;    "    " 4
PI.CO5==1B33		;    "    " 5
PI.CO6==1B34		;    "    " 6
PI.CO7==1B35		;    "    " 7
;PI CONO BITS:
;(DIFFERENT NAMES FROM CONI ONLY BECAUSE SOME HAVE DIFF FUNCTIONS)
PI.CPF==1B18		;CLEAR POWER FAILURE
PI.CPE==1B19		;CLEAR PARITY ERROR
PI.DPE==1B20		;DISABLE PARITY ERROR
PI.EPE==1B21		;ENABLE PARITY ERROR
PI.CPI==1B23		;CLEAR PI SYSTEM
PI.IIO==1B24		;INITIATE INTERRUPT ON (SELECTED PIS)
PI.TNP==1B25		;TURN ON SELECTED PIS
PI.TFP==1B26		;TURN OFF SELECTED PIS
PI.OFF==1B27		;TURN PI SYSTEM OFF
PI.ON==1B28		;TURN PI SYSTEM ON
PI.SC1==1B29		;SELECT CHANNELS 1
PI.SC2==1B30		;   "       "    2
PI.SC3==1B31		;   "       "    3
PI.SC4==1B32		;   "       "    4
PI.SC5==1B33		;   "       "    5
PI.SC6==1B34		;   "       "    6
PI.SC7==1B35		;   "       "    7

;CPU TYPE CODES (RH OF .CPTYP)(LH FOR CUSTOMERS)
CT.P6==1		;PDP-6 TYPE PROCESSOR
CT.KA==2		;KA-10 TYPE PROCESSOR
CT.KI==3		;KI-10 TYPE PROCESSOR
CT.KL==4		;KL-10 TYPE PROCESSOR
CT.KS==5		;KS-10 TYPE PROCESSOR
	SUBTTL	HARDWARE BITS -- FOR KI10 PROCESSOR

;LEFT HALF APR CONI BITS.

IP.MOD==1B1			;MEMORY OVERLAP DISABLE
IP.FMS==1B2			;FAST MEMORY SELECT
IP.MID==1B3			;MI PROGRAM DISABLE
IP.CRO==1B4			;CONSOLE READ ONLY
IP.CLC==1B5			;CONSOLE LOCKED
IP.50H==1B6			;50 HERTZ POWER LINE FREQUENCY
IP.MNM==1B7			;MANUAL MARGINS
IP.MNT==1B8			;MAINTAINANCE MODE
IP.PWL==1B9			;POWER LOW
IP.MCL==1B10			;MARGIN COMPARE LOW
IP.SS1==1B12			;SENSE SWITCH 1
IP.SS2==1B13			;SENSE SWITCH 2
IP.SS3==1B14			;SENSE SWITCH 3
IP.SS4==1B15			;SENSE SWITCH 4
IP.SS5==1B16			;SENSE SWITCH 5
IP.SS6==1B17			;SENSE SWITCH 6

;RIGHT HALF APR CONI BITS.  THOSE MARKED WITH "*" CAUSE INTERRUPTS.

IP.TTO==1B18			;*TIMER TIMED OUT
IP.PAR==1B19			;*PARITY ERROR IN MEMORY
IP.PEE==1B20			;PARITY ERROR ENABLED
IP.TOE==1B21			;TIME-OUT ENABLED
IP.PWF==1B22			;*POWER FAILURE
IP.ARE==1B23			;AUTO-RESTART ENABLED
;UE.PEF==1B24			;PARITY ERROR ENABLE (AND INTERRUPT) FOR APRENB UUO
				; MONITOR MAKES IT APPEAR AS IF PARITY IS HERE FOR USER
IP.CIE==1B25			;CLOCK INTERRUPT ENABLED
;IP.CLK==1B26			;*CLOCK (HAS INTERRUPTED)
IP.ABK==1B27			;*ADDRESS BREAK
IP.IOF==1B28			;*I/O PAGE FAIL FLAG
IP.NXM==1B29			;*NON-EXISTANT MEMORY

;BITS 30-35 ARE APR ERROR AND CLOCK PI ASSIGNMENTS
;RIGHT HALF APR CONO BITS.

IP.SWT==1B18			;SET WATCH-DOG TIMER
IP.IOR==1B19			;I/O RESET (CLEAR ALL DEVICES)
IP.CTE==1B20			;CLEAR TIME-OUT ENABLE
IP.STE==1B21			;SET TIME-OUT ENABLE
IP.CAE==1B22			;CLEAR AUTO-RESTART ENABLE
IP.SAE==1B23			;SET AUTO-RESTART ENABLE
IP.DCI==1B24			;DISABLE CLOCK INTERRUPTS
IP.ECI==1B25			;ENABLE CLOCK INTERRUPTS
;IP.CCF==1B26			;CLEAR CLOCK FLAG
IP.CAB==1B27			;CLEAR ADDRESS BREAK
IP.CIO==1B28			;CLEAR I/O PAGE FAIL
IP.CNM==1B29			;CLEAR NON-EXISTANT MEMORY

;BITS 30-35 ARE APR ERROR AND CLOCK PI ASSIGNMENTS

;LEFT HALF PI CONI BITS. NONE CAUSE INTERUPTS.

II.AIF==1B0	;ADDRESS BREAK ON INSTRUCTION FETCH SWITCH IS ON
II.ADF==1B1	;   "      "    "    DATA       "      "    "  "
II.ABW==1B2	;   "      "    " WRITE SWITCH
II.ASS==1B3	;ADDRESS STOP SWITCH
II.ABS==1B4	;ADDRESS BREAK SWITCH
II.EPS==1B5	;EXEC PAGING SWITCH
II.UPS==1B6	;USER PAGING SWITCH
II.PSS==1B7	;PARITY STOP SWITCH
II.NSS==1B8	;NXM STOP SWITCH
II.PR1==1B11	;PROGRAM PI REQUESTED FOR CHANNEL 1
II.PR2==1B12	;   "    "      "      "     "    2
II.PR3==1B13	;   "    "      "      "     "    3
II.PR4==1B14	;   "    "      "      "     "    4
II.PR5==1B15	;   "    "      "      "     "    5
II.PR6==1B16	;   "    "      "      "     "    6
II.PR7==1B17    ;   "    "      "      "     "    7
;RIGHT HALF PI CONO BITS.

II.CPF==1B18			;CLEAR POWER FAIL FLAG
;II.CPE==1B19			;CLEAR PARITY ERROR FLAG
II.EPE==1B21			;ENABLE PARITY ERROR
II.CPP==1B22			;CLEAR PROGRAM PI N
II.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
II.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
II.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
II.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
II.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
II.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
II.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
II.IPA==II.IP1+II.IP2+II.IP3+II.IP4+II.IP5+II.IP6+II.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
II.PIA==1B28			;PI ACTIVE
II.CO1==1B29			;PI CHANNEL 1 ON
II.CO2==1B30			;PI CHANNEL 2 ON
II.CO3==1B31			;PI CHANNEL 3 ON
II.CO4==1B32			;PI CHANNEL 4 ON
II.CO5==1B33			;PI CHANNEL 5 ON
II.CO6==1B34			;PI CHANNEL 6 ON
II.CO7==1B35			;PI CHANNEL 7 ON
II.ACO==II.CO1+II.CO2+II.CO3+II.CO4+II.CO5+II.CO6+II.CO7
				;ANY OR ALL PI CHANNELS ON
;LEFT HALF PC FLAG BITS.

IC.000==1B0			;(EXEC)
;IC.OVF==1B0			;(USER) ARITHMETIC OVERFLOW
IC.CY0==1B1			;CARRY 0
IC.CY1==1B2			;CARRY 1
;IC.FOV==1B3			;FLOATING OVERFLOW
IC.BIS==1B4			;BYTE INCREMENT SUPPRESSION
;IC.USR==1B5			;USER MODE
IC.UOU==1B6			;(EXEC) UUO OLD USER
;IC.UIO==1B6			;(USER) USER IOT MODE
IC.LIP==1B7			;LAST INSTRUCTION PUBLIC
IC.AFI==1B8			;ADDRESS FAILURE INHIBIT
IC.ATN==3B10			;APR TRAP NUMBER
IC.TN0==1B9			;TRAP BIT 0
IC.TN1==1B10			;TRAP BIT 1
;IC.FUF==1B11			;FLOATING POINT UNDERFLOW
;IC.NDV==1B12			;NO DIVIDE
	SUBTTL	PAGE/SECTION MAP ENTRIES

;PAGE MAP WORD FORMAT.

;POINTER TYPE FIELD (BITS 0-2)

PM.NCD==:0			;NO ACCESS
PM.DCD==:1			;DIRECT
PM.SCD==:2			;SHARED
PM.ICD==:3			;INDIRECT
PM.ACD==:7			;ALL BITS IN FIELD

;DESCRIPTOR BITS

PM.PUB==:1B3			;PUBLIC
PM.WRT==:1B4			;WRITABLE
PM.KPM==:1B5			;KEEP ME
PM.CSH==:1B6			;CACHEABLE
PM.SWB==:1B7			;SOFTWARE BIT - USED TO MARK PAGES WHICH SHOULD
				; BE WRITABLE AFTER INITIALIZATION COMPLETES
PM.NIA==:1B7			;NO I/O ALLOWED INTO PAGE (HIGH SEG, BASICALLY)
PM.SPY==:1B8			;SPY PAGE
PM.COR==:1B9			;ADDRESS FIELD CONTAINS CORE ADDRESS IF SET
PM.AAB==:1B10			;ACCESS ALLOWED
PM.LOK==:1B11			;PAGE IS LOCKED IN CORE
PM.OIQ==:1B12			;ON PAGING I/O QUEUE
PM.SSP==:1B13			;SLOW SWAPPING

;COMPOSITE MASKS, ETC.

PM.ADR==:7,,777777		;ADDRESS PORTION OF PAGE MAP ENTRY
PM.PAG==:17777			;PHYSICAL PAGE MAXIMUM FOR KL (4 MEG)
PM.UNT==:7,,0			;UNIT PORTION OF DISK ADDRESS
PM.NAD==:-1^!PM.ADR		;EVERYTHING BUT ADDRESS
PM.SAD==:^D21			;SIZE
PM.FLG==:PM.AAB!PM.SPY!PM.NIA!PM.COR	;SOFTWARE FLAGS
PM.BTS==:PM.PUB!PM.WRT!PM.SWB!PM.CSH!PM.AAB!PM.SPY!PM.NIA!PM.COR


PM.ZER==:1,,0			;CORE ALLOCATED BUT 0 IF ONLY
				; THIS BIT IS ON IN THE MAP SLOT

;BITS IN SECTION MAP

SM.WSB==:PM.AAB			;SECTION HAS A WORKING SET PAGE IN IT
;FORMAT OF SECONDARY PAGE MAP BLOCK (FOR HIGH SEG)

	PHASE	0

.M2SIZ::!BLOCK	1		;MAX SIZE OF HIGH SEG (# OF SLOTS) (RH)
.M2VPN::!BLOCK	1		;POINTER TO VPN TABLE OR NEXT VPN
.M2LCN::!BLOCK	1		;LOCKED COUNT
.M2MAX::!			;LAST OVERHEAD WORD
.M2MAP::!			;START OF MAPPING POINTERS (JBYOFF POINTS HERE)
	DEPHASE

;FORMAT FOR SEGMENT DATA BLOCK

	PHASE	0

.HBLNK::!BLOCK	1		;LINK WORD
.HBSGN::!BLOCK	1		;SEGMENT #+BITS
;BITS:
;SEE ALSO JBTSGN - SOME BITS APPEAR BOTH HERE AND IN JBTSGN FOR THE JOB
	XP	SPYSEG,400000	;THE HIGH SEG IS PHYSICAL CORE (SEE SPYUUO)
				; MUST BE SIGN BIT SO TEST FOR JOB HAVING A
				; REAL HIGH SEG IS SKIPG JBTSGN(J)
				;THIS BIT CAN ALSO BE SET IN AN AC (AS IN J),
				;SO THAT MODULES LIKE LOKCON CAN USE A COPY
				;OF JBTSGN AS AN INDEX. THIS WILL NEVER BE
				;STORED BACK IN JBTSGN, IT WILL JUST BE USED
				;IN THE AC.
	XP	SHRSEG,SHRSEG	;THE HIGH SEG THIS JOB IS USING IS SHARABLE
				; THIS BIT ALSO APPEARS IN JBTSTS FOR HIGH SEGS
	XP	REDOMP,100000	;ON IF THE HIGH SEGMENT PART OF THIS
				; JOB'S MAP MUST BE REDONE
	XP	MEDDLE,40000	;IF 1, USER HAS MEDDLED WITH SHARABLE PROGRAM SUCH
				; THAT PROGRAM CANNOT TRUST ITSELF
				; TO TURN UWP OFF OR CHANGE HIGH SEG CORE ASSIGNMENT
				; MEDDLING MEANS:
				;   1. START N, OR D COMMAND
				;   2. RUN UUO WITH GREATER THAN 1 STARTING INCREMENT
				;   3. GETSEG UUO
				;   4. HIGH SEG IS PHYSICAL CORE (SPY UUO)
	XP	CORCNT,20000	;IF 1, THE HIGH SEG IN CORE COUNT FOR THIS
				; JOB HAS BEEN INCREMENTED.  IF 0, IT HAS NOT.
				; SET AND CLEARED BY INCCNT AND DECCNT ROUTINES.
	XP	LOKSEG,10000	;THE HIGH SEGMENT THIS JOB IS SHARING IS LOCKED
				; IN CORE. THE HIGH SEGMENT WILL ONLY BE UNLOCKED
				; WHEN THIS BIT IS OFF EVERY JOB SHARING
				; THE HIGH SEGMENT.
	XP	NCSH,4000	;THE HIGH SEGMENT THIS JOB IS USING
				; IS TO HAVE THE CACHE BITS OFF IN
				; THIS JOB'S MAP
	XP	SWCUP,2000	;SEGMENT WAIT COUNT (IN JBTSGN) UP FOR THIS SEG
	XP	NOCSH,1000	;ON IF THIS JOB'S HIGH SEGMENT IS NOT TO
				; BE CACHED SINCE IT IS SHARABLE, WRITABLE
				; BY SOME JOB IN A MULTIPROCESSING MONITOR
	XP	UWPOFF,400	;IF 1, USER-MODE WRITE PROTECT IS OFF FOR THIS JOB
	XP	GTSSEG,200	;ON IF THIS JOB'S HIGH SEGMENT WAS
				; OBTAINED VIA A GETSEG UUO
	XP	SHRCNT,100	;ON IF THIS JOB HAS INCREMENTED THE TOTAL SHARE
				; COUNT FOR THIS SEGMENT.  SET AND CLEARED BY
				; INCSHR AND DECSHR

.HBSPO::!			;SPY SEGMENT ORIGIN PAGE (SPY SEGS ONLY)
	PSPOLH==<POINT 9,,26>	;(BITS 18-26; SECTION RELATIVE)
.HBSG2::!			;SECTION # (FORMERLY JBYSG2)
	PSG2LH==<POINT 5,,17>	;SKELETON BP (BITS 13-17)
.HBHSZ::!			;SIZE OF SEGMENT (BITS 0-8)
	PHSSLH==<POINT 9,,8>	;SKELETON BYTE POINTER

	BLOCK	1
.HBHNM::!BLOCK	1		;HIGH SEGMENT NAME,  C(.JBHRL), USED BY SEGOP.
.HBLEN::!			;SIZE OF THE HIGH SEG DATA BLOCK

	DEPHASE
;BITS IN CONO PAGE WORD.

PG.LUB==1B0			;LOAD USER BASE REGISTER
PG.ACE==1B4			;USER ADDRESS COMPARE ENABLE
PG.LEB==1B18			;LOAD EXEC BASE REGISTER
PG.EAT==1B22			;ENABLE TRAPS
PG.AC0==0B2			;USE AC SET 0 IN USER MODE
PG.AC1==1B2			;USE AC SET 1 IN USER MODE
PG.AC2==2B2			;USE AC SET 2 IN USER MODE
PG.AC3==3B2			;USE AC SET 3 IN USER MODE
PG.EPT==17777			;ADDRESS OF EPT
PG.UPT==17777B17		;ADDRESS OF UPT

;MAP INSTRUCTION

MP.USR==1B0			;USER ADDRESS REFERENCE IF SET
MP.BAD==1B1			;BAD MAPPING (FAILURE)
MP.MOD==1B3			;MODIFIED
MP.WRT==1B4			;WRITTEN
MP.BTS==17B5			;(KS) BITS GUARANTEED NON-ZERO IF VALID MAPPING
MP.PUB==1B6			;PUBLIC
MP.CSH==1B7			;CACHED
MP.ADR==17,,777777		;PHYSICAL ADDRESS
MP.NAD==-1^!MP.ADR		;NON-ADDRESS BITS

;INSPECT FLTCHK AT VMSER FOR PROPER TESTING OF MP.BAD/MP.BTS

;BITS RETURNED AS PAGE-FAIL CODE ON PAGE FAULTS
PC.PNA==1			;PAGE NOT ACCESSABLE
PC.PNC==2			;PAGE NOT IN CORE
PC.UUO==3			;PAGE FAULT WHILE IN UUO PROCESSING
PC.TIM==4			;TIME-CAUSE FAULT DISPATCH
PC.AZU==5			;FAULT ON AN ALLOCATED-BUT-ZERO PAGE
				; (NON MONITOR-CALL)
PC.AZM==6			;FAULT ON A  MONITOR CALL PAGE ALLOCATED BUT 0

;BITS RETURNED IN PAGE-FAIL WORD
PC.WHC==1B0			;WORKING SET HAS CHANGED
PC.WSS==1B1			;WORKING SET IS SCRAMBLED
;BITS IN THE DATAO PTR (OPERATING CONSOLE) WORD

OC.BCI==1B0			;BREAK CONDITION INSTRUCTION FETCH
OC.BCD==1B1			;BREAK CONDITION DATA FETCH
OC.BCW==1B2			;BREAK CONDITION WRITE
OC.BCM==1B3			;BREAK CONDITION MUUO (SOFTWARE BIT)
OC.ABE==1B4			;ADDRESS BREAK ENABLED
OC.FEP==1B5			;FOLLOW EXEC PAGING
OC.FUP==1B6			;FOLLOW USER PAGING
OC.BSU==1B7			;BREAK ADDRESS AND CONDITIONS SET BY UUO

;BITS 14-35 SET ADDRESS SWITCHES

;PAGE FAILURE NUMBERS (STORED IN THE PF WORD ON A PAGE FAILURE)

IFN FTKL10,<
PF.SUV==20			;SMALL USER VIOLATION
PF.PRV==21			;PROPRIETARY VIOLATION
PF.PRF==22			;PAGE REFILL FAILURE
PF.ABF==23			;ADDRESS BREAK FAILURE
PF.IID==24			;ILLEGAL INDIRECT (BITS 0 & 1 =1)
PF.PTP==25			;PAGE TABLE PARITY ERROR
PF.ISN==27			;ILLEGAL SECTION NUMBER
PF.ARP==36			;AR PARITY ERROR
PF.AXP==37			;ARX PARITY ERROR
>;IFN FTKI10!FTKL10

IFN FTKS10,<
PF.IOP==20			;UBA ADDRESS FAILURE (I/O PAGE FAILURE)
PF.PTP==25			;PAGE TABLE PARITY ERROR
PF.PAR==36			;UNCORRECTABLE (HARD) MEMORY PARITY ERROR
PF.NXM==37			;NXM
>;IFN FTKS10

;BITS IN THE PAGE FAIL WORD

PF.USR==1B0			;PAGE FAILURE CAUSED BY A REFERENCE TO A PAGE
				; IN THE USER'S VIRTUAL ADDRESS SPACE
PF.BAD==1B1			;BAD PAGE FAIL (CODES IN THE 20'S)
PF.ACC==1B2			;PAGE IS ACCESSIBLE
PF.WRT==1B5			;PAGE FAILURE WAS CAUSED BY A WRITE VIOLATION
PF.PHY==1B8			;PAGE FAILURE WAS CAUSED BY A PHYSICAL REFERENCE
PF.KPM==1B8			;KEEP ME, SUPERCEDES PF.PHY
	SUBTTL	HARDWARE BITS -- FOR KL10 PROCESSOR

IFN FTKL10,<
;LEFT HALF APR CONI BITS.

LP.SEE==1B6		;SBUS ERROR ENABLED
LP.NEE==1B7		;NXM ERROR ENABLED
LP.IFE==1B8		;I/O PAGE FAIL ERROR ENABLED
LP.PEE==1B9		;PARITY ERROR ENABLED
LP.CDE==1B10		;CACHE DIRECTORY PARITY ERROR ENABLED
LP.PDE==1B11		;PAGE TABLE DIRECTORY PARITY ERROR ENABLED
LP.PFE==1B12		;POWER FAIL ENABLED
LP.SDE==1B13		;SWEEP DONE ENABLED

;RIGHT HALF APR CONI BITS

LP.CSB==1B19		;CACHE SWEEP BUSY
LP.SBE==1B24		;S-BUSS ERROR
LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.CDP==1B28		;CACHE DIRECTORY PARITY ERROR
LP.ADP==1B29		;ADDRESS PARITY ERROR
LP.PWF==1B30		;POWER FAIL
LP.CSD==1B31		;CACHE SWEEP DONE
LP.INT==1B32		;INTERRUPT REQUEST
LP.PIA==7B35		;PIA

;CONO APR BITS
LP.IOR==1B19		;IO RESET
LP.ESF==1B20		;ENABLE SELECTED FLAGS (BITS 24-31)
LP.DSF==1B21		;DISABLE SELECTED FLAGS (BITS 24-31)
LP.CSF==1B22		;CLEAR SELECTED FLAGS (BITS 24-31)
LP.SSF==1B23		;SET SELECTED FLAGS (BITS 24-31)
LP.SBE==1B24		;S-BUSS ERROR
LP.NXM==1B25		;NXM
LP.IOF==1B26		;I/O PAGE FAIL
LP.PAR==1B27		;PARITY ERROR
LP.CDP==1B28		;CACHE DIRECTORY PARITY
LP.ADP==1B29		;ADDRESS PARITY
LP.PWF==1B30		;POWER FAIL
LP.CSD==1B31		;CACHE SWEEP DONE
LP.PIA==7B35		;PIA
;LEFT HALF CONI PI BITS
LI.PR1==1B11		;PROGRAM P1 REQUEST FOR CHANNEL 1
LI.PR2==1B12		;PROGRAM PI REQUEST FOR CHANNEL 2
LI.PR3==1B13		;PROGRAM PI REQUEST FOR CHANNEL 3
LI.PR4==1B14		;PROGRAM PI REQUEST FOR CHANNEL 4
LI.PR56=1B15		;PROGRAM PI REQUEST FOR CHANNEL 5
LI.PR6==1B16		;PROGRAM PI REQUEST FOR CHANNEL 6
LI.PR7==1B17		;PROGRAM PI REQUEST FOR CHANNEL 7

;RIGHT HALF PI CONO BITS.

LI.EPA==1B18			;EVEN PARITY ADDRESSES
LI.EPD==1B19			;EVEN PARITY DATA
LI.CPP==1B22			;CLEAR PROGRAM PI N
LI.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
LI.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
LI.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
LI.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
LI.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
LI.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
LI.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
LI.IPA==LI.IP1+LI.IP2+LI.IP3+LI.IP4+LI.IP5+LI.IP6+LI.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
LI.PIA==1B28			;PI ACTIVE
LI.CO1==1B29			;PI CHANNEL 1 ON
LI.CO2==1B30			;PI CHANNEL 2 ON
LI.CO3==1B31			;PI CHANNEL 3 ON
LI.CO4==1B32			;PI CHANNEL 4 ON
LI.CO5==1B33			;PI CHANNEL 5 ON
LI.CO6==1B34			;PI CHANNEL 6 ON
LI.CO7==1B35			;PI CH7NNEL 7 ON
LI.ACO==LI.CO1+LI.CO2+LI.CO3+LI.CO4+LI.CO5+LI.CO6+LI.CO7
;BITS FOR KL10 PROGRAM CLOCKS


;BITS IN CONO TIM,

TO.CIT==1B18		;CLEAR INTERVAL TIMER
TO.SIT==1B21		;START INTERVAL TIMER
TO.CTD==1B22		;CLEAR TIMER DONE
TO.PRP==1B35		;POSITION OF PERIOD FIELD
TO.PRS==^D12		;SIZE OF PERIOD FIELD
TO.PRF==7777B35		;THE FIELD ITSELF


;BITS IN CONI TIM,

TI.INP==1B17		;POSITION OF INTERVAL TIMER FIELD
TI.INS==^D12		;SIZE OF IT
TI.INF==7777B17		;THE FIELD ITSELF
TI.TIO==1B21		;INTERVAL TIMER ON
TI.ITD==1B22		;INTERVAL TIMER DONE
TI.TOV==1B23		;TIMER OVERFLOW
TI.PRP==1B35		;PERIOD REGISTER POSITION
TI.PRS==^D12		;SIZE
TI.PRF==7777B35		;FIELD


;BITS IN CONO MTR,

MO.LAC==1B18		;LOAD ACCOUNTING CONTROL
MO.AIP==1B21		;ACCT INCLUDE PI
MO.AEN==1B22		;ACCT INCLUDE EXEC NO PI
MO.AO==1B23		;ACCT ON
MO.TOF==1B24		;TIME BASE OFF
MO.TON==1B25		;TIME BASE ON
MO.CTB==1B26		;CLEAR TIME BASE
MO.IPI==7B35		;INTERVAL TIMER PI

;BITS IN CONI MTR,

MI.AIP==1B21		;ACCT INCLUDE PI
MI.AEN=1B22		;ACCT INCLUDE EXEC NO PI
MI.AO==1B23		;ACCT ON
MI.TON==1B25		;TIME BASE ON
MI.IPI==7B35		;INTERVAL TIMER PI
;LEFT HALF WRPAE BITS

PE.CP0==1B0		;CHANNEL 0 PERFORMANCE ENABLE
PE.CP1==1B1		; CHANNEL 1
PE.CP2==1B2
PE.CP3==1B3
PE.CP4==1B4
PE.CP5==1B5
PE.CP6==1B6
PE.CP7==1B7
PE.CPI==1B8		;CHANNEL PERFORMANCE IGNORE

PE.UCI==1B9		;MICROCODE STATE IGNORE

PE.PRL==1B10		;PROBE LOW ENABLE
PE.PRI==1B11		;PROBE STATE IGNORE

PE.CCR==1B12		;CACHE REFILL ENABLE
PE.CCF==1B13		;CACHE FILL ENABLE
PE.EWB==1B14		;EBOX WRITE BACK
PE.SWB==1B15		;SWEEP WRITE BACK ENABLE
PE.CCI==1B16		;CACHE CONDITION IGNORE

;RIGHT HALF WRPAE BITS

PE.PP0==1B18		;PI 0 PERFORMANCE ENABLE
PE.PP1==1B19
PE.PP2==1B20
PE.PP3==1B21
PE.PP4==1B22
PE.PP5==1B23
PE.PP6==1B24
PE.PP7==1B25
PE.NPI==1B26		;NO PI
PE.PPI==777B26		;PI CONDITION IGNORE

PE.PCU==1B27		;PC USER ENABLE
PE.PCI==1B28		;PC IGNORE
PE.EVM==1B29		;EVENT MODE (RATHER THAN DURATION MODE)
PE.CLR==1B30		;CLEAR PERFORMANCE METER



;VALUES FOR THE CLOCKS

.EBCPT==10000		;EBOX COUNTS/EBOX TICK
.MBCPT==10000		;MBOX COUNTS/MBOX TICK
.TBCPT==10000		;TIME BASE COUNTS/TIME BASE TICK

TB.LTP==^L<.TBCPT>	;POSITION THAT TIME BASE STARTS COUNTING IN
;BITS IN CONO PAG
LG.CSL==1B18		;CACHE STRATEGY LOOK
LG.CSW==1B19		;CACHE STRATEGY WRITE
LG.KIP==0B21		;KI PAGING (INVERTED IN BREADBOARD)
LG.KLP==1B21		;KL PAGING
LG.TEN==1B22		;TRAP ENABLE
LG.EPT==17777		;ADDRESS OF EPT

;BITS IN DATAO PAG
LG.LAB==1B0		;LOAD AC BLOCKS
LG.LPC==1B1		;LOAD PREV CONTEXT
LG.LUB==1B2		;LOAD USER BASE REGISTER
LG.KPM==1B3		;KEEP MAP ENTRIES WITH "KEEP ME" LIT IN PAGING MEMORY
LG.CAC==7B8		;CURRENT AC BLOCK #
LG.PAC==7B11		;PREV. AC BLOCK #
LG.CSX==1B12		;CSWX
LG.PCS==37B17		;PREVIOUS CONTEXT SECTION
LG.IAM==1B18		;INHIBIT STORING ACCOUNTING METER
LG.UPT==17777		;ADDRESS OF UBR

;BITS IN RDERA
EA.SWP==1B2		;CACHE SWEEP REFERENCE
EA.CHN==1B3		;CHANNEL REFERENCE
EA.DAT==1B4		;DATA SOURCE FIELD (2 BIT ENCODING)
EA.SRC==1B5		;...
EA.WRT==1B6		;MEMORY WRITE

;BITS IN APRID
ID.KLP==1B0		;KL PAGING
ID.XAD==1B1		;EXTENDED ADDRESSING
ID.XUC==1B2		;EXOTIC MICROCODE
ID.PMV==1B4		;MICROCODE SUPPORTS PHYSICAL MOVE/MOVEM
ID.UVN==777B17		;MICROCODE VERSION NUMBER
ID.50H==1B18		;50 HZ EXTENAL POWER
ID.CSH==1B19		;PROCESSOR HAS CACHE
ID.CHL==1B20		;CHANNEL
ID.XKL==1B21		;EXTENDED KL
ID.MCA==1B23		;REAL MCA25 BIT
ID.PSN==7777B35		;PROCESSOR SERIAL NUMBER
>; END IFN FTKL10
	SUBTTL	HARDWARE BITS -- FOR KS10 PROCESSOR

IFN FTKS10,<

;WRAPR BITS

SP.IOR==1B19		;IO RESET
SP.ESF==1B20		;ENABLE SELECTED FLAGS (BITS 24-31)
SP.DSF==1B21		;DISABLE SELECTED FLAGS (BITS 24-31)
SP.CSF==1B22		;CLEAR SELECTED FLAGS (BITS 24-31)
SP.SSF==1B23		;SET SELECTED FLAGS (BITS 24-31)
SP.IFE==1B25		;INTERRUPT FRONT END
SP.PWF==1B26		;POWER FAIL
SP.NXM==1B27		;NXM
SP.HMP==1B28		;HARD MEMORY PARITY ERROR
SP.SMP==1B29		;SOFT MEMORY PARITY ERROR
SP.ITI==1B30		;INTERVAL TIMER
SP.PIA==7B35		;PIA

;RDAPR BITS, LEFT HALF

SP.PFE==1B8		;POWER FAIL ENABLED
SP.NEE==1B9		;NXM ERROR ENABLED
SP.HPE==1B10		;HARD MEM PAR ERROR ENABLED
SP.SPE==1B11		;SOFT MEM PAR ERROR ENABLED
SP.ITE==1B12		;INTERVAL TIMER ENABLED

;RDAPR BITS, RIGHT HALF

SP.PWF==1B26		;POWER FAIL
SP.NXM==1B27		;NXM
SP.HMP==1B28		;HARD MEMORY PARITY ERROR
SP.SMP==1B29		;SOFT MEMORY PARITY ERROR
SP.ITI==1B30		;INTERVAL TIMER INTERRUPT
SP.FEI==1B31		;INTERRUPT FROM 8080 FRONT END
SP.INT==1B32		;INTERRUPT REQUESTED
SP.PIA==7B35		;PIA

;BITS IN APRID
ID.KLP==1B5		;KL PAGING
ID.NCU==3B1		;MICROCODE SUPPORTS NO CST UPDATE
ID.UVN==777B17		;MICROCODE VERSION NUMBER
ID.PSN==77777B35	;PROCESSOR SERIAL NUMBER

;WRUBR BITS

SG.LAB==1B0		;LOAD AC BLOCKS
SG.LUB==1B2		;LOAD USER BASE REGISTER
SG.CAC==7B8		;CURRENT AC BLOCK NUMBER
SG.PAC==7B11		;PREVIOUS AC BLOCK NUMBER
SG.UPT==3777B35		;ADDRESS OF UBR

;WREBR BITS

SG.KIP==0B21		;KI PAGING (INVERTED IN BREADBOARD)
SG.KLP==1B21		;KL PAGING
SG.TEN==1B22		;TRAP AND PAGING ENABLED
SG.EPT==3777B35		;ADDRESS OF EPT
;LEFT HALF RDPI BITS
SI.PR1==1B11		;PROGRAM P1 REQUEST FOR CHANNEL 1
SI.PR2==1B12		;PROGRAM PI REQUEST FOR CHANNEL 2
SI.PR3==1B13		;PROGRAM PI REQUEST FOR CHANNEL 3
SI.PR4==1B14		;PROGRAM PI REQUEST FOR CHANNEL 4
SI.PR56=1B15		;PROGRAM PI REQUEST FOR CHANNEL 5
SI.PR6==1B16		;PROGRAM PI REQUEST FOR CHANNEL 6
SI.PR7==1B17		;PROGRAM PI REQUEST FOR CHANNEL 7

;RIGHT HALF WRPI BITS.

SI.CPP==1B22			;CLEAR PROGRAM PI N
SI.IP1==1B21			;INTERRUPT IN PROGRESS ON PI CHANNEL 1
SI.IP2==1B22			;INTERRUPT IN PROGRESS ON PI CHANNEL 2
SI.IP3==1B23			;INTERRUPT IN PROGRESS ON PI CHANNEL 3
SI.IP4==1B24			;INTERRUPT IN PROGRESS ON PI CHANNEL 4
SI.IP5==1B25			;INTERRUPT IN PROGRESS ON PI CHANNEL 5
SI.IP6==1B26			;INTERRUPT IN PROGRESS ON PI CHANNEL 6
SI.IP7==1B27			;INTERRUPT IN PROGRESS ON PI CHANNEL 7
SI.IPA==SI.IP1+SI.IP2+SI.IP3+SI.IP4+SI.IP5+SI.IP6+SI.IP7
				;INTERRUPT IN PROGRESS ON ANY OR ALL PI CHANNELS
SI.PIA==1B28			;PI ACTIVE
SI.CO1==1B29			;PI CHANNEL 1 ON
SI.CO2==1B30			;PI CHANNEL 2 ON
SI.CO3==1B31			;PI CHANNEL 3 ON
SI.CO4==1B32			;PI CHANNEL 4 ON
SI.CO5==1B33			;PI CHANNEL 5 ON
SI.CO6==1B34			;PI CHANNEL 6 ON
SI.CO7==1B35			;PI CH7NNEL 7 ON
SI.ACO==SI.CO1+SI.CO2+SI.CO3+SI.CO4+SI.CO5+SI.CO6+SI.CO7
;PHYSICAL CORE DEFINITIONS FOR KS10 CTY, KLINIK SERVICE
; AND OTHER FRONT-END FUNCTIONS

XPP RLWORD,31		;RELOAD WORD
	KSRLD==1B4		;RELOAD REQUEST
	KPACT==1B5		;KEEP ALIVE ACTIVE
	KLACT==1B6		;KLINIK ACTIVE
	PAREN==1B7		;PARITY ERROR DETECT ENABLED
	CRMPAR==1B8		;CRAM PAR ERR DETECT ENABLED
	DRMPAR==1B9		;DRAM PAR ERR DETECT ENABLED
	CASHEN==1B10		;CACHE ENABLED
	MILSEN==1B11		;1MSEC ENABLED
	KPALIV==377B28		;KEEP ALIVE WORD
	AUTOBT==1B32		;BOOT SWITCH OR POWER UP CONDITION
	PWRFAL==1B33		;POWER FAIL
	FORREL==1B34		;FORCED RELOAD
	KEPFAL==1B35		;KEEP ALIVE FAILURE

XPP CTYIWD,32		;CTY INPUT WORD
	CTYICH==377B35		;CTY INPUT CHARACTER
	CTYIVL==1B27		;INPUT VALID BIT

XPP CTYOWD,33		;CTY OUTPUT WORD
	CTYOCH==377B35		;CTY OUTPUT CHARACTER
	CTYOVL==1B27		;OUTPUT VALID FLAG

XPP KLIIWD,34		;KLINIK INPUT WORD
	KLIICH==377B35		;KLINIK INPUT CHARACTER
	KLIIVL==1B27		;KLINIK INPUT VALID
	KLICHR==1B27		;KLINIK CHARACTER
	KLIINI==2B27		;KLINIK INITED
	KLICAR==3B27		;CARRIER LOST


XPP KLIOWD,35		;KLINIK OUTPUT WORD
	KLIOCH==377B35		;KLINIK OUTPUT CHARACTER
	KLIOVL==1B27		;KLINIK OUTPUT VALID
	KLOCHR==1B27		;KLINIK CHARACTER AVAILABLE
	KLIHUP==2B27		;KLINIK HANGUP REQUEST
	SUBTTL	HARDWARE BITS -- FOR KS10 UBA AND DEVICES

; MAXIMUM UNIBUS ADAPTER NUMBER

MAXUBA==4			;WE ONLY SUPPORT ADAPTERS 1 & 3

; EXTERNAL PAGE DEFINITIONS FOR UNIBUS ADAPTER

UBAEXP==763000			;ADDRESS OF UNIBUS ADAPTER (FIRST ADDRESS)
UNBSTW==763100			;BASIC UNIBUS STATUS REGISTER ADDRESS (MINUS UNIT NUMBER)
UNBSTS==100			;ADDRESS OF STATUS WORD (FIRST UNIBUS ADAPTER)

; BIT DEFINITIONS FOR STATUS WORD
UNBTMO==1B18			;NON EX DEVICE (TIMEOUT)
UNBBME==1B19			;BAD MEMORY
UNBBPE==1B20			;SM10 BUS PARITY
UNBNED==1B21			;NON EX CPU DEVICE
UNBACL==1B26			;AC OR DC LOW (POWER FAIL ON UNIBUS)
UNBENI==1B27			;ENABLE INTERNAL INTERRUPT
UNBDTR==1B28			;DISABLE TRANSFER ON UNCORRECTABLE DATA
UBINIT==1B29			;UNIBUS INIT

UBAMUL==4000			;MULTIPLIER FOR UNIBUS ADDRESSES / PAGE RAM
UBAPGS==100			;NUMBER OF MAPPING REGISTERS
MXUBWN==100			;MAX MAPPING REGISTER
UNBPAR==1B4			;UNIBUS ADAPT PARITY BIT
UNBRRV==1B18			;READ REVERSE BIT
UNBD18==1B19			;DISABLE 18 BIT MODE TRANSFER (16 BIT TRANSFERS)
UNB36B==1B20			;36 BIT MODE TRANSFERS
UNBVBT==1B21			;VALID TRANSFER BIT

;DEFINITIONS FOR MEMORY STATUS REGISTER

MEMSTS==100000			;UNIBUS ADDRESS OF MEMORY STATUS REGISTER
	MR.HLD==1B0		;HOLD BIT
	MR.BAD==1B1		;BAD DATA
	MR.REF==1B2		;REFRESH ERROR (%MRE)
	MR.PAR==1B3		;PARITY ERROR (?PAR ERR)
	MR.ECC==1B4		;ECC CORRECTION ENABLED
	MR.ECD==177B11		;ECC CORRECTION CODE
	MR.PWF==1B12		;POWER/BATTERY BACKUP FAILURE
	MR.ERA==17777777B35	;ERROR ADDRESS

;NOTE THE DEVICE ADDRESSES ARE A FULL-WORD QUANTITY IN THE FORMAT:
;	XWD	UBA NUMBER,,UNIBUS ADDRESS

;DUP11 DEFINITIONS

	DUP1BA==3760300		;DUP-11 BASE ADDRESS

;KMC11 DEFINTIONS

	KMC1BA==3760540		;KMC11 DEVICE ADDRESS
	KMC1IV==540		;INTERRUPT VECTOR FOR KMC11

;DMR11 DEFINITIONS

	DMR1BA==3764000		;DMR11 DEVICE ADDRESS
				;Temp in "user space" for ME
	DMR1IV==610		;DMR11 INTERRUPT VECTOR
				;Also a ME definition

;RX20 DEFINITIONS

	RX21BA==3777170			;RX211 BASE ADDRESS
	RX21IV==264			;INTERRUPT VECTOR

;PC22 DEFINITIONS

	PR11CA==3777550			;CSR ADDRESS FOR PTR
	PR11IV==70			;INTERRUPT VECTOR FOR PTR
	PP11CA==3777554			;CSR ADDRESS FOR PTP
	PP11IV==74			;INTERRUPT VECTOR FOR PTP

;HARDWARE CLOCK DEFINITIONS

	CLKCSR==3760770		;ADDRESS OF DATE/TIME BOARD

;LP20 DEFINITIONS

	LP11CA==3775400			;LP20 DEVICE ADDRESS
	LP11IV==754			;INTERRUPT VECTOR FOR LP20

;RH11 DEFINITIONS

	RH11CA==1776700			;DEVICE ADDRESS OF FIRST RH11
	RH21CA==3772440			;DEVICE ADDRESS OF SECOND RH11
	RH11IV==254			;INTERRUPT VECTOR ADDRESS FOR 1ST RH11
	RH21IV==224			;INTERRUPT VECTOR ADDRESS OF 2ND RH11

;CD20 DEFINITIONS
	CD11BA==3777160			;CD20 DEVICE ADDRESS
	CDRIVT==230			;INTERRUPT VECTOR ADDRESS

;DZ11 DEFINITIONS
	DZ11BA==3760010			;BASE ADDRESS FOR FIRST DZ11
	DZ11IV==340			;INTERRUPT VECTOR ADDRESS FOR FIRST DZ11
;PROCESSOR INSTRUCTIONS

OPDEF APRID [700000,,0]		;GET PROCESSOR SERIAL NUMBER, ETC.
OPDEF WRAPR [700200,,0]		;WRITE APR
OPDEF RDAPR [700240,,0]		;READ APR
OPDEF WRPI [700600,,0]		;WRITE THE PI SYSTEM
OPDEF RDPI [700640,,0]		;READ THE PI SYSTEM
OPDEF WRUBR [701140,,0]		;WRITE THE USER BASE REGISTER
OPDEF CLRPT [701100,,0]		;CLEAR PAGE TABLE ENTRY FOR EFF ADR
OPDEF RDUBR [701040,,0]		;READ THE USER BASE REGISTER
OPDEF WREBR [701200,,0]		;WRITE THE EXEC BASE REGISTER
OPDEF RDEBR [701240,,0]		;READ THE EXEC BASE REGISTER

; OPDEFS FOR KS10 UNIBUS ADAPTER

OPDEF TIOE [710000,,0]		;TEST IO NO MOD SKIP IF EQUAL
OPDEF TIOEB [720000,,0]		;TEST IO BYTE NO MOD SKIP IF EQUAL
OPDEF TION [711000,,0]		;TEST IO NO MOD SKIP IF NOT EQUAL
OPDEF TIONB [721000,,0]		;TEST IO BYTE NO MOD SKIP IF NOT EQUAL
OPDEF RDIO [712000,,0]		;READ I/O
OPDEF RDIOB [722000,,0]		;READ I/O BYTE
OPDEF WRIO [713000,,0]		;WRITE I/O
OPDEF WRIOB [723000,,0]		;WRITE I/O BYTE
OPDEF BSIO [714000,,0]		;BIT SET I/O
OPDEF BSIOB [724000,,0]		;BIT SET I/O BYTE
OPDEF BCIO [715000,,0]		;BIT CLEAR I/O
OPDEF BCIOB [725000,,0]		;BIT CLEAR I/O BYTE
OPDEF WRSPB [702400,,0]		;WRITE SPT BASE REGISTER
OPDEF RDSPB [702000,,0]		;READ SPT BASE REGISTER
OPDEF WRCSB [702440,,0]		;WRITE CORE STATUS TABLE BASE EGISTER
OPDEF RDCSB [702040,,0]		;READ CORE STATUS TABLE BASE REGISTER
OPDEF WRPUR [702500,,0]		;WRITE PROCESS USE REGISTER
OPDEF RDPUR [702100,,0]		;READ PROCESS USE REGISTER
OPDEF WRCSTM [702540,,0]	;WRITE CST MASK REGISTER
OPDEF RDCSTM [702140,,0]	;READ CST MASK REGISTER
OPDEF WRTIME [702600,,0]	;WRITE TIME BASE
OPDEF RDTIME [702200,,0]	;READ TIME BASE
OPDEF WRINT [702640,,0]		;WRITE INTERVAL TIMER
OPDEF RDINT [702240,,0]		;READ INTERVAL TIMER
OPDEF RDHSB [702300,,0]		;READ HALT STATUS BLOCK ADDRESS
OPDEF WRHSB [702700,,0]		;WRITE HALT STATUS BLOCK ADDRESS

;OPDEFS FOR KL10 INSTRUCTIONS WHICH WORK ON THE KS10

	OPDEF	PMOVE	[052B8]	;PHYSICAL MOVE (MAYBE SOMEDAY ...)
	OPDEF	PMOVEM	[053B8]	;PHYSICAL MOVEM
	OPDEF	ADJSP	[105B8]	;ADJUST STACK POINTER
	SOPDEF	PXCT	[XCT]	;PREVIOUS CONTEXT EXECUTE
	OPDEF	DADD	[114B8]	;DOUBLE ADD
	OPDEF	DSUB	[115B8]	;DOUBLE SUB
	OPDEF	DMUL	[116B8]	;DOUBLE MUL
	OPDEF	DDIV	[117B8]	;DOUBLE DIV
	OPDEF	ADJBP	[IBP]	;ADJUST BYTE POINTER

>;END IFN FTKS10
	SUBTTL	EXEC VIRTUAL MEMORY ADDRESSES (PER PROCESS)

;EXEC VIRTUAL MEMORY ADDRESSES (MAPPED THROUGH THE PER PROCESS MAP)

FYSORG==740000			;ORIGIN OF "FUNNY SPACE"
FYSSIZ==30000			;24. PAGES OF FUNNY SPACE

;MAPPINGS FOLLOWING "FUNNY SPACE" (PAGES 770 - 777)

IF1,<IFL <770000-<FYSORG+FYSSIZ>>,<PRINTX ?Funny space overlaps page 770>>

.WSBNZ=:770000			;WSBTAB FOR NON-ZERO SECTIONS
.UPMAP=:.WSBNZ+PAGSIZ		;SECTION 0 USER PAGE MAP
.UPMP=:.UPMAP+PAGSIZ		;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S UPT
.JDAT=:.UPMP+PAGSIZ		;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S JOBDAT
.VJDT=:.JDAT+PAGSIZ		;EXEC VIRTUAL ADDRESS OF THE CURRENT USER'S
				; VESTIGUAL JOBDAT
.TEMP=:.VJDT+PAGSIZ		;EXEC VIRTUAL ADDRESS OF TEMP
				;THIS SLOT USABLE AT UUO LEVEL OR CLOCK LEVEL
				; (UUO LEVEL MUST PRESERVE IF IT BLOCKS AND
				; NEEDS AFTER IT RETURNS)
.JBPK=:.TEMP+PAGSIZ		;EXEC VIRTUAL ADDRESSES USED FOR JOBPEK UUO
.UUPMP=:.JBPK+PAGSIZ		;ADDRESS USED TO REFERENCE CACHED ITEMS
				; IN THE UPT

.MCFV==<HLGPGS+1>*PAGSIZ	;VIRTUAL PAGE NUMBER OF FIRST PAGE OF MONITOR
				; FREE CORE
.UPMVP==.MCFV+.UPMP-FYSORG	;VIRTUAL PAGE NUMBER OF THE UPT
.FPPP==FYSORG			;EXEC VIRTUAL ADDRESS OF FIRST PAGE OF
				; "PER PROCESS" DATA
.FPMC==FYSORG			;EXEC VIRTUAL ADDRESS OF FIRST PAGE OF MONITOR
				; FREE CORE
.LPMC==FYSORG+FYSSIZ		;EXEC VIRTUAL ADDRESS OF FIRST PAGE AFTER
				; MONITOR FREE CORE
NWMCP==.LPMC-.FPMC		;NUMBER OF WORDS OF MONITOR FREE CORE

.LPPP==.UUPMP+PAGSIZ		;EXEC VIRTUAL ADDRESS OF FIRST PAGE AFTER
				; "PER PROCESS" DATA
IFG .LPPP-<1,,0>,<PRINTX ?Funny space exceeds addressing space>
	SUBTTL	EXEC VIRTUAL MEMORY ADDRESSES


;EXEC VIRTUAL MEMORY ADDRESSES (MAPPED THROUGH THE EXEC MAP)

EVAPGS==0			;INIT COUNT OF EXEC VIRTUAL ADDRESS PAGES

EVAPGS==EVAPGS+1		;EXEC VIRTUAL ADDRESS OF SWAPPING CHECKSUM
.ECKSM==FYSORG-<EVAPGS*PAGSIZ>

EVAPGS==EVAPGS+1		;EXEC VIRTUAL ADDRESS TO SET UP .UPMP
.EUPMP==FYSORG-<EVAPGS*PAGSIZ>
.ERPIL==.EUPMP			;USED FOR TEMPORARY MAPPING AT PI LEVEL

;*** ADD NEW EXEC VIRTUAL ADDRESSES HERE

;*** END OF ADDED EXEC VIRTUAL ADDRESSES


;LENGTH OF PAGTAB/MEMTAB/PT2TAB
IFN FTKL10,<PAGTBL==<1_<^D22-^D18>>> ;KL10 SUPPORTS 22 BIT PHYSICAL ADDRESSES
IFN FTKS10,<PAGTBL==<1_<^D20-^D18>>> ;KS10 SUPPORTS 20 BIT PHYSICAL ADDRESSES

IFE FTXMON,<
EVAPGS==EVAPGS+PAGTBL		;EXEC VIRTUAL ADDRESS OF PAGTAB
PAGTAB==:FYSORG-<EVAPGS*PAGSIZ>
EVAPGS==EVAPGS+PAGTBL		;EXEC VIRTUAL ADDRESS OF PT2TAB
PT2TAB==:FYSORG-<EVAPGS*PAGSIZ>
EVAPGS==EVAPGS+PAGTBL		;EXEC VIRTUAL ADDRESS OF MEMTAB
MEMTAB==:FYSORG-<EVAPGS*PAGSIZ>
>; END IFE FTXMON

IFN FTXMON,<
MEMBEG==:0			;STARTING OFFSET IN MS.MEM FOR PAGING TABLES
PAGTAB==:MEMBEG			;PAGTAB ORIGIN
PT2TAB==:PAGTAB+PAGTBL*PAGSIZ	;PT2TAB IMMEDIATELY FOLLOWS PAGTAB
MEMTAB==:PT2TAB+PAGTBL*PAGSIZ	;MEMTAB IMMEDIATELY FOLLOWS PT2TAB
MEMEND==:MEMTAB+PAGTBL*PAGSIZ	;START OF ALLOCATABLE CORE BEYOND PAGING TABLES
MEMWDS==:<MEMEND-MEMBEG>	;NUMBER OF WORDS RESERVED TO PAGING TABLES
MEMPGS==:MEMWDS/PAGSIZ		;NUMBER OF PAGES RESERVED TO PAGING TABLES
IFLE 400K-MEMEND,<
	PRINTX	?PAGTAB/PT2TAB/MEMTAB TABLES EXTEND BEYOND 400K
	PASS2
	END
> ;END IFGE 400K-MEMEND
> ;END IFN FTXMON

IFE FTXMON,<
UMAPS==:.UPMAP			;USER MAPS MAPPED IN THROUGH HERE
>; END IFE FTXMON

IFN FTXMON,<
MMAPS==:700000			;MONITOR SECTIONS MAPPED IN THROUGH HERE
UMAPS==:740000			;USER MAPS MAPPED IN THROUGH HERE
>; END IFN FTXMON
	SUBTTL	EXECUTE PROCESS TABLE LAYOUT

	SECTAB==:540		;SECTION MAP TABLE IN EPT/UPT
IFN FTXMON,MXSECN==37		;MAXIMUM SECTION NUMBER
IFE FTXMON,MXSECN==0

;EXECUTIVE PROCESS TABLE ENTRIES ARE LISTED IN ORDER OF THEIR APPEARANCE
;IN THE EPT (MANY OFFSETS ARE DEFINED BY THE MICROCODE).

	PHASE	0		;ALL ARE OFFSETS

.EPEPT::!			;BEGINNING OF EXEC PROCESS TABLE

IFN FTKL10,<

;LOGOUT AREAS FOR INTERNAL CHANNELS (0-37)

	PHASE	0
.EPLGO::!BLOCK	40		;4 WORDS FOR EACH OF 8 INTERNAL CHANNELS
>; END IFN FTKL10

;LOCAL UUO HANDLER

	PHASE	40
.EPUUO::!BLOCK	1		;LOCAL UUO STORED HERE
.EP41::! BLOCK	1		;DISPATCH TO LOCAL UUO HANDLER

;STANDARD PRIORITY INTERRUPT LOCATIONS (42-57)

	PHASE	42
.EPPII::!BLOCK	1		;PRIORITY INTERRUPT INSTRUCTIONS
	.EPIL==:.EPPII-2	;ORIGIN AS IF THERE WERE A CHANNEL ZERO

IFN FTKL10,<

;CHANNEL FILL WORDS FOR RH20 CHANNELS (60-63) - MUST CONTAINS ZEROES!

	PHASE	60
.EPCFW::!BLOCK	4		;USED BY RH20 WHEN ZERO FILLING
>; END IFN FTKL10

IFN FTKS10,<

;ADDRESSES OF UNIBUS ADAPTER INTERRUPT VECTOR TABLES (101-107)

	PHASE	101
.EPVIT::!BLOCK	7		;SPACE FOR UP TO 7 UNIBUS ADAPTERS
>; END IFN FTKS10

IFN FTKL10,<

;SCRATCH BUFFER TO OBTAINING DATE/TIME FROM FRONT-END (135-137)
;(CAN GO ANYWHERE IN EPT)

	PHASE	135
.EPDTM::!BLOCK	3		;3 WORDS

;FOUR DTE20 CONTROL BLOCKS (140-177)

	PHASE	140
.EPDCB::!BLOCK	^D8*4		;8 WORDS FOR EACH OF 4 DTE20S
>; END IFN FTKL10
;EXECUTIVE TRAP LOCATIONS (421-423)

	PHASE	421
.EPETL::!			;BEGINNING OF EXECUTIVE TRAP LOCATIONS
.EPAOV::!BLOCK	1		;EXECUTIVE ARITHMETIC OVERFLOW INSTRUCTION
.EPPOV::!BLOCK	1		;EXECUTE PUSHDOWN LIST OVERFLOW INSTRUCTION
.EPTP3::!BLOCK	1		;TRAP 3 TRAP INSTRUCTION

IFN FTKS10,<

;HALT STATUS BLOCK (424-445)
;CAN GO ANYWHERE IN EPT

	PHASE	424
.EPHSB::!BLOCK	^D18		;HALT STATUS AREA WRITTEN BY FRONT-END
>; END IFN FTKS10

IFN FTKL10,<

;DTE CONTROL AREA FOR DIAGNOSTIC UTILITIES (440-443)

	PHASE	440
.EPDDG::!			;BEGINNING OF DTE DIAGNOSTIC UTILITY AREA
.EPDDS::!BLOCK	1		;DIAGNOSTIC START
.EPDDT::!BLOCK	1		;DDT START
.EPDSL::!BLOCK	1		;START LOADER (BOOT)
.EPDSM::!BLOCK	1		;START MONITOR

;SECONDARY PROTOCOL COMMUNICATIONS AREA (444-456)

	PHASE	444
.EPDSC::!BLOCK	^D11		;11 WORDS FOR THE MASTER FRONT-END

;TIME BASE/PERFORMANCE ANALYSIS COUNTS (510-513)

	PHASE	510
.EPTMB::!BLOCK	2		;2 WORD TIME BASE
.EPPAC::!BLOCK	2		;2 WORD PERFORMANCE ANALYSIS COUNT

;INTERVAL TIMER INTERRUPT INSTRUCTION (514)

	PHASE	514
.EPTII::!BLOCK	1		;XPCW TO INTERRUPT HANDLER
>; END IFN FTKL10

;SECTION TABLE (540-577)

	PHASE	SECTAB
.EPSTB::!BLOCK	MXSECN+1	;SPACE FOR ALL SECTION POINTERS

IFN FTKL10,<

;CONSTANTS USED BY MICROCODE FOR OWGBP

	PHASE	700
.EPOWG::!BLOCK	^D19		;TABLE OF CONSTANTS FOR MICROCODE
>; END IFN FTKL10

	DEPHASE
	SUBTTL	USER PROCESS TABLE LAYOUT

;USER PROCESS TABLE ENTRIES ARE LISTED IN ORDER OF THEIR APPEARANCE
;IN THE UPT (MANY OFFSETS ARE DEFINED BY THE MICROCODE).

;PUSH DOWN LIST (0 - 217)

JOBPDO=.UUPMP+0			;ORIGIN OF THE PUSH DOWN LIST
PDLLEN==217			;LENGTH OF THE PUSH DOWN LIST
				; **********
				; PDLLEN MUST BE DEFINED SO THAT
				; USRHCU AND USRPC DO NOT FALL IN THE
				; SAME 8 WORD CACHE BLOCK
				; IF PDLLEN IS INCREASED, INCREASE
				; IT BY A MULTIPLE OF 8 WORDS.
				; **********
EPDLEN==50			;SIZE OF EMERGENCY PDL
				;***MUST BE MULTIPLE OF 8 (SEE ABOVE)***

JOBPRO==JOBPDO+PDLLEN+EPDLEN-<.UUPMP-.UPMP> ;ORIGIN OF THE 'PROTECTED JOB DATA AREA'
PRTLEN==114-70			;LENGTH OF THE 'PROTECTED JOB DATA AREA'

;BEGINNING OF FIRST USER PROCESS TABLE VARIABLE AREA (303 - 417)

	PHASE	JOBPRO+PRTLEN-.UPMP

.UPLPS:!BLOCK	1
.USLPS=:.UPMP+.UPLPS		;PAGE NUMBER ON A SWAP IN/OUT

.UPSLX:!BLOCK	1		;RH=SWPLST INDEX - USED WHEN STARTING PAGING
.USSLX=:.UPMP+.UPSLX		; I/O AT UUO LEVEL

.UPFFT:!BLOCK	1		;VIRTUAL TIME OF FIRST PAGE FAULT
.USFFT=:.UPMP+.UPFFT
.UPLFT:!BLOCK	1		;VIRTUAL TIME OF LAST FAULT
.USLFT=:.UPMP+.UPLFT
.UPVCT:!BLOCK	1		;COUNT OF TOTAL FAULTS FOR JOB
.USVCT=:.UPMP+.UPVCT		;LH="REAL" FAULTS, RH= COUNT OF FAULTS WHEN
				; THE PAGE IS IN CORE, PM.ACC=0
.UPREL:!BLOCK	1		;HIGHEST LOC GOTTEN BY COR UUO OR COMMAND
.USREL=:.UPMP+.UPREL		; IF JOB IS HOLEY

.UPNXP:!BLOCK	1		;PAGE RANGE SPECIFIED IN PAGE UUO ARGUMENT LIST
.USNXP=:.UPMP+.UPNXP
.UPJOB:!BLOCK	1		;JOB NUMBER
.USJOB=:.UPMP+.UPJOB
.UPMEM:!BLOCK	1		;TOTAL VIRTUAL MEMORY A JOB HAS
.USMEM=:.UPMP+.UPMEM		; (OR 0 IF NOT VIRTUAL)
.UPVRT:!BLOCK	1		;NON-0 IF JOB IS VIRTUAL(HAS DSK ADDRESS IN MAP)
.USVRT=:.UPMP+.UPVRT		;LH FOR HI-SEG, RH FOR LOW SEG

.UPBTS:!BLOCK	1		;RANDOM COLLECTION OF BITS
.USBTS=:.UPMP+.UPBTS
	UP.BIG==1B0		;USER IS EXTENDED (MUST BE SIGN)
	UP.WHC==1B1		;WORKING SET HAS CHANGED
	UP.MGP==1B2		;MONITOR GOT PFH
	UP.GET==1B3		;RUNNING GET TO GET A PROGRAM TOO BIG TO FIT IN CORE
	UP.SAA==1B4		;SET ACCESS ALLOWED AUTOMATICALLY
	UP.CSP==1B5		;CORE IMAGE (MAY) CONTAIN SPY PAGES
	UP.MPF==1B6		;MERGING PFH - ON SO PFH DOESN'T GET PAGED OUT
	UP.MMO==1B7		;THIS JOB OWNED AND GAVE UP THE MM RESOURCE
				; OVER A CALL TO THE SCHEDULAR
	UP.PGB==1B8		;ON IF PAGING I/O PAGES HAVE NOT BEEN GIVEN BACK
	UP.IYB==1B9		;IN YOUR BEHALF PPN SPECIFIED (FOR IPCSER)
	UP.WSS==1B10		;WORKING SET IS SCRAMBLED
	UP.DST==1B11		;DON'T PUT TERMINAL AT MONITOR LEVEL (HNGSTP)
	UP.CXO==1B12		;CORE IMAGE (AS OPPOSED TO HIGH SEGMENT) IS XO
	UP.FIP==1B13		;FILOP IN PROGRESS
	UP.DDW==1B14		;DON'T DIDDLE WORKING SET (MIGRAT)
	UP.NZS==1B16		;NEED TO SWAP IN NON-ZERO SECTIONS (BISLST)
	UP.MAP==1B16		;CURRENT SWPLST ENTRY HAS MAP INFO IN IT
	UP.CTX==1B17		;RUN UUO CALLED BY CONTEXT UUO
	UP.SWF==1B18		;SET WATCH FILES ALREADY TYPED
	UP.JXP==1B19		;(MAPBAK) CALL XPANDH WHEN DONE
	UP.EPL==1B20		;IN EMERGENCY PDL CODE, CAN'T EXTEND STACK
	UP.NVS==1B21		;JOB WAS VIRTUAL ON LAST SWAPIN, THERE ARE
				; DISK ADDRESSES FOR WRITE LOCKED PAGES
	UP.MLB==1B22		;MERGE LAST BLOCK INTO OUTPUT BUFFER
.UPANA:!BLOCK	1		;COUNT OF NON-ACCESSABLE PAGES
.USANA=:.UPMP+.UPANA
.UPICT:!BLOCK	1		;INCREMENTAL COUNT OF PAGE FAULTS
.USICT=:.UPMP+.UPICT
.UPPFH:!BLOCK	1		;COPY OF .JBPFH ON SWAP OUT (USED IF FTDHIA=-1)
.USPFH=:.UPMP+.UPPFH
.UPFOP:!BLOCK	1		;USED BY FILOP. TO RECOVER FROM A PAGE FAIL
.USFOP=:.UPMP+.UPFOP
.UPHVA:!BLOCK	1		;USED FOR ADDRESS CHECKING AT INTERRUPT LEVEL
.USHVA=:.UPMP+.UPHVA
.UPLST:!BLOCK	1		;LH POINTER TO SWAPPABLE DDBS
.USLST=:.UPMP+.UPLST		;RH POINTER TO SAVED CONTEXT BLOCK IN FUNNY SPACE

.UPFCC:!BLOCK	1		;HEADER FOR CACHED (KI TOO) FREE SPACE
.USFCC=:.UPMP+.UPFCC		;LH USED FOR TMPCOR FILE POINTERS

.UPFCU:!BLOCK	1		;HEADER FOR UNCACHED (KL ONLY) FREE SPACE
.USFCU=:.UPMP+.UPFCU		;LH KEEPS TRACK OF LARGEST HOLE

.UPFCD:!BLOCK	1		;HEADER FOR RESTRICTED FREE SPACE
.USFCD=:.UPMP+.UPFCD
.UPSWI==.UPFCD			;LH IS POINTER TO CORE COPY OF SWITCH.INI
.USSWI=:.UPMP+.UPSWI
.UPLNM:!BLOCK	1		;RH=POINTER TO LOGICAL NAME SPACE
.USLNM=:.UPMP+.UPLNM		;LH=T4

.UPCTA:!BLOCK	1		;RH=POINTER TO EXTENDED CHANNEL TABLE
.USCTA=:.UPMP+.UPCTA
.UPMBF:!BLOCK	1		;ADDRESS OF MONITOR BUFFER
.USMBF=:.UPMP+.UPMBF

.UPLBF:!BLOCK	1		;FLAG FOR USE OF EXTRA PAGE FOR DIRECTORY
.USLBF=:.UPMP+.UPLBF		;SEARCHES - 0=DONT GET, POSITIVE=CAN GET,
				;NEGATIVE=IOWD FOR IT

.UPSBF:!BLOCK	1		;SAVED .UPMBF WHEN DOING 4-BLOCK READ
.USSBF=:.UPMP+.UPSBF
.UPSPT:!BLOCK	1		;CURRENT SECTION POINTER (BISLST)
.USSPT=:.UPMP+.UPSPT

.UPNCR:!BLOCK	1		;# OF "CORE" PAGES IN NZS
.USNCR=:.UPMP+.UPNCR
.UPSCT:!			;ARRAY OF COUNTERS FOR # PGS IN SECTION (9-BITS)
	UP.SCS==^D18		;SIZE OF COUNTER BYTE
	UP.VRG==400000		;VIRGIN MAP BIT

	BLOCK	<<MXSECN/<^D36/UP.SCS>>-1+IFN <MXSECN-<MXSECN/<^D36/UP.SCS>>*<^D36/UP.SCS>>,<1>+1>
.USSCT=:.UPMP+.UPSCT		;NONE FOR SECTION 0
.UPSCE==.-1
.USSCE=:.UPMP+.UPSCE

.UPPFF:!BLOCK	1		;PFH PAGE FAULT PC FLAGS
.USPFF=:.UPMP+.UPPFF

.UPPFC:!BLOCK	1		;PFH PAGE FAULT PC COUNTER
.USPFC=:.UPMP+.UPPFC

.UPPFL:!BLOCK	1		;LAST PAGE PAGED OUT BY PFH
.USPFL=:.UPMP+.UPPFL

.UPPFU:!BLOCK	1		;COUNT OF PAGE-FAULTS FOR CURRENT UUO.
.USPFU=:.UPMP+.UPPFU

.UPUSN:!BLOCK	1		;SECTION NUMBER READ AS AN ARGUMENT FROM /USE
				; SWITCH ON AN R, RUN, GET, OR MERGE COMMAND
.USUSN=:.UPMP+.UPUSN

.UPUSA:!BLOCK	1
.USUSA=:.UPMP+.UPUSA		;PROGRAM START ADDRESS

.UPEPL:!BLOCK	1		;EXTENDED PUSHDOWN POINTER
.USEPL=:.UPMP+.UPEPL
.UPUAC:!BLOCK	20		;BLOCK OF 20 ACS USED TO SAVE JOBS ACS
.USUAC=:.UPMP+.UPUAC		; WHILE GETTING PFH.EXE

.UPLPG:!BLOCK	1		;QUEUE OF LOCKED PAGES
.USLPG=:.UPMP+.UPLPG

.UPWLP:!BLOCK	1		;NUMBER OF WRITE LOCKED PAGES IN THE WORKING SET
.USWLP=:.UPMP+.UPWLP

.UPWLC:!BLOCK	1		;COUNT OF USER WRITE-LOCKED PAGES
.USWLC=:.UPMP+.UPWLC

.UPEND==.-1
.USEND=:.UPMP+.UPEND
	DEPHASE
IFGE <.UPEND-420>,<PRINTX ?UPMP DATA TOO LARGE, OVERLAPS TRAP LOCATIONS>
;TRAP INSTRUCTIONS/NEW PC WORDS (420 - 437)

.UPTVC==420			;LOCATION OF TRAP VECTOR
.USTVC=:.UPMP+.UPTVC
.UPPFT==420			;LOCATION OF USER PAGE FAULT TRAP INSTRUCTION
.USPFT=:.UPMP+.UPPFT
.UPAOT==421			;LOCATION OF USER ARITHMETIC TRAP INSTRUCTION
.USAOT=:.UPMP+.UPAOT
.UPPDT==422			;LOCATION OF USER PUSH DOWN LIST OVERFLOW TRAP
.USPDT=:.UPMP+.UPPDT		; INSTRUCTION
.UP03T==423			;LOCATION OF USER TRAP 3 INSTRUCTION
.US03T=:.UPMP+.UP03T
	UP.PFT==0		;PAGE FAIL TRAP MUUO
	UP.AOT==1		;ARITHMETIC TRAP UO
	UP.PDT==2		;PUSH DOWN LIST OVERFLOW TRAP MUUO
	UP.03T==3		;TRAP 3 TRAP UUO
	UE.PFT==4		;USER ENABLED PAGE FAIL TRAP MUUO
	UE.AOT==5		;USER ENABLED ARITHMETIC TRAP MUUO
	UE.PDT==6		;USER ENABLED PDL OVERFLOW TRAP MUUO
	UE.03T==7		;USER ENABLED TRAP 3 TRAP MUUO
	UI.PFT==10		;PSI PAGE FAULT TRAP MUUO
	UI.AOT==11		;PSI ARITHMETIC TRAP MUUO
	UI.PDT==12		;PSI PDL OVERFLOW TRAP MUUO
	UI.03T==13		;PSI TRAP 3 TRAP MUUO
	UP.MLT==11		;MAXIMUM LEGAL TRAP NUMBER
.UPMUO==424			;LOCATION OF MUUO
.USMUO=:.UPMP+.UPMUO
.UPMUP==425			;LOCATION OF MUUO PC
.USMUP=:.UPMP+.UPMUP
.UPMUE==426			;MUUO EFFECTIVE ADDRESS CALCULATION
.USMUE=:.UPMP+.UPMUE
.UPEPF==426			;LOCATION OF EXEC PROCESS CONTEXT WORD
.USEPF=:.UPMP+.UPEPF
.UPUPF==427			;LOCATION OF MUUO PROCESS CONTEXT WORD
.USUPF=:.UPMP+.UPUPF
.UPMTS==430			;START OF MUUO TRAP VECTOR
.USMTS=:.UPMP+.UPMTS
.UPMTE==437			;END OF MUUO TRAP VECTOR
.USMTE=:.UPMP+.UPMTE

;WORKING SET BIT TABLE (440 - 457)

WSBTAB=:.UPMP+440		;BIT-TABLE FOR WORKING SET
WSBTBL==<^D512+FYSSIZ/PAGSIZ+MXSECN+1+^D35>/^D36 ;LENGTH OF WORKING SET BIT TABLE

;460 - 477 IS RESERVED BUT AVAILABLE FOR USE
;PAGE FAIL STUFF (500 - 503)

.UPPFW==500			;PAGE FAIL WORD
.USPFW=:.UPMP+.UPPFW
.UPPFP==501			;PAGE FAIL FLAGS/OLD PC DOUBLEWORD
.USPFP=:.UPMP+.UPPFP
.UPPFN==503			;PAGE FAIL NEW PC WORD
.USPFN=:.UPMP+.UPPFN

;KL10 EBOX/MBOX COUNTERS (504 - 507)

.LMEBH==504			;(KL10)HIGH ORDER PART OF EBOX CYCLE METER
.LMEBL==505			;(KL10)LOW ORDER PART OF EBOX CYCLE METER
.LMMBH==506			;(KL10)HIGH ORDER PART OF MBOX CYCLE METER
.LMMBL==507			;(KL10)LOW ORDER PART OF MBOX CYCLE METER

;510 - 537 IS RESERVED BUT AVAILABLE FOR USE

;TABLE OF SECTION MAP POINTERS (540 - 577)

;SECTAB==540			;LOCATION OF THE SECTION TABLE

;BEGINNING OF SECOND USER PROCESS TABLE VARIABLE AREA

	PHASE	600		;START SECOND VARIABLE AREA FOLLOWING SECTAB

.UPTMP:!BLOCK	6		;6 LOCATIONS USED AS TEMPORARIES WHILE SWAPPING
.USTMP=:.UPMP+.UPTMP		; (USED ON A FRAGMENTED SWAP)

.UPTMU:!BLOCK	2		;UUO LEVEL TEMPS (E. G. PLTSN)
.USTMU=:.UPMP+.UPTMU

.UPCDB:!BLOCK	4		;MAPPING POINTERS FOR CURRENT CPU'S CDB
.USCDB=:.UPMP+.UPCDB		; (FOR SPY PAGES) - HOPE CDB NEVER EXCEEDS 4 PAGES

.UPPAT:!BLOCK	1		;AREA FOR PATCHING
.USPAT=:.UPMP+.UPPAT

.UPEN2==.-1			;END OF SECOND VARIABLE AREA
.USEN2=:.UPMP+.UPEN2
	DEPHASE
IFGE <.UPEN2-FYSORG/PAGSIZ>,<PRINTX ?UPMP DATA TOO LARGE, OVERLAPS MAPPING LOCATIONS>

;LOCATIONS IN THE UPT USED FOR MAPPING

.UMORG==FYSORG/PAGSIZ		;MAP SLOTS ARE AT THE END

.UMWSB==.UMORG+<.WSBNZ-FYSORG>/PAGSIZ	;.WSBNZ
.UMJBK==.UMORG+<.JBPK-FYSORG>/PAGSIZ	;JOBPEK
.UMTMP==.UMORG+<.TEMP-FYSORG>/PAGSIZ	;JOBPEK ETC. TEMP
.UMVJD==.UMORG+<.VJDT-FYSORG>/PAGSIZ	;.VJDT
.UMJDT==.UMORG+<.JDAT-FYSORG>/PAGSIZ	;.JDAT
.UMUPT==.UMORG+<.UPMP-FYSORG>/PAGSIZ	;UPT
.UMUPM==.UMORG+<.UPMAP-FYSORG>/PAGSIZ	;CURRENT SECTION MAP
.UMUUP==.UMORG+<.UUPMP-FYSORG>/PAGSIZ	;CACHED UPT SLOT

UPGWID==44-^L<MXSECN+1>-1+9	;WIDTH OF FIELD CONTAINING VIRTUAL PAGE NUMBER
REPEAT 0,<
;NOTE THAT THE SOURCES HAVE BEEN EDITED SO THAT THESE TESTS NO LONGER APPEAR
	SUBTTL	FEATURE TEST SWITCHES WHICH MUST BE ON

;LIST OF INDEPENDENT MONITOR COMMAND FEATURES
;WILL BE FOUND IN FILE F.MAC. THOSE FEATURE TEST SWITHCES
;WHICH MUST BE ON ARE FOUND HERE.

; ( -1 MEANS INCLUDE THE ASSOCIATED FEATURE, 0 MEANS ELIMINATE IT )

XP FTSWAP,-1	;SWAPPING SYSTEM
		;IF FTSWAP=-1, THEN FTDISK MUST BE -1
		; APPEARS IN CLOCK1, COMCON, COMMON, CORE1, DPCINT, DPCREF,
		;  DPDINT, DPDREF, DSKSER, DTASRN, FHDINT, FHDREF, MDFINT,
		;  MDFREF, SCHED, SCNSRH, SEGCON, SYSINI, AND UUOCON.

XP FTDISK,-1	;DISK SYSTEM (MAY OR MAY NOT HAVE SWAPPING)
		;IF FTDISK=-1, THEN FTLOGIN MUST BE -1
		;IF FTSWAP=-1, THEN FTDISK MUST BE -1
		; APPEARS IN CLKCSS, COMCON, COMMON, ONCE, SCHED, SEGCON,
		;  SYSINI, AND UUOCON.

XP FTLOGIN,-1	;LOGIN-LOGOUT COMMAND AND UUOS
		;FTDISK=-1 IMPLIES FTLOGIN=-1
		; APPEARS IN CLOCK1, COMCON, SCNSRF, SCNSRH, AND UUOCON

XP FTCCL,-1	;CONCISE COMMAND LANGUAGE COMMANDS
		;SHOULD BE 0 IN NON-DISK SYSTEMS
		;SHOULD BE -1 IN DISK SYSTEMS, WHEN IMPLEMENTED
		; APPEARS IN COMCON
>;END REPEAT 0
XP FTVM,-1	;ONLY DEFINED SO THAT JOBDAT ASSEMBLES CORRECTLY
	SUBTTL	SYSTEM MACROS -- GENERAL

;MACROS TO CONVERT FROM DOUBLE WORD TO SINGLE WORD PCS AND VICE-VERSA

DEFINE	GETPC	(AC,LOC)<
	SALL
	PUSHJ	P,[	MOVE	AC,LOC+1
;			TLNE	AC,7777
;			STOPCD	.+1,DEBUG,NZS,
			HLL	AC,LOC
			POPJ	P,]

>
DEFINE	GETPCS	(AC,LOC)<
	SALL
	PUSHJ	P,[	AOS	(P)
			MOVE	AC,LOC+1
;			TLNE	AC,7777
;			STOPCD	.+1,DEBUG,NZS,
			HLL	AC,LOC
			POPJ	P,]

>
DEFINE	PUTPC	(AC,LOC)<
	SALL
	PUSHJ	P,[	HLLZM	AC,LOC
			HRRZM	AC,LOC+1
			POPJ	P,]

>

;MACRO TO MAKE IT EASY TO USE "POPM" IF IT EVER GETS IMPLEMENTED
DEFINE	RETSKP,<
	IFNDEF	CPOPJ1,<EXTERNAL CPOPJ1>
	JRST	CPOPJ1
>

;MACRO TO PREVENT SCHEDULING, USED AT UUO LEVEL WHEN A
;REENTRANT ROUTINE IS CHANGING COMMON DATA NOT YET
;ASSIGNED TO A PARTICULAR JOB

DEFINE NOSCHED
<>

;MACRO TO ALLOW SCHEDULING ONCE MORE

DEFINE SCHEDULE
<>
;MACRO TO PREVENT INTERRUPTS ON A CPU-BASIS
DEFINE	SYSPIF<
IFNDEF LOKSPI,<EXTERN LOKSPI>
	PUSHJ	P,LOKSPI
>

;MACRO TO REENABLE INTERRUPTS ON A CPU-BASIS
DEFINE	SYSPIN(A)<
IFNDEF UNLSPI,<EXTERN UNLSPI,UNLSPT>
IFB <A><PUSHJ P,UNLSPI>
IFNB <A><PUSHJ P,UNLSPT
	CONO PI,PI.ON+A>
>

;MACRO TO PREVENT INTERRUPTS ON A DEVICE-BASIS
DEFINE PIOFF<
IFNDEF LOKDPI,<EXTERN LOKDPI>
	PUSHJ	P,LOKDPI
>

;MACRO TO REENABLE INTERRUPTS ON A DEVICE-BASIS
DEFINE PION<
IFNDEF UNLDPI,<EXTERN UNLDPI>
	PUSHJ	P,UNLDPI
>

;MACRO TO PREVENT INTERRUPTS FOR BIT DIDDLERS (SETOS,CLRBTS)
DEFINE	BTSOFF,<
IFNDEF LOKBTI,<EXTERNAL LOKBTI>
	PUSHJ	P,LOKBTI
>

;MACRO TO REENABLE INTERRUPTS FOR BIT DIDDLERS
DEFINE	BTSON,<
IFNDEF UNLBTI,<EXTERNAL UNLBTI>
	PUSHJ	P,UNLBTI
>

;MACRO TO INTERLOCK BUFFER MANAGEMENT (CACHE)
DEFINE	NBFOFF,<
IFN FTKL10,<
IFNDEF	LOKNBI,<EXTERNAL LOKNBI>
	PUSHJ	P,LOKNBI
>>

;MACRO TO FREE UP BUFFER MANAGEMENT INTERLOCK
DEFINE NBFON,<
IFN FTKL10,<
IFNDEF	UNLNBI,<EXTERNAL UNLNBI>
	PUSHJ	P,UNLNBI
>>

;MACRO TO INTERLOCK ETHERNET DATA STRUCTURES
DEFINE	ETHLOK,<
IFNDEF LOKETH,<EXTERNAL LOKETH>
	PUSHJ	P,LOKETH
>; END DEFINE ETHLOK

;MACRO TO RELEASE ETHERNET INTERLOCK
DEFINE	ETHULK,<
IFNDEF UNLETH,<EXTERNAL UNLETH>
	PUSHJ	P,UNLETH
>; END DEFINE ETHULK
IFN FTMP,<
;MACRO TO PREVENT DDB-SCAN RACES
DEFINE DDBSRL,<
IFNDEF DDBLOK,<EXTERNAL DDBLOK>
	PUSHJ	P,DDBLOK
> ;END DEFINE DDBSRL

;MACRO TO UNLOCK DDB-SCAN
DEFINE DDBSRU<
IFNDEF	DDBULK,<EXTERNAL DDBULK>
	PUSHJ	P,DDBULK
> ;END DEFINE DDBSRU
>;END IFN FTMP
IFE FTMP,<
DEFINE DDBSRL<>
DEFINE DDBSRU<>
>;END IFN FTMP

IFN FTMP,<
;GENERAL UUO-LEVEL LOCK
DEFINE	UUOLOK<
	SKIPGE	INTRUU##
	AOSE	INTRUU##
	JRST	.-2
	APRID	INTOUU##
>
DEFINE	UUONLK<
	SETOM	INTRUU##
	SETOM	INTOUU##
>
>
IFE FTMP,<
DEFINE	UUOLOK<>
DEFINE	UUONLK<>
>
IFN FTMP,<
;INTERLOCK ON CLOCK QUEUE PROCESSING
DEFINE	CLKLOK<
	SKIPGE	INTRCL##
	AOSE	INTRCL##
	JRST	.-2
	APRID	INTOCL##
>
DEFINE	CLKNLK<
	SETOM	INTRCL##
	SETOM	INTOCL##
>
>
IFE FTMP,<
DEFINE	CLKLOK<>
DEFINE	CLKNLK<>
>
;INTERLOCK ON EMERGENCY PROCESSING
IFN FTMP,<
DEFINE	DIELOK<
IF2,IFNDEF LOKDIE,<EXTERN LOKDIE>
	PUSHJ	P,LOKDIE	;;GET THE INTERLOCK
>; END DEFINE DIELOK

DEFINE	DIENLK<
IF2,IFNDEF ULKDIE,<EXTERN ULKDIE>
	PUSHJ	P,ULKDIE	;;RELEASE THE INTERLOCK
>; END DEFINE DIENLK
>; END IFN FTMP
IFE FTMP,<
DEFINE	DIELOK<>
DEFINE	DIENLK<>
>
	SUBTTL	SYSTEM MACROS -- AIDS TO EXTENDED ADDRESSING

;THESE MACROS ARE DEFINED TO PRODUCE CODE THAT CAN RUN UNDER BOTH
;KL PAGING AND KI PAGING. UNDER KI PAGING THEY WILL PRODUCE CODE
;WHICH WILL RUN IN SECTION 0, AND UNDER KL PAGING THEY WILL PRODUCE
;CODE WHICH RUNS IN AN EXTENDED SECTION. NOTE THAT IF KL PAGING IS
;ON, THE CODE MUST BE EXECUTED IN AN EXTENDED SECTION.

	SOPDEF	IFIW	[1B0]		;INSTRUCTION FORMATTED INDIRECT WORD
	OPDEF	XMOVEI	[SETMI]		;MOVEI WITH PC SECTION NUMBER

;MACRO TO DEFINE AN INDIRECT WORD. IN KI PAGING, IT GENERATES AN ORDINARY
;STANDARD INSTRUCTION FORMATTED INDIRECT WORD, AND IN KL PAGING IT GENERATES
;A FULL GLOBAL INDIRECT WORD.
;	SECTION CAN BE ANY SECTION NUMBER (LH) BETWEEN 0 AND 37
;	ADDR CAN BE ANY 18 BIT ADDRESS PLUS INDIRECTION AND INDEXING.

IFE FTXMON,<DEFINE IW(SECTION,ADDR),<Z ADDR>>
IFN FTXMON,<DEFINE IW(SECTION,ADDR),<SALL
	EA==<Z ADDR>
	IFN <SECTION&<777740,,777777>>!<EA&<777740,,0>>,<
		PRINTX ?INVALID INDIRECT WORD SECTION,ADDR
		EXP 0,,0 ;;GENERATE Q ERROR
		>
	IDX==<<EA&<37,,0>>_-22>
	OFS==<EA&777777>
	EXP <<IDX>B5!<SECTION+<OFS>B35>>
	PURGE EA,OFS,IDX
	>;END DEFINE IW
>; END IFN FTXMON

;MACRO TO SET SET THE AC FIELD FOR A GLOBAL INDEX WORD

IFN FTXMON,<
	DEFINE	GIDX(AC)<<AC>B5>
	>

IFE FTXMON,<
	DEFINE	GIDX(AC)<<AC>B17>
	>

;MACRO TO CALL A SUBROUTINE IN SECTION 0, RETURNING TO THE CURRENT
;SECTION WHEN DONE. IN KI PAGING THIS RESOLVES TO A PUSHJ.

IFE FTXMON,<DEFINE S0PSHJ(ADDR),<PUSHJ P,ADDR>>
IFN FTXMON,<DEFINE S0PSHJ(ADDR),<SALL
	IFNDEF SSEC0,<EXTERN SSEC0>
	PUSHJ	P,[PUSHJ P,SSEC0
		JRST ADDR]
		>;END DEFINE S0PSHJ
>;END IFN FTXMON

;MACRO TO CALL A SUBROUTINE IN SECTION 1, RETURNING TO CURRENT CONTEXT
;WHEN DONE

IFE FTXMON,<DEFINE S1PSHJ(ADDR),<PUSHJ P,ADDR>>
IFN FTXMON,<DEFINE S1PSHJ(ADDR),<SALL
	IFNDEF SSEC1,<EXTERN SSEC1>
	PUSHJ	P,[PUSHJ P,SSEC1
		   JRST	 ADDR]
		>;END DEFINE S1PSHJ
>;END IFN FTXMON

;MACRO TO PJRST TO A SUBROUTINE IN SECTION 0. SAME AS S0PSHJ BUT
;DOES A PJRST INSTEAD OF A PUSHJ.

IFE FTXMON,<DEFINE S0JRST(ADDR),<JRST ADDR>>
IFN FTXMON,<DEFINE S0JRST(ADDR),<SALL
	IFNDEF SSEC0,<EXTERN SSEC0>
	JRST	[PUSHJ P,SSEC0
		JRST ADDR]
	>;END DEFINE S0JRST
>;END IFN FTXMON


;MACRO TO DO ONE INSTRUCTION IN SECTION 1 AND RETURN TO SECTION 0

IFE FTXMON,<DEFINE SE1XCT(INSTR),<INSTR>>
IFN FTXMON,<DEFINE SE1XCT(INSTR),<SALL
	IFNDEF SSEC1,<EXTERN SSEC1>
	IFNDEF CPOPJ1,<EXTERN CPOPJ1>
	PUSHJ	P,[PUSHJ P,SSEC1
		INSTR
		  POPJ P,
		JRST CPOPJ1]
	>;END DEFINE SE1XCT
>;END IFN FTXMON

;MACRO TO CALL A SUBROUTINE IN SECTION SN, RETURNING TO THE CURRENT
;SECTION WHEN DONE. IN KI PAGING THIS RESOLVES TO A PUSHJ.

IFE FTXMON,<
DEFINE SNCALL(ADDR,SN),<
.IFN SN,ABSOLUTE,<PRINTX ?Illegal section argument 'SN' to SNCALL 'ADDR'>
IFN SN&<0,,-1>,<PRINTX ?Illegal section argument 'SN' to SNCALL 'ADDR'>
	PUSHJ P,ADDR>>

IFN FTXMON,<
DEFINE SNCALL(ADDR,SN),<SALL
.IFN SN,ABSOLUTE,<PRINTX ?Illegal section argument 'SN' to SNCALL 'ADDR'>
IFN SN&<0,,-1>,<PRINTX ?Illegal section argument 'SN' to SNCALL 'ADDR'>
	IFNDEF SENCAL,<EXTERN SENCAL>
	XCT	[PUSHJ P,SENCAL
		SN+<EXP ADDR&777777>]
		>;END DEFINE SNCALL
>;END IFN FTXMON


;MACRO TO CALL A SUBROUTINE IN DECNET CONTEXT.  APPLIES ONLY TO UNEXTENDED
;SYSTEMS.
IFN FTXMON,<DEFINE DNCALL(ADDR),<PRINTX ? DNCALL is inconsistent with FTXMON>>
IFE FTXMON,<DEFINE DNCALL(ADDR),<SALL
REPEAT 0,<
	IFNDEF DNXCAL,<EXTERN DNXCAL>
	XCT	[PUSHJ P,DNXCAL
		 JUMP	ADDR]
>; END REPEAT 0
	PUSHJ	P,ADDR
		>;END DEFINE DNCALL
>;END FTXMON


;MACRO TO CALL A SUBROUTINE IN REGULAR CONTEXT.  APPLIES ONLY TO UNEXTENDED
;SYSTEMS.
IFN FTXMON,<DEFINE RGCALL(ADDR),<PRINTX ? RGCALL is inconsistent with FTXMON>>
IFE FTXMON,<DEFINE RGCALL(ADDR),<SALL
REPEAT 0,<
	IFNDEF RGXCAL,<EXTERN RGXCAL>
	XCT	[PUSHJ P,RGXCAL
		 JUMP	ADDR]
>; END REPEAT 0
	PUSHJ	P,ADDR
		>;END DEFINE RGCALL
>;END FTXMON
;COMMON SUBROUTINE ENTRY - ROUTINE CALLABLE FROM ANY CODE SECTION,
;EXECUTES IN REGULAR HIGH SEGMENT (SECTION 1).

DEFINE	$CSENT(NAME,%DUMMY),<

	$CSUB			;;SWITCH TO COMMON ENTRY PSECT
NAME				;;HOPE YOU INCLUDED COLONS IN DEFINITION!
IFN FTXMON,<			;;IF EXTENDED MONITOR
	SE1ENT			;;MAKE SURE RETURN IN S0 IF CALLED FROM THERE
	XJRST	.+1		;;ENTER HIGH SEGMENT
	MCSEC1+%DUMMY		;;BRANCH ADDRESS
	$HIGH			;;SWITCH INTO HIGH SEGMENT
%DUMMY:				;;EXECUTION CONTINUES HERE IN SECTION 1
>;; END IFN FTXMON

>; END DEFINE $CSENT


;EXTENDED SUBROUTINE ENTRY - ROUTINE CALLABLE FROM ANY CODE SECTION,
;EXECUTES IN EXTENDED HIGH SEGMENT (SECTION 2)

DEFINE	$XSENT(NAME,%DUMMY),<

	$CSUB			;;SWITCH TO GLOBAL ENTRY PSECT
NAME				;;HOPE YOU INCLUDED COLONS IN DEFINITION!
IFN FTXMON,<			;;IF EXTENDED MONITOR
	SE1ENT			;;MAKE SURE RETURN IN S0 IF CALLED FROM THERE
	XJRST	.+1		;;ENTER EXTENDED HIGH SEGMENT
	%DUMMY			;;BRANCH ADDRESS
	$XHIGH			;;SWITCH INTO EXTENDED HIGH SEGMENT
%DUMMY:				;;EXECUTION CONTINUES HERE IN SECTION 2
>;; END IFN FTXMON

>; END DEFINE $XSENT
;COMMON BLISS-STYLE SUBROUTINE ENTRY - ROUTINE CALLABLE FROM ANY CODE SECTION,
;EXECUTES IN REGULAR HIGH SEGMENT (SECTION 1).

DEFINE	$CBSUB(NAME,ARGS,%DUMMY),<

	$CSUB			;;SWITCH TO COMMON ENTRY PSECT
NAME				;;HOPE YOU INCLUDED COLONS IN DEFINITION!
	BLSUB.	(<ARGS>)	;;CALL .ENTER BEFORE CHANGING STACK
IFN FTXMON,<			;;IF EXTENDED MONITOR
	SE1ENT			;;MAKE SURE RETURN IN S0 IF CALLED FROM THERE
	XJRST	.+1		;;ENTER HIGH SEGMENT
	MCSEC1+%DUMMY		;;BRANCH ADDRESS
	$HIGH			;;SWITCH INTO HIGH SEGMENT
%DUMMY:				;;EXECUTION CONTINUES HERE IN SECTION 1
>;; END IFN FTXMON

>; END DEFINE $CSENT


;EXTENDED BLISS-STYLE SUBROUTINE ENTRY - ROUTINE CALLABLE FROM ANY CODE SECTION,
;EXECUTES IN EXTENDED HIGH SEGMENT (SECTION 2)

DEFINE	$XBSUB(NAME,ARGS,%DUMMY),<

	$CSUB			;;SWITCH TO GLOBAL ENTRY PSECT
NAME				;;HOPE YOU INCLUDED COLONS IN DEFINITION!
	BLSUB.	(<ARGS>)	;;CALL .ENTER BEFORE CHANGING STACK
IFN FTXMON,<			;;IF EXTENDED MONITOR
	SE1ENT			;;MAKE SURE RETURN IN S0 IF CALLED FROM THERE
	XJRST	.+1		;;ENTER EXTENDED HIGH SEGMENT
	%DUMMY			;;BRANCH ADDRESS
	$XHIGH			;;SWITCH INTO EXTENDED HIGH SEGMENT
%DUMMY:				;;EXECUTION CONTINUES HERE IN SECTION 2
>;; END IFN FTXMON

>; END DEFINE $XBSUB
	SUBTTL	SYSTEM MACROS -- NETSER INTERLOCK MANAGEMENT
;THE FOLLOWING FIVE MACROS ARE USED TO INTERLOCK THE NETSER DATABASE
;
;  NETDBL	THIS MACRO LOCKS THE DATABASE.  IT MUST BE CALLED FROM
;		UUO LEVEL, AND IT MAY NOT BE CALLED RECURSIVLY!
;  NETDBU	THIS MACRO UNLOCKS THE DATABASE.  (COMPLEMENT OF NETDBL)
;  NETDBJ	IF THE CURRENT JOB ALREADY OWNS THE INTERLOCK, THIS
;		OPERATION DOES NOTHING.  OTHERWISE IT LOCKS THE DATABASE
;		AND COROUTINES BACK TO THE CALLING ROUTINE.  WHEN THAT
;		ROUTINE POPJ'S (OR POPJ1'S) IT WILL UNLOCK THE DATABASE.
;  NTDBLI	THIS OPERATION IS USED TO LOCK THE DATABASE FROM INTERRUPT
;		LEVEL.  IT SKIP RETURNS IF THE DATABASE WAS AVAILABLE.
;		ERROR RETURN'S IF IT WAS LOCKED.
;  NTDBUI	THIS OPERATION IS USED TO UNLOCK THE DATABASE FROM INTERRUPT
;		LEVEL.
;  NTSAVE	THIS OPERATION IS USED RETURN THE INTERLOCK FOR THE
;		DURATION OF ONE SUBROUTINE CALL. (DOES NOTHING IF CURRENT
;		JOB DOES NOT OWN THE INTERLOCK)
;  NTGIVE	THIS MACRO IS USED TO GIVE UP THE INTERLOCK CONDITIONAL
;		ON THE PROCESS'S HAVING IT.  USED IN ERROR ROUTINES
;  NTDBUG	THIS MACRO IS USED TO AID IN DEBUGGING THIS MESS.
;		IT TAKES TWO ARGUMENTS.  THE GOVERNS THE CHECK REGARDING
;		WHO HAS THE INTERLOCK.  THE SECOND GOVERNS CHECKING ABOUT
;		INTERRUPT VS UUO LEVEL.
;		FIRST ARG VALUES:
;		  EITHER	MEANS DON'T WORRY ABOUT WHO HAS THE INTERLOCK
;		  YES		SAYS TO STOP IF THE CURRENT PROCESS DOES NOT
;				HAVE THE INTERLOCK.  (THIS IS THE DEFAULT IF NO
;				ARGUMENT IS SPECIFIED)
;		  NO		SAYS TO STOP IF THE CURRENT PROCESS HAS THE
;				INTERLOCK
;		SECOND ARG VALUES:
;		  EITHER	MEANS DON'T WORRY ABOUT WHAT LEVEL THE CURRENT
;				PROCESS IS RUNNING AT.  (THIS IS THE DEFAULT)
;		  INT		SAYS TO STOP IF THE CURRENT PROCESS IS NOT AT
;				EITHER CLOCK (SCHEDULER), OR INTERRUPT LEVEL
;		  UUO		SAYS TO STOP IF THE CURRENT PROCESS IS NOT AT
;				UUO LEVEL. (STACK IN THE .UPMP)
;

DEFINE	NETDBL,<
	IFNDEF NTLCLK,<EXTERNAL NTLCLK>
	PUSHJ	P,NTLCLK
>

DEFINE	NETDBU,<
	IFNDEF NTUNLK,<EXTERNAL NTUNLK>
	PUSHJ	P,NTUNLK
>

DEFINE	NETDBJ,<
	IFNDEF NTLCKJ,<EXTERNAL NTLCKJ>
	PUSHJ	P,NTLCKJ
>
DEFINE	NTDBLI,<
	IFNDEF NTLCKI,<EXTERNAL NTLCKI>
	PUSHJ	P,NTLCKI
>

DEFINE	NTDBUI,<
	IFNDEF NTULKI,<EXTERNAL NTULKI>
	PUSHJ	P,NTULKI
>

DEFINE	NTSAVE,<
	IFNDEF NTSAV,<EXTERNAL NTSAV>
	PUSHJ	P,NTSAV
>

DEFINE	NTGIVE,<		;;ROUTINE TO GIVE UP THE INTERLOCK ON AN ERROR
	IFNDEF NTLERR,<EXTERNAL NTLERR>
	PUSHJ	P,NTLERR>	;;GIVE UP THE INTERLOCK ONLY IF WE OWN IT

DEFINE	NTDBUG(HAVEIT,LEVEL),<
	IFNDEF NTCHCK,<EXTERNAL NTCHCK>
	IFNDEF NTDSTP,<EXTERNAL NTDSTP>
	IFNDEF UUOLVL,<EXTERNAL UUOLVL>
	IFNDEF INTLVL,<EXTERNAL INTLVL>

ZZZ==0				;;FLAG TO HELP CHECK THE ARG'S VALIDITY

IFB <LEVEL>,<ZZZ==1>		;;IF WE WEREN'T ASKED TO, DON'T CHECK LEVEL
IFNB <LEVEL>,<			;;HERE WE MUST VALIDATE THE LEVEL PARAMETER
  IFIDN <LEVEL><EITHER>,<ZZZ==1>;;EITHER MEANS EITHER LEVEL IS OK
  IFIDN <LEVEL><UUO>,<ZZZ==1	;;HERE VERIFY UUO LEVEL
	PUSHJ	P,UUOLVL	;;SEE IF IT'S UUO LEVEL
	 PUSHJ	P,NTDSTP>	;;STOP IF THE LEVEL IS WRONG
  IFIDN <LEVEL><INT>,<ZZZ==1	;;HERE VERIFY INTERRUPT LEVEL
	PUSHJ	P,INTLVL	;;SEE IF IT'S INTERRUPT LEVEL
	 PUSHJ	P,NTDSTP>>	;;STOP IF THE LEVEL IS WRONG

IFE ZZZ,<PRINTX ?BAD SECOND ARG (= LEVEL ) TO NTDBUG MACRO?>

ZZZ==0

IFB <HAVEIT>,<ZZZ==2>		;;DEFAULT IS TO VERIFY THAT WE HAVE IT (2)
IFIDN <HAVEIT><EITHER>,<ZZZ==1>	;;EITHER MEANS WE DON'T CARE
IFIDN <HAVEIT><YES>,<ZZZ==2>	;;YES MEANS WE SHOULD CHECK FOR IT
IFIDN <HAVEIT><NO>,<ZZZ==3>	;;NO MEANS WE SHOULD MAKE SURE WE DON'T HAVE IT

IFE ZZZ,<PRINTX ?BAD FIRST ARG (= HAVEIT ) TO NTDBUG MACRO?>
IFGE ZZZ-2,<			;;IF WE HAVE TO CHECK,
	PUSHJ	P,NTCHCK	;;CALL THE ROUTINE THAT CHECKS
  IFE ZZZ-3,<JRST .+2>		;;IF WE ARE IN A "NO" CLAUSE, INVERT THE CHECK
	 PUSHJ	P,NTDSTP>	;;STOP IF WE DO/DON'T HAVE THE LOCK

ZZZ==0				;;CLEAN UP
>				;;END OF NTDBUG MACRO
;MACRO TO PREVENT CORE SHUFFLING, USED AT UUO LEVEL WHEN
;A ROUTINE SETS UP AN ABSOLUTE USER ADDRESS IN AN AC
;OTHER THAN P,R, OR R. THE MAIN EXAMPLE IS A BLT
;FROM EXEC TO USER OR USER TO EXEC.

DEFINE NOSHUFF
<>

;MACRO TO ALLOW SHUFFLING ONCE MORE

DEFINE	SHUFFLE
<>



;MACRO TO START A DEVICE FROM UUO LEVEL
;T1:=XWD DEVINT FLAGS,CONO ARGUMENTS

DEFINE STARTDV (A)
<
	CONO	PI,PI.OFF
	CONO	A,(T1)
	HLRM	T1,A'CON
	CONO	PI,PI.ON
>
	SUBTTL	MULTI-PROCESSING MACRO DEFINITIONS FOR ONCE-ONLY TIME


;MACRO TO EXECUTE A SUBROUTINE ON A SPECIFIED CPU.  TYP ALLOWS
;YOU TO SET UP COMMON DATA STRUCTURE ACS FOR FREE.  SEE CPUXCT
;FOR DETAILS.  CALLS ARE USUALLY SYNCHRONOUS, EXECUTE WITH ALL
;AC'S EXCEPT FOR P, AND MAY SKIP (ONCE).  THE ACS OF THE CALLED
;ROUTINE ARE RETURNED.  HOWEVER, IF XC.ASY IS SET, THE CALL
;ONLY WAITS FOR THE CPU TO ACCEPT THE COMMAND, MAY NOT SKIP,
;AND DOES NOT RETURN THE ACS.  CPUASF BIT 35-CPU# WILL CLEAR
;WHEN THE I/O COMPLETES.

DEFINE	XCTCPU	(TYP,SUB,FLAGS),<
IFE FTMP,<PUSHJ	P,SUB>
IFN FTMP,<
IF2,<IFNDEF CPU'TYP,<EXTERN CPU'TYP>>
	PUSHJ	P,[PUSHJ P,CPU'TYP
		   <IFIW SUB>+<FLAGS>]
> ;;END IFN FTMP
> ;;END DEFINE XCTCPU

	XC.ASY==1B1		;ASYNCH REQUEST FLAG
	XC.LNG==1B2		;LONG TIMEOUT FLAG
	SUBTTL	SYSTEM MACROS -- STOPCD

;MACRO TO GENERATE CODE FOR FATAL ERROR CONDITIONS
;CALL WITH:
;	STOPCD	CONT,TYPE,NAME,TYPOUT,	;++COMMENT
;WHERE:
;CONT IS THE CONTINUE ADDRESS FOR THIS CONDITION.
;TYPE IS THE TYPE OF ERROR. IT MUST BE ONE OF THE FOLLOWING:
;	HALT  - GENERATE A HALT INSTRUCTION (USE ONLY IN DISPATCH TABLES, ETC.)
;	STOP  - STOP THE SYSTEM (MAJOR ERROR)
;	JOB   - STOP JOB (MAJOR ERROR IN A DEVICE SERVICE ROUTINE OR UUO)
;	DEBUG - GO TO CONTINUE ADDRESS
;	CPU   - SAME AS STOP ON A SINGLE CPU SYSTEM, IF THIS IS THE LAST
;	        CPU RUNNING ON A MULTIPROCESSOR SYSTEM OR IF DF.CP1 IS
;	        SET.  IN ALL OTHER CASES, STOP ONLY THE CPU ON WHICH THE
;	        ERROR WAS DETECTED.
;NAME IS A SIX LETTER NAME FOR THIS ERROR. IT MUST BE UNIQUE.
;TYPOUT IS AN ADDITIONAL ROUTINE TO CALL FOR ADDITIONAL OUTPUT

;NOTE THAT ALTERNATE ENTRY INTO STOPCD IS VIA BUG.

;DEFINE THE VARIOUS STOPCODE ACTION TYPES
	S$HALT==:0		;GENERATE A HALT
	S$STOP==:1		;STOP/RELOAD THE SYSTEM
	S$JOB==:2		;STOP THE JOB
	S$DEBUG==:3		;DUMP AND CONTINUE
	S$CPU==:4		;STOP THE CPU (RELOAD IF LAST)
	S$INFO==:5		;INFORMATIONAL ONLY
	S$NODUMP==:5		;ALTERNATE NAME FOR ABOVE (**TEMP**)
	S$EVENT==:6		;EVENT (BUGINF)

	S$MAXT==:6		;HIGHEST KNOWN STOPCODE TYPE
	S$MAXL==:4		;MAXIMUM LENGTH OF STOPCODE BLOCK
	S$PTRT==:<POINT 4,2,17>	;BYTE POINTER TO STOPCODE TYPE

DEFINE	STOPCD(CONT,TYPE,NAME,TYPOUT),<
	STPTRP(<CONT>,<TYPE>,<NAME>,<TYPOUT>,<PUSHJ P,DIE>,DIE)
>

REPEAT 0,<;;THIS DOESN'T WORK
DEFINE	TRAPCD(CONT,TYPE,NAME,TYPOUT),<
	STPTRP(<CONT>,<TYPE>,<NAME>,<TYPOUT>,<XPCW CROAK>,CROAK)
>
>

DEFINE	STPTRP(CONT,TYPE,NAME,TYPOUT,INSTR,PROC),<
;	SALL		;;CLEAN LISTING

;;TYPE OF ACTION TO TAKE ON STOPCD

	ACTTYP==-1

IFDEF S$'TYPE,<ACTTYP==S$'TYPE>

IFB <NAME><PRINTX ?STOPCD WITHOUT A NAME. -- SEE S.. IN CREF>
IFL ACTTYP,<IF2	< PRINTX ?STOPCD NAME IS IN ERROR -- SEE %%.'NAME IN CREF>
	%%.'NAME:
> ;END IFL ACTTYP

IFNB <TYPOUT>,<ACTTYP==ACTTYP!400000>	;;IF TYPEOUT ROUTINE, SET BIT

	IFE <<SIXBIT /NAME/>&777777>,<S..'NAME::!> ;;OLD-STYLE LABEL

IFE	ACTTYP&377777,<
	IF2,<IFNDEF	DOHALT,<EXTERNAL DOHALT>>
	XPCW	DOHALT			;;CONTINUE ADDRESS IS USELESS ANYWAY
>
IFN	ACTTYP&377777,<
	IF2,<IFNDEF	PROC,<EXTERNAL PROC>>
	XCT	[NAME::INSTR		;**** NAME STOP ****
		SIXBIT /NAME/
		<ACTTYP>B17+IFDIF<CONT><.>,<EXP CONT&777777>;;STOPCD TYPE AND CONTINUATION
		IFNB <TYPOUT>,<EXP TYPOUT> ;;TYPEOUT ADDRESS IF PRESENT
		]			;;END STOPCD
>
	PURGE	ACTTYP
>
	SUBTTL	GENERAL SYSTEM DEFINITIONS -- BUG. - TOPS20 STOPCD

;This macro IS skippable and it saves ALL temp ACs except CX
;
;Args:	prefix:	Three-character module name
;	name:	Three-character BUG. name, unique within module
;	type:	CHK (recommended), HLT or INF, like TOPS-20's BUG macro
;	text:	Some text to type on the CTY when this BUG. is hit
;		Depends on FTLONG.
;	cont:	(optional) Address at which to continue after BUG.
;		If blank, BUG. falls through to next instruction

DEFINE	BUG.(type,name,module,harsof,text,args,bigtxt,cont),<

	IF2 ,<IFNDEF	DIE,< EXTERNAL DIE>>
ACTTYP==0
IFIDN <type><HLT>,<		;STOP STOPCD
		ACTTYP==S$STOP
		>
IFIDN <type><CHK>,<		;DEBUG STOPCD
		ACTTYP==S$DEBUG
		>
IFIDN <type><INF>,<		;JUST SOME TYPEOUT
		ACTTYP==S$EVENT
		>

IFE ACTTYP,<PRINTX ?Illegal BUG. type for bug 'name ('type)>
	..ARGN==0
	IRP <ARGS>,<..ARGN==..ARGN+1>
	IFN ..ARGN,<ACTTYP=ACTTYP!400000>

	XCT	[NAME::PUSHJ P,DIE	;**** NAME STOP ****
		SIXBIT /NAME/
		<ACTTYP>B17+IFNB <CONT>,<EXP CONT&777777>;;STOPCD TYPE AND CONTINUATION
		IFN ..ARGN,<IF2,<IFNDEF BGCTYP,<EXTERNAL BGCTYP>>
		  [JSP T1,BGCTYP	;;CALL TYPEOUT
		  BUG0. <ARGS>		;;WITH ADDITIONAL DATA ARGUMENTS
		  EXP 0]>		;;TERMINATE LIST
		]			;;END STOPCD

	PURGE	..ARGN,ACTTYP

>;END DEFINE BUG.

DEFINE	BUG0.(ARGS),<
	IRP ARGS,<BUG1. ARGS>>

DEFINE	BUG1.(ARGS),<BUG2.(ARGS)>

DEFINE	BUG2.(ARGLOC,ARGNAM),<
	IFB <ARGNAM>,<
		PRINTX %Data item ARGLOC in BUG'TYP NAME has no descriptor.
		>
	EXP SIXBIT \ARGNAM\
	Z ARGLOC
>
	SUBTTL	SYSTEM MACROS -- FRAME

;MACRO TO DEFINE A BUNCH OF WORDS ON THE STACK.
;EACH ARGUMENT TO THE FRAME MACRO ALLOCATES 1 WORD ON THE
; STACK AND DEFINES A MACRO WITH THE SAME NAME AS -N(P).
;
;NOTE: THIS MACRO DEFINES THINGS IN TERMS OF (P) AND THEREFOR
; NOTHING ELSE MAY BE PUSHED ON THE STACK!!!

DEFINE	FRAME(LIST,%A),<
	%%%N==0			;ARGUMENT COUNT
IRP LIST,<
	%FRAM1(LIST,\<%%%N+1>)	;DEFINE MACRO
	%%%N==%%%N+1		;BUMP COUNT
>
	ADJSP	P,%%%N
	PUSHJ	P,%A		;DO THE SUBROUTINE
	  JRST	.+2		;NON-SKIP RETURN
	AOS	-%%%N(P)	;PASS ON THE SKIP RETURN
	ADJSP	P,-%%%N		;DEALLOCATE SPACE
	POPJ	P,0		;RETURN
%A:! ;SUBROUTINE WITH LOCAL STORAGE
>

DEFINE	%FRAM1(A,B),<
DEFINE	A,<-B(P)>
>
	SUBTTL	SYSTEM MACROS -- TEXT CONCATENATION

;THESE MACROS PROVIDE A CONVENIENT MECHANISM TO ACCUMULATE TEXT
;(ASCIZ STRINGS, MACRO DEFINITIONS ETC.) DURING THE COURSE OF AN
;ASSEMBLY, THEN TO USE THAT TEXT AS DESIRED LATER ON.
;
;TO INITIALIZE:
;		CCLEAR(NAME)
;
;	WHERE NAME IS 4 CHARACTERS OR LESS.
;
;TO CONCATENATE TEXT ON THE RIGHT:
;		CONCAT(NAME,TEXT)
;
;	WHERE NAME HAS BEEN INITIALIZED BY CCLEAR, AND TEXT IS
;	THE TEXT TO BE CONCATENATED.
;
;AFTER THE CALL TO ANY CONCAT MACRO, NAME WILL BE DEFINED TO BE
;THE TEXT ACCUMULATED SO FAR. USE OF THIS MACRO DOES NOT PREVENT
;ADDITIONAL CALLS TO CONCAT. MULTIPLE STRINGS CAN BE ACCUMULATED
;SIMULTANEOUSLY, USING DIFFERENT NAMES.
;
;EXAMPLE:
;		CCLEAR(MSG)
;		CONCAT(MSG,ASCIZ /)
;		CONCAT(MSG,A )
;		CONCAT(MSG,LINE)
;		CONCAT(MSG,/)
;
;	IS EQUIVALENT TO DEFINE MSG<ASCIZ /A LINE/>


	DEFINE	CCLEAR(NAME)<			;;CLEAR MACRO
	  DEFINE C.'NAME(FTXT)<			;;DEFINE FIRST CALL
	    DEFINE C.'NAME(TEXT)<		;;DEFINE 2ND CALL
	      C%%%ON <NAME>,<FTXT>,<TEXT>	;;APPEND THE TEXT
	    >
	    DEFINE NAME<FTXT>			;;JUST TEXT 1ST TIME
	  >
	  .XCREF C.'NAME			;;DON'T CREF TEMP MACRO
	  DEFINE NAME<>				;;NULL BEFORE CONCAT'S
	>

	DEFINE	C%%%ON(NAME,OTXT,NTXT)<		;;INTERNAL HELPER MACRO
	  DEFINE C.'NAME(TEXT)<			;;DEF C.NAME FOR LATER
	    C%%%ON <NAME>,<OTXT'NTXT>,<TEXT>	;;CALL HELPER MACRO
	  >
	  DEFINE NAME<OTXT'NTXT>		;;PUT NEW TEXT IN NAME
	>

	DEFINE	CONCAT(NAME,TEXT)<C.'NAME <TEXT>>

	.XCREF	C%%%ON
;THE CONC MACRO SIMPLY CONCATENATES ITS PARAMETERS AND MAKES
; A CONVENIENT MECHANISM TO BUILD LABELS WITH NUMERIC STRINGS IN THEM.

DEFINE	CONC(A,B,C,D)<A'B'C'D>
	SUBTTL	SYSTEM MACROS -- SOPDEF, GOPDEF, GSOPDEF

;MACROS TO DO VARIOUS FLAVORS OF OPDEF.
;
;	SOPDEF			OPDEF, SUPRESSED TO DDT
;	GOPDEF			OPDEF, GLOBAL (INTERNAL)
;	GSOPDEF			OPDEF, GLOBAL SUPPRESSED
;
;EXAMPLE:
;	SOPDEF	PJRST[JRST]	;REPLACE PUSHJ/POPJ SEQUENCE


	DEFINE	SOPDEF(STR)<		;;SUPPRESSED OPDEF
	  O%%%PD(.NODDT,STR)
	>

	DEFINE	GOPDEF(STR)<		;;GLOBAL OPDEF
	  O%%%PD(INTERNAL,STR)
	>

	DEFINE	GSOPDEF(STR)<		;;GLOBAL SUPPRESSED OPDEF
	  O%%%PD(<.NODDT,INTERNAL>,STR)
	>


	DEFINE	O%%%PD(OPS,STR)<
	  .XCREF
	  CCLEAR(O%%P)			;;PREPARE TO EXTRACT NAME
	  CONCAT(O%%P,<OP%%%D (>)	;;START STRING WITH OP%%%D CALL
	  IRPC STR,<
	    IFIDN <STR><[>,<
	      STOPI			;;STOP WHEN WE HAVE THE SYMBOL
	    >
	    IFDIF <STR><[>,<
	      CONCAT(O%%P,STR)		;;ACCUMULATE SYMBOL NAME
	    >
	  >
	  CONCAT(O%%P,<)>)		;;FINISH THE OP%%%D CALL
	  O%%P				;;CALL OP%%%D TO DEFINE O%%P%D
	  .CREF				;;CREF THE OPDEF
	  OPDEF	STR			;;ACTUALLY DO THE OPDEF
	  .XCREF			;;BUT NOTHING ELSE
	  IRP OPS,<
	    O%%P%D(OPS)			;;DO THE PSEUDO-OP TO THE SYMBOL
	  >
	  .CREF
	>

	DEFINE	OP%%%D(STR)<
	  DEFINE O%%P%D(OP)<
	    OP	STR
	  >
	>

	.XCREF	O%%%PD,OP%%%D
	SUBTTL	SYSTEM MACROS -- METER POINT

;METER POINT MACRO (METER. UUO)
;  N=METER POINT # (DECIMAL)
;  AC T1=POINT VALUE (IF ANY)
;  RH OF MEQ'N'## IS POINT PARAMETER (IF ANY)
;    (I.E. MAY BE USED TO QUALIFY POINT VALUE)
;  MEP'N IS GLOBAL & MAY BE USED TO FIND
;    POINT 'N' VIA GLOB & CREFS
;  DESTROYS T1 & T2

DEFINE MPOINT (N)
<IFN FTMETR,<
	SKIPGE	T2,MEP'N'##
	PUSHJ	P,(T2)
>>
	SUBTTL	SYSTEM MACROS -- EXECUTIVE EXECUTE

IFN FTXMON,<
;XBLT EXEC TO USER
DEFINE	XBLTXU(AC<T1>),<XCT PX.SRC,[EXTEND AC,[XBLT]]>

;XBLT USER TO USER
DEFINE	XBLTUU(AC<T1>),<XCT PX.SRC!PX.BYT,[EXTEND AC,[XBLT]]>

;XBLT USER TO MONITOR
DEFINE	XBLTUX(AC<T1>),<XCT PX.BYT,[EXTEND AC,[XBLT]]>

>;END OF IFN FTXMON

IFE FTXMON,<
;XBLT TO USER
DEFINE	XBLTXU(AC<T1>),<
IFN <AC>-T1,<PRINTX ? CAN'T XBLT VIA AC, USE T1>
IF2,<IFNDEF PBLTXU,<EXTERN PBLTXU>>
	PUSHJ	P,PBLTXU
>

;XBLT TO MONITOR
DEFINE	XBLTUX(AC<T1>),<
IFN <AC>-T1,<PRINTX ? CAN'T XBLT VIA AC, USE T1>
IF2,<IFNDEF PBLTUX,<EXTERN PBLTUX>>
	PUSHJ	P,PBLTUX
>

>;END OF IFE FTXMON

;BLT TO USER
DEFINE	BLTXU(X),<EXCTXU(<X>)>

;BLT TO MONITOR
DEFINE	BLTUX(X),<EXCTUX(<X>)>

;SPECIAL PXCT MACROS FOR KL10
; MUST BE DEFINED AS CORRESPONDING EXCT IF FTKL10 IS OFF

DEFINE PXCTUX(A,B)<
	EXCTUX(<A>)
>
DEFINE PXCTXU(A,B)<
	EXCTXU(<A>)
>
DEFINE PXCTUU(A,B)<
	EXCTUU(<A>)
>
	SUBTTL	SYSTEM MACROS -- KL10 SPECIFIC

IFN	FTKL10,<

;KL10 INTERNAL DEVICE OPCODES

CCA==14			;CACHE
TIM==20			;INTERVAL TIMER,TIME BASE
MTR==24			;ACCOUNTING METERS, PERFORMANCE METER

;OPDEFS FOR KL10 INSTRUCTIONS
	OPDEF	PMOVE	[052B8]	;PHYSICAL MOVE
	OPDEF	PMOVEM	[053B8]	;PHYSICAL MOVEM
	OPDEF	ADJSP	[105B8]	;ADJUST STACK POINTER
	SOPDEF	PXCT	[XCT]	;PREVIOUS CONTEXT EXECUTE
	OPDEF	DADD	[114B8]	;DOUBLE ADD
	OPDEF	DSUB	[115B8]	;DOUBLE SUB
	OPDEF	DMUL	[116B8]	;DOUBLE MUL
	OPDEF	DDIV	[117B8]	;DOUBLE DIV
	SOPDEF	ADJBP	[IBP]	;ADJUST BYTE POINTER
	OPDEF	APRID	[BLKI APR,]	;READ PROCESSOR SERIAL, UCODE VERSION
	OPDEF	WRFIL	[BLKO APR,]	;WRITE CACHE REFILL ALGORITHM
	OPDEF	RDERA	[BLKI PI,]	;READ ERROR ADDRESS REGISTER
	OPDEF	SBDIAG	[BLKO PI,]	;SBUS DIAGNOSTIC
	OPDEF	CLRPT	[BLKO PAG,]	;CLEAR ONE ENTRY IN HARDWARE
					; PAGE TABLE
	OPDEF	SWPIA	[DATAI CCA,]	;INVALIDATE ALL CACHE DATA,
					; WITHOUT UPDATING CORE
	OPDEF	SWPVA	[BLKO CCA,]	;SWEEP CACHE, VALIDATING CORE
					; FOR ALL PAGES, LEAVING CACHE VALID
	OPDEF	SWPUA	[DATAO CCA,]	;UNLOAD ALL PAGES, UPDATING
					; CORE AND INVALIDATING CACHE
	OPDEF	SWPIO	[CONI CCA,]	;INVALIDATE ONE PAGE
	OPDEF	SWPVO	[CONSZ CCA,]	;VALIDATE ONE PAGE
	OPDEF	SWPUO	[CONSO CCA,]	;UNLOAD ONE PAGE
	OPDEF	RDPERF	[BLKI TIM,]	;READ DOUBLE-WORD PERFORMANCE
					; ANALYSIS COUNTER
	OPDEF	RDTIME	[DATAI TIM,]	;READ DOUBLE-WORD TIME BASE
	OPDEF	WRPAE	[BLKO TIM,]	;WRITE PERFORMANCE ANALYSIS
					; ENABLES
	OPDEF	RDMACT	[BLKI MTR,]	;READ DOUBLE-WORD MBOX
					; ACCOUNTING COUNT
	OPDEF	RDEACT	[DATAI MTR,]	;READ DOUBLE-WORD EBOX
					; ACCOUNTING COUNT


>;END IFN FTKL10 CONDITIONAL
	SUBTTL	SYSTEM MACROS -- KL10/KS10 SPECIFIC

;BITS IN PXCT AC FIELD
	PX.EAC==10		;EFFECTIVE ADDRESS OF OBJECT INSTRUCTION
	PX.MEM==4		;MEMORY OPERAND (BOTH FETCH AND STORE)
	PX.BYT==2		;EFFECTIVE ADDRESS OF BYTE POINTER
				;SOURCE IN XBLT
	PX.SRC==1		;STACK WORD IN PUSH/POP; SOURCE IN BLT
				;DESTINATION IN XBLT

DEFINE	EXCTUU(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>


	PXGEN(<INST>,<DPB,IDPB>,<PX.SRC>)	;;BECAUSE EXCTUU IS USED ON KL10 FOR
					;; READ-MODIFY-WRITE
	PXGEN(<INST>,<BLT,PUSH,POP>,<PX.SRC!PX.MEM>)
	PXGEN(<INST>,<EXTEND>,<PX.SRC!PX.BYT>)	;;FOR XBLT AND MOVSLJ
	GINST
	PURGE GINST
>;END EXCTUU MACRO DEFINITION

DEFINE	EXCTUX(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>
	PXGEN(<INST>,<LDB,ILDB,POP,BLT>,<PX.SRC>)
	PXGEN(<INST>,<EXTEND>,<PX.BYT>)	;;FOR XBLT AND MOVSLJ
	GINST
	PURGE GINST
>;END EXCTUX MACRO DEFINITION

DEFINE	EXCTXU(INST)<
	SALL
	GINST==<PXCT PX.MEM,[INST]>
	PXGEN(<INST>,<IDPB,DPB,PUSH,EXTEND>,<PX.SRC>)
	PXGEN(<INST>,<POP,BLT>,<PX.MEM>)
	GINST
	PURGE GINST
>;END EXCTXU MACRO DEFINITION

IFN	FTKL10,<
DEFINE	UMOVE(AC,ADR)<EXCTUX <MOVE AC,ADR>>	;MOVE FROM USER TO MONITOR
DEFINE	UMOVEM(AC,ADR)<EXCTXU <MOVEM AC,ADR>>	;MOVE FROM MONITOR TO USER
> ;END IFN FTKL10

IFN	FTKS10,<
OPDEF	UMOVE	[704B8]		;MOVE FROM USER TO MONITOR
OPDEF	UMOVEM	[705B8]		;MOVE FROM MONITOR TO USER
> ;END IFN FTKS10
DEFINE	PXGEN(INST,CODES,BITS)<
	ZZ==0
	IRPC INST,<
	IFB<INST>,<STOPI>			;;IF TAB OR SPACE, STOP
	IFNB<INST>,<ZZ==ZZ_6+''INST''>		;;ELSE MERGE IN CHAR
>;END IRPC INST
	IRP CODES,<
	IFE <ZZ^!''CODES''>,<GINST==<PXCT BITS,[INST]>>
>;END IRP CODES

	PURGE OPCOD,ZZ1
>;END PXGEN MACRO DEFINITION

;MACROS TO SAVE AND RESTORE  AC BLOCKS FOR KL10/KS10 POWER FAIL RESTART

DEFINE	SAVE(X,Y),<
	EXECAC	(X)
	MOVEM	17,Y+17
	MOVEI	17,Y
	BLT	17,Y+16
	MOVE	17,Y+17
>

DEFINE	RESTOR(X,Y),<
	EXECAC	(X)
	MOVSI	17,Y
	BLT	17,17
>

DEFINE	ZERO	(X),<
	EXECAC	(X)
	SETZ	0,
	MOVEI	17,1
	BLT	17,17
>
;MACROS TO CHANGE AC BLOCKS

	DEFINE	EXECAC(A),<
IFN FTKL10,<
	SALL
IFB <A>,<
	DATAO	PAG,[LG.LAB+01B11]
>
IFNB <A>,<
	DATAO	PAG,[LG.LAB+<<A_3>+1>B11]
>
	LIST
>;IFN FTKL10
IFN FTKS10,<
	SALL
IFB <A>,<
	WRUBR	[SG.LAB+01B11]
>
IFNB <A>,<
	WRUBR	[SG.LAB+<<A_3>+1>B11]
>
	LIST
>;IFN FTKS10
>;DEFINE EXECAC

DEFINE 	USERAC,<
IFN FTKL10,<
	SALL
	DATAO	PAG,[LG.LAB+11B11]
	LIST
>;IFN FTKL10
IFN FTKS10,<
	SALL
	WRUBR	[SG.LAB+11B11]
	LIST
>;IFN FTKS10
>;DEFINE USERAC
DEFINE CLRPGT(A,B),<
	SALL

IFNB <A>,<PRINTX ?NO ARGUMENTS TO CLRPGT MACRO>
IFNB <B>,<PRINTX ?NO ARGUMENTS TO CLRPGT MACRO>

IF2,<IFNDEF .CPEBR,<EXTERN .CPEBR>>
IFN FTKL10,<CONO PAG,@.CPEBR>
IFN FTKS10,<WREBR @.CPEBR>

>;END CLRPGT MACRO DEFINITION
	SUBTTL	SYSTEM MACROS -- SOFTWARE INTERRUPTS

;MACRO TO CAUSE A NON-DEVICE PROGRAMMED SOFTWARE INTERRUPT

	DEFINE	SIGNAL(COND),<
	IF2,<IFNDEF PSICND,<EXTERNAL PSICND>>
		IFNDEF COND,<
		  PRINTX  ? COND IS NOT DEFINED IN FILE S.MAC!
		  XP	COND,C$MIN-1	;CONDITION YOU CAN NOT ENABLE
		 >
		IFGE <COND><
		  PRINTX  ? COND IS NO A NEGATIVE NUMBER!
		  XP	COND,C$MIN-1	;CONDITION YOU CAN NOT ENABLE
		 >
	HRROI	T1,COND		;SETUP CONDITION
	XCT	NOPISK##	;SKIP IS USER IS NOT ENABLED
	PUSHJ	P,PSICND	;ENABLED, CALL SIGNALLER
>
	SUBTTL	SYSTEM MACROS -- TWO SEGMENT MONITOR

	DEFINE	$LIT<
	$HIGH
	LIT
>;END OF $LIT
	SUBTTL	SYSTEM MACROS -- MULTI SEGMENT MONITOR

;DEFINITION OF THE PSECTS USED BY TOPS-10:
;EACH ENTRY IS "PSECT NAME[,ORIGIN]" WHERE ORIGIN IS SPECIFIED ONLY
;FOR PSECTS OTHER THAN .ABS. AND .LOW.

DEFINE	PSECTS,<

PSECT	.ABS.			;;DUMMY PLACEHOLDER - *** MUST BE FIRST ***
PSECT	.LOW.			;;LOW SEGMENT
PSECT	.INIT.			;;INITIALIZATION CODE - DESTROYED AFTER ONCE
PSECT	.TWIC.			;;TWICE - USER MODE DISK ONCE-ONLY CODE
PSECT	.HIGH.			;;HIGH SEGMENT
PSECT	.CSUB.			;;COMMON SUBROUTINES
PSECT	.XHGH.			;;EXTENDED HIGH SEGMENT (DECNET, ETC.)

>; END DEFINE PSECTS

DEFINE	PSECT(NAME),<

	NAME==0-PSECT.		;;GIVE NAME A NEGATIVE VALUE (PLACEHOLDER)
	PSECT.==PSECT.+1	;;COUNT THEM UP

>; END DEFINE PSECT

	PSECT.==0		;START AT THE BEGINNING
	PSECTS			;GENERATE PSECT IDENTIFIERS

;MACRO TO INITIALIZE PSECT USAGE - MUST APPEAR FIRST IN A MODULE
;BEFORE ANY STATEMENTS WHICH GENERATE CODE.

DEFINE	$RELOC,<		;;INITIALIZER

	SALL			;;ENOUGH OF THIS JUNK

	PSECT.==.LOW.		;;WHERE WE START OFF
	.PSECT	.LOW.		;;GET THERE

	ABSLOC==0		;;WHERE ABSOLUTE CODE BEGINS

>; END $RELOC

;DEFINE EQUIVALENCES FOR THE OLD MACROS

DEFINE	$ABS,<	$PSECT (.ABS.)>	;ABSOLUTE CODE - NOT A REAL PSECT
DEFINE	$LOW,<	$PSECT (.LOW.)> ;LOW SEGMENT CODE
DEFINE	$INIT,<	$PSECT (.INIT.)> ;INITIALIZATION CODE - DESTROYED AFTER ONCE
DEFINE	$TWICE,< $PSECT (.TWIC.)> ;TWICE (USER MODE DISK ONCE-ONLY)
				; (NEVER USED BY MONITOR)
IFE FTXMON,<
DEFINE	$CSUB,< $PSECT (.HIGH.)> ;COMMON SUBROUTINE ENTRY
>; END IFE FTXMON
IFN FTXMON,<
DEFINE	$CSUB,<	$PSECT (.CSUB.)> ;COMMON SUBROUTINE ENTRY
>; END IFN FTXMON
DEFINE	$HIGH,<	$PSECT (.HIGH.)> ;HIGH SEGMENT CODE
IFE FTXMON,<
DEFINE	$XHIGH,<$PSECT (.HIGH.)> ;EXTENDED HIGH SEGMENT SAME AS HIGH SEGMENT
>; END IFE FTXMON
IFN FTXMON,<
DEFINE	$XHIGH,<$PSECT (.XHGH.)> ;EXTENDED HIGH SEGMENT
>; END IFN FTXMON
;MACRO TO SWITCH TO ANY DEFINED PSECT

DEFINE	$PSECT(NAME),<		;;GENERIC PSECT

IFN PSECT.-NAME,<		;;IF WE'RE SWITCHING

	IFN PSECT.,<		;;IF NOT ABSOLUTE
		.ENDPS		;;END OF THIS ONE
	>;; END IFN
	IFE PSECT.,<		;;IF ABSOLUTE
		ABSLOC==.	;;REMEMBER WHERE WE WERE
		RELOC		;;GO RELOCATABLE
	>;; END IFE

	PSECT.==NAME		;;WHERE WE ARE NOW

	IFL PSECT.,<		;;IF NOT THE ABSOLUTE "PSECT"
		.PSECT	NAME	;;GET THERE
	>;; END IFL
	IFE PSECT.,<		;;IF THE ABSOLUTE "PSECT"
		LOC	ABSLOC	;;GET THERE
	>;; END IFE

>;; END IFN

>; END $PSECT
	SUBTTL	SYSTEM MACROS -- $PHASE AND $DEPHASE

;COMPANION MACROS TO DO PHASE/DEPHASE AND RECLAIM SPACE USED

DEFINE	$PHASE(LOC,%...),<

	.XCREF	%...		;;DON'T WASTE CREF SPACE
	.NODDT	%...		;;OR SYMBOL TABLE SPACE
	%...==.			;;REMBER CURRENT LOCATION
	PHASE	LOC		;;PHASE TO LOCATION

    DEFINE  $DEPHASE,<		;;DEFINE COMPANION MACRO

	DEPHASE			;;DEPHASE
	.ORG	%...		;;RECLAIM WASTED SPACE
	DEFINE	$DEPHASE,<PRINTX ? $DEPHASE WITHOUT PRECEEDING $PHASE>

    >;; END DEFINE $DEPHASE

>;; END DEFINE $PHASE

DEFINE	$DEPHASE,<PRINTX ? $DEPHASE WITHOUT PRECEEDING $PHASE>
	SUBTTL	SYSTEM MACROS -- UUO ERROR CODE GENERATOR

;USAGE:
; DEFINE LOCAL ERROR CODES, ERRA%=0, ERRB%=1, ...
; DEFINE LOCAL LABELS WHICH CORRESPOND TO EACH ERROR CODE.
; FOR EACH ERROR CODE, LABEL PAIR, ERCODE(LABEL,CODE)

ECDMAX==40

DEFINE	ERCODX(NAME,CODE)<
	.DIRECTIVE .XTABM
	ERRCDX	(NAME,CODE,\CODE)
	.DIRECTIVE .ITABM>

DEFINE	ERRCDX(NAME,CODE,ACODE)<
	IFG <CODE+1-ECDMAX>,<GENXCD(NAME,CODE,ACODE)>
	IFNDEF NAME,<NAME==ECDX'ACODE##>>

DEFINE	GENXCD(NAME,CODE,ACODE)<
PRINTX %ECDX'ACODE IS UNDEFINED, DEFINE ECDMAX IN S.MAC TO BE ACODE+1
NAME==[MOVEI	T1,CODE
	JRST	STOTAC##]
	IF1,<NAME==0>>		;GET ROUND BUG IN MACRO 50

DEFINE	ERCALX(N)<
.N==0
REPEAT	N,<ERXJSP (\.N)
.N=.N+1>
ECDX:	SUBI	T1,ECDX0+1
	HRRZS	T1
	JRST	STOTAC##>

DEFINE	ERXJSP(N)<
ECDX'N::JSP	T1,ECDX>


DEFINE	ERCODE(NAME,CODE)<
	.DIRECTIVE .XTABM
	ERRCOD	(NAME,CODE,\CODE)
	.DIRECTIVE .ITABM>

DEFINE	ERRCOD(NAME,CODE,ACODE)<
	IFG <CODE+1-ECDMAX>,<GENECD(NAME,CODE,ACODE)>
	IFNDEF NAME,<NAME==ECOD'ACODE##>>

DEFINE	GENECD(NAME,CODE,ACODE)<
PRINTX %ECOD'ACODE IS UNDEFINED, DEFINE ECDMAX IN S.MAC TO BE ACODE+1
NAME==[MOVEI	T1,CODE
	JUMPL	M,CPOPJ##
	JRST	STOTAC##]
	IF1,<NAME==0>>		;GET ROUND BUG IN MACRO 50

DEFINE	ERCALC(N)<
.N==0
REPEAT	N,<ERRJSP (\.N)
.N=.N+1>
ECOD:	SUBI	T1,ECOD0+1
	HRRZS	T1
	JUMPL	M,CPOPJ
	JRST	STOTAC##>

DEFINE	ERRJSP(N)<
ECOD'N::JSP	T1,ECOD>
	SUBTTL	SYSTEM MACROS -- MULTI PROCESSING

IFN FTMP,<		;MASTER-SLAVE INTERFACE CODE PRESENT?

;NOTE: NO NEED TO BRACKET CPLOCK,CPUNLK,SBLOK MACRO CALLS WITH
; IFN FTMP,< ... > SINCE THE ARE DEFINED TO BE NULL IF FTMP = 0.

;MACRO TO INTERLOCK CODE AND/OR DATA ON FLAG XXX.
; CPLOCK XXX ENTERS AND LOCKS BEHIND IT UNTIL MATCHING CPUNLK XXX.
; SO FAR "SCD" IS ONLY INTER-LOCK FLAG(FOR SCHEDULER).

	DEFINE	CPLOCK	(XXX)<
	PUSHJ	P,LOK'XXX	;ENTER CPU INTER-LOCKED REGION ON 'XXX'
	EXTERN	LOK'XXX>

;MACRO TO UNLOCK CODE AND/OR DATA ON FLAG XXX.
; GOES WITH CPLOCK MACRO.

	DEFINE	CPUNLK	(XXX)<
	PUSHJ	P,ULK'XXX	;EXIT CPU INTER-LOCKED REGION ON 'XXX'
	EXTERN	ULK'XXX>

;MACRO TO INTERLOCK A SUBROUTINE UNTIL THIS SUB. EXITS ON FLAG XXX.
; JUST LIKE CPLOCK EXCEPT MATCHING CPUNLK IS AUTOMATIC,
; BECAUSE LK'XXX PUTS ULK'XXX ON PD LIST.

	DEFINE	SBLOK	(XXX)<
	PUSHJ	P,SB'XXX	;INTERLOCK THIS SUBROUTINE ON 'XXX'
	EXTERN	SB'XXX>

>	;END FTMP

IFE FTMP,<		;MASTER-SLAVE INTERFACE CODE NOT PRESENT?

	DEFINE	CPLOCK	(XXX)<>
	DEFINE	CPUNLK	(XXX)<>
	DEFINE	SBLOK	(XXX)<>

>	;END FTMP

;MACRO TO TEST FOR WHICH CPU THIS IS (0 OR 1) OR WHICH TYPE THIS IS (A OR I)
; NOTE:  P4 DOES NOT NEED TO BE SETUP
; ALWAYS BRACKET THIS MACRO CALL WITH IFN FTMP,< ... >, SO NESTED
; SKIP CODE WILL BE OBVIOUS THAT SOMETIMES MACRO DOES NOT GENERATE CODE.

	DEFINE	SKPCPU	(N)<
IF2,< IFNDEF .CPSK'N,<EXTERNAL .CPSK'N>>
	XCT	.CPSK'N
>
	SUBTTL	SYSTEM MACROS -- DISK AND TAPE PI CONTROL


;MACROS TO TURN DISK PI CHANNEL ON AND OFF

	DEFINE	DSKON,<
IFE FTMP,<
IF2,<IFNDEF DSKPIN,<EXTERN DSKPIN>>
	CONO	PI,DSKPIN
>
IFN FTMP,<
IF2,<IFNDEF DSKULK,<EXTERN DSKULK>>
	PUSHJ	P,DSKULK
>
>;END DSKON MACRO DEFINITION


	DEFINE	DSKOFF,<
IFE FTMP,<
IF2,<IFNDEF DSKPIF,<EXTERN DSKPIF>>
	CONO	PI,DSKPIF
>
IFN FTMP,<
IF2,<IFNDEF DSKLOK,<EXTERN DSKLOK>>
	PUSHJ	P,DSKLOK
>
>;END DSKOFF MACRO DEF.


;MACROS TO TURN TAPSER PI CHANNEL ON AND OFF

	DEFINE	TAPON,<
IF2,<IFNDEF TAPULK,<EXTERN TAPULK>>
	PUSHJ	P,TAPULK
>;END TAPON MACRO DEF.

	DEFINE	TAPOFF,<
IF2,<IFNDEF TAPLOK,<EXTERN TAPLOK>>
	PUSHJ	P,TAPLOK
>;END TAPOFF MACRO DEFINITION
	DEFINE	SCNON,<
IF2,<IFNDEF SCNPIN,<EXTERN SCNPIN>
 IFN FTMP,<IFNDEF UNLSCI,<EXTERN UNLSCI>>
>
IFE FTMP,<CONO PI,SCNPIN>
IFN FTMP,<PUSHJ P,UNLSCI>
>

	DEFINE	SCNOFF,<
IF2,<IFNDEF SCNPIF,<EXTERN SCNPIF>
 IFN FTMP,<IFNDEF LOKSCI,<EXTERN LOKSCI>>
>
IFE FTMP,<CONO PI,SCNPIF>
IFN FTMP,<PUSHJ P,LOKSCI>
>

	DEFINE	NETON,<
IF2,<IFNDEF NETPIN,<EXTERN NETPIN>
 IFN FTMP,<IFNDEF UNLNPI,<EXTERN UNLNPI>>
>
IFE FTMP,<CONO PI,NETPIN>
IFN FTMP,<PUSHJ P,UNLNPI>
>

	DEFINE	NETOFF,<
IF2,<IFNDEF NETPIF,<EXTERN NETPIF>
 IFN FTMP,<IFNDEF LOKNPI,<EXTERN LOKNPI>>
>
IFE FTMP,<CONO PI,NETPIF>
IFN FTMP,<PUSHJ P,LOKNPI>
>

;BYTE DIDDLING INTERLOCK MACROS
DEFINE BYTPIF,<PUSHJ P,LOKSBI>
DEFINE BYTPIN,<PUSHJ P,UNLSBI>

;...DPB - DO A DEPOSIT BYTE TO AN INTERLOCKED WORD.
;	THIS WAS DEFINED FOR A VERSION OF THE MICROCODE WHICH DID NOT HAVE
;	READ-MODIFY-WRITE FOR DEPOSIT BYTE. IT IS STRONGLY SUGGESTED THAT
;	THIS FEATURE TEST (FTDOTD) NOT BE TURNED ON, SINCE PERFORMANCE IS
;	NOTICABLY IMPACTED.
;
;N.B. - THE MICROCODE BUG HAS BEEN FIXED, BUT PLEASE CONTINUE TO USE THE
;	...DPB CONSTRUCT FOR DPB TO UN-INTERLOCKED WORDS, IN CASE THE FIX
;	HAS TO BE REMOVED FOR SOME UNKNOWN REASON.


IFE FTXMON,<
	DEFINE	SPUSH(AC),<>
	DEFINE	SPOP(AC),<>
	DEFINE	SSX(AC,SN),<>
	DEFINE	SSXE(AC,SN),<>
	DEFINE	SE1ENT,<>
	DEFINE	SE1JRS,<>
	DEFINE	XJRST<JRST	@>
>
IFN FTXMON,<
	DEFINE	SPUSH(AC),<PUSH P,AC>
	DEFINE	SPOP(AC),<POP P,AC>
	DEFINE	SSX(AC,SN),<HRLI AC,(SN)>
	DEFINE	SSXE(AC,SN),<HRLI AC,SN>
	DEFINE	SE1ENT,<IFNDEF SSEC1,<EXTERNAL SSEC1>
			PUSHJ P,SSEC1>
	OPDEF	XJRST [JRST 15,]
	DEFINE	SE1JRS,<XJRST .+1
			MCSEC1+.+1
		>
>
;MACRO TO CAUSE AN I/O PAGE FAIL ON AN INTERRUPT TO 40+2N+1
; THIS CAPTURES THE I/O PAGE FAIL WORD WHICH CAN BE USEFUL IN DIAGNOSIS
	DEFINE	IOP,<MOVEM MONORG>
	SUBTTL	MACROS TO MANIPULATE TERMINAL BUFFER STREAMS

;NOTE:  THE FOLLOWING MACROS USE T1 AND T2 AS TEMPORARY AC'S.  THEY
;	MAY ** NOT ** BE SKIPPED OVER.  EACH CALLS A SUPPORT SUBROUTINE TO
;	SKIP FROM CHUNK TO CHUNK, BUT HANDLES THE NORMAL CASE IN LINE.
;	IN CASE OF ERROR RECOVERY (FROM RCC STOPCD) THE SCNSER INTERLOCK
;	MUST BE OWNED.

;MACRO TO TAKE A CHARACTER OUT OF A TERMINAL BUFFER STREAM, ADVANCE
;THE POINTER SPECIFIED BY "LOC", BUT NOT TO GIVE BACK ANY CHUNKS
;THAT ARE PASSED OVER.  USES T1, T2 AND T3.  CHARACTER MAY BE
;RETURNED IN T3 IF DESIRED.

DEFINE LDCHK(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKS,<EXTERNAL NEWCKS>
	IFB	<ABO>,<PRINTX ? LDCHK INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKS;;YES, ADVANCE TO NEXT CHUNK, KEEPING THIS ONE
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE ILDB
	ILDB	AC,LOC		;;GET NEXT BYTE
>

;MACRO TO TAKE A CHARACTER OUT OF A CHUNK AND TO RETURN ANY CHUNKS
;THAT ARE PASSED BY.  USES T1, T2 AND T3.  CHARACTER MAY BE RETURNED
;IN T3 IF DESIRED.

DEFINE LDCHKR(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKI,<EXTERNAL NEWCKI>
	IFB	<ABO>,<PRINTX ? LDCHKR INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKI;;YES, ADVANCE TO NEXT CHUNK, RELEASING THIS ONE
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE ILDB
	ILDB	AC,LOC		;;FETCH THE NEXT BYTE

>
;MACRO TO STORE A CHARACTER IN A TERMINAL OUTPUT STREAM.  DEPOSITS
;CHARACTER FROM "AC" USING THE BYTE POINTER SPECIFIED BY "LOC".
;CHUNKS ARE ALLOCATED FROM THE FREELIST AS NEEDED.  USES T1 AND T2.

DEFINE STCHK(AC,LOC,ABO),<
	IFNDEF	CK.BDY,<EXTERNAL CK.BDY>
	IFNDEF	NEWCKO,<EXTERNAL NEWCKO>
	IFB	<ABO>,<PRINTX ? STCHK INVOKED WITHOUT ABORT ADDRESS>
	SKIPE	T1,LOC		;;COPY OF BYTE POINTER
	TDNN	T1,[770000,,CK.BDY]  ;;POINTER AT END OF CHUNK?
	JRST	[PUSHJ	P,NEWCKO;;YES, ALLOCATE A NEW CHUNK
		  JRST	ABO	;;ABORT - CHUNKS MESSED UP
		MOVEM	T2,LOC	;;STORE NEW CHUNK BYTE POINTER
		JRST	.+1]	;;DO THE IDPB
	IDPB	AC,LOC		;;STUFF THIS CHARACTER INTO THE CHUNK STREAM

>

;DEFINITION OF CHUNK CONTENTS (SEE OTHER DEFINITIONS IN COMMON.MAC)
XP CK.CHR,0377			;MASK FOR JUST CHARACTER
XP CK.CH7,0177			;MASK FOR 7-BIT CHARACTER
XP CK.PAR,0200			;PARITY BIT
XP CK.IMG,0400			;CHARACTER IN IMAGE MODE
XP CK.FDE,1000			;FRONT-END ECHOED THIS CHARACTER
XP CK.NIS,2000			;NOT IN STREAM (USED-UP CHARACTER)
XP CK.MET,4000			;META-CHARACTER FOR SYNCHRONOUS FUNCTIONS
XP CK.MSK,7777			;ALL PER-CHARACTER BITS
XP CK.XMT,0777			;ALL CHARACTER BITS TO BE TRANSMITTED
XP CK.WID,^D36-^L<CK.MSK>	;NUMBER BITS PER CHARACTER IN A CHUNK
XP CK.CPW,^D36/CK.WID		;CHARACTERS PER WORD

;SCNSER ISR VECTOR OFFSETS

XP ISRTYP,0			;ILLEGAL NOW.  DON'T USE.
XP ISRDSC,1			;DATA SET CONTROL
XP ISRCHK,2			;TEST FOR LOST PIA (ONCE-A-SECOND CALLS)
XP ISRINI,3			;INIT ISR
XP ISRCHP,4			;CHANGE HARDWARE PARAMETERS
XP ISRLPC,5			;SEND LINE PARAMETER CONTROL MSG
XP ISRELE,6			;SET ELEMENT #
XP ISRREM,7			;DO REMOTE TERMINAL STUFF
XP ISROFL,10			;SKIP IF FRONT END ON LINE
XP ISRMAX,10			;MAXIMUM LDBISR INDEX

;SCNSER ISRREM VECTOR OFFSETS

XP IRRINV,0			;ILLEGAL.  DON'T USE
XP IRRCSL,1			;CHUNK SPACE LOW (SKIP AVOIDS XOFF)
XP IRRCNS,2			;CHARACTER NOT STORED (SKIP AVOIDS BELL)
XP IRRSCG,3			;SEND CHARACTER GOBBLER
XP IRRCSA,4			;CHUNK SPACE AVAILABLE (SKIP AVOIDS XON)
XP IRRDSC,5			;DISCONNECT (NON-SKIP MEANS CAN'T)
XP IRRCIB,6			;CLEAR INPUT BUFFER
XP IRRTMO,7			;TIMEOUT (DISCONNECT), NON-SKIP MEANS CAN'T
XP IRRBMC,10			;BREAK MASK CHANGED, NON-SKIP IMPLIES SETCHP
XP IRROOB,11			;OUT-OF-BAND SET CHANGED, NON-SKIP IMPLIES SETCHP
XP IRRMAX,11			;MAXIMUM ISRREM CODE

;SCNSER SPECIAL CHARACTER BIT DEFINITIONS

XP CC.BRK,1B35			;THIS IS A LINE BREAK
XP CC.NSA,1B34			;NO SPECIAL ACTION (SUPPRESS NORMAL MONITOR ACTION)
XP CC.OOB,1B33			;OUT-OF-BAND ENABLED FOR THIS CHARACTER
XP CC.DFR,1B32			;OOB IS DEFERRED TYPE (HELLO OR DEFERRED CLEAR)

;ADD ALL VALUES WHICH GO IN THE ACTUAL BYTES ABOVE
XP CC.WID,4			;WIDTH FOR MAKING BYTE POINTERS

;ADD ALL BITS WHICH DO NOT BELONG IN THE BYTES BELOW THIS LINE
XP CC.CLR,1B31			;BIT FOR 'CLEAR' OOB SETTING/CLEARING
XP CC.MSK,37			;KEEP MASK FOR FINDING VALID BITS
;CHARACTER ATTRIBUTE DEFINITIONS
	TA.8BT==1B0	;8-BIT TERMINAL
	TA.DIS==1B1	;DISPLAY TERMINAL
	TA.OVR==1B2	;OVERPRINTING WORKS ON THIS TERMINAL
	TA.8BA==1B3	;8-BIT ARCHITECTURE (CAN SOMETIMES BE 8-BIT)
	TA.NRC==1B4	;NATIONAL REPLACEMENT CHARACTER SETS SUPPORTED
	TA.ISO==1B5	;8-BIT MEANS ISO/LATIN-1, NOT DEC/MCS
	TA.LID==1B6	;LINE INSERTION & DELETION
	TA.CID==1B7	;CHARACTER INSERTION & DELETION
	TA.SRM==1B8	;SCROLLING REGIONS (DECSTBM) SUPPORTED
	TA.GAT==1B9	;GUARDED AREA TRANSFER SUPPORTED
	TA.SEM==1B10	;SELECTIVE ERASE (DECSEL/DECSED) SUPPORTED
	TA.AVO==1B11	;VT100'S ADVANCED VIDEO OPTION SUPPORTED OR EMULATED
	TA.PPO==1B12	;PRINTER PORT OPTION SUPPORTED
	TA.GPO==1B13	;REGIS SUPPORTED (MAYBE VIA GRAPHICS PROCESSOR OPTION)
	TA.SXL==1B14	;SIXEL GRAPHICS SUPPORTED
	TA.TEK==1B15	;TEKTRONIX 4010/4014 EMULATION
	TA.RCS==1B16	;DYNAMICALLY REDEFINABLE CHARACTER SETS
	TA.UDK==1B17	;USER-DEFINE KEYS
	TA.VFW==1B18	;VARIABLE FORMS WIDTH
	TA.VFL==1B19	;VARIABLE FORMS LENGTH
	TA.V52==1B20	;VT52 EMULATION AVAILABLE
	TA.ESL==1B21	;EXTRA STATUS LINE EXISTS
	TA.JTK==1B22	;KATAKANA CHARACTER SET IS AVAILABLE
	TA.TCS==1B23	;DEC TECHNICAL CHARACTER SET IS AVAILABLE
	TA.TSI==1B24	;TERMINAL STATE INTERROGATION
	TA.BMT==1B25	;BLOCK-MODE TRANSFER
	TA.BTA==1B26	;BLOCK TRANSFER IS ANSI
	TA.HSR==1B27	;HORIZONTAL SCROLLING
	TA.UWN==1B28	;USER WINDOWS
	TA.SSU==1B29	;MULTIPLE SESSIONS
	TA.CLR==1B30	;COLORED TERMINAL SCREEN
	TA.NKB==1B31	;NO KEYBOARD (ASYNCHRONOUS PRINTER SUCH AS LN03)
	SUBTTL	SYSTEM MACROS -- QUEUE DEFINITIONS

;DEFINE THE QUEUES, QUANTUM RUNNING TIME IN JIFFIES, AND PRIORITY
;PRIORITY GOES BACKWARD FROM LOW TO HIGH
;THE QUEUE NUMBERS START AT 0 AND GO UP BY ONE READING DOWN THE PAGE

;DEFINITION AND USAGE OF ARGUMENTS TO THE X MACRO:
;ARG1:  QUEUE NAME - USED TO DEFINE NAME OF QUEUE NUMBER (FOR
;	STATE XX, SYMBOL XXQ IS DEFINED AS THE QUEUE NUMBER IF
;	X MACRO CALLED BY QUEUES OR RWAITS, OR THE NAME IS
;	THE NUMBER FOR CODES)
;ARG2:	QUANTUM RUNTIME ON REQUEUE FROM THIS QUEUE TO RUN
;ARG3:	[DJ (DELAY JOB) OR SJ (STOP JOB)] ON ^C
;ARG4:	ADDRESS OF UNWIND ROUTINE FOR SCHEDULAR
;ARG5:	ADDRESS OF ROUTINE TO GRANT RESOURCE AT SCHEDULAR
;ARG6:	ADDRESS OF ROUTINE TO TEST IF JOB IN J OWNS RESOURCE OF
;	THIS TYPE
;FOR ARGUMENTS 3-6 A DEFAULT ROUTINE IS USED IF NONE IS SPECIFIED


DEFINE QUEUES
<	X	(RN,7,DJ,)	;;STRAIGHT RUN (LOWEST PRIORITY) (Q=0)
	X	(WS,6,SJ,)	;;I/O WAIT SATISFIED
	X	(TS,6,SJ,)	;;TTY I/O WAIT SATISFIED
	X	(DS,6,DJ,)	;;DISK I/O WAIT SATISFIED
	X	(PS,6,DJ,)	;;PAGING I/O WAIT SATISFIED
>
DEFINE RWAITS
<
	X	(AU,4,DJ,UNWAU,SCDAU,OWNAU)	;;ALTER DISK UFD QUEUE
	X	(DA,4,DJ,UNWDA,SCDDA,OWNDA)	;;DISK STORAGE ALLOCATION WAIT
	X	(CB,4,DJ,)	;;DISK CORE-BLOCK SCAN WAIT
	X	(DT,4,SJ,UNWDTC,SCDDT,OWNDTC)	;;DECTAPE CONTROL WAIT
	X	(IP,4,DJ,UNWIPC,SCDIP,OWNIP)	;;IPCF INTERLOCK WAIT
	X	(CX,4,DJ,UNWCX,SCDCX,OWNCX)	;;CONTEXT SAVE WAIT
	X	(DC,4,SJ,)	;;DATA CONTROL (DC) WAIT - MAGTAPE AND DECTAPE
	X	(CA,4,DJ,)	;;SEMI-PERMANENT CORE ALLOCATION WAIT
				;;(LOKCON, ALSO SEGCON SETTING UP SEGMENT TBLS)
IFN FTMP,<
	X	(MC,4,DJ,)	;;MONITOR I/O DISK CACHE WAIT
	X	(MM,4,DJ,)	;;MEMORY MANAGEMENT WAIT
> ;END IFN FTMP
	X	(EV,4,SJ,)	;;EXEC VIRTUAL MEMORY WAIT
	X	(EQ,4,DJ,)	;;ENQ/DEQ WAIT
	X	(FA,4,DJ,)	;;DISK FILE ALLOCATION RESOURCE WAIT
>


;;JOB STATUS CODES WHICH HAVE NO CORRESPONDING QUEUES
;;JOBS ARE UNRUNABLE WHEN IN THESE STATES

DEFINE CODES
<	X	(IOW,,SJ,)	;;I/O WAIT
	X	(TIOW,,SJ,)	;;TTY I/O WAIT
	X	(DIOW,,DJ,)	;;DISK I/O WAIT

	X	(PIOW,,DJ,)	;;PAGING I/O WAIT

	X	(PQIO,,DJ,)	;;PAGING QUEUE WAIT
	X	(SLP,,SJ,)	;;JOB SLEEPING
	X	(EW,,SJ,)	;;JOB IN EVENT WAIT
	X	(NAP,,SJ,)	;;JOB NAPPING (.LT. 1 SEC SLEEP)
	X	(NUL,,SJ,)	;;JOB NUMBER NOT ASSIGNED
	X	(JDC,,SJ,)	;;WAITING FOR DAEMON TO BE RUN

	X	(STOP,,SJ,)	;;STOP (CONTROL C)
>
	SUBTTL	OPDEFS

;USEFUL OPCODES TO INDICATE SHORT CODING OF A SUBROUTINE CALL

SOPDEF PJRST [JRST]	;PJRST IS USED IN PLACE OF THE LAST PAIR OF
		; INSTRUCTIONS IN A SUBROUTINE WHEN THEY ARE PUSHJ
		; FOLLOWED BY A POPJ.  PJRST IS USED INSTEAD OF JRST, SO
		; THAT SOMEONE READING THE CODE WILL UNDERSTAND THAT A
		; SUBROUTINE IS BEING CALLED.

SOPDEF PJRSTF	[JRSTF]
SOPDEF PJSP	[JSP]	;PJSP IS USED IN PLACE OF MOVEI .+2, PJRST SUB
SOPDEF PJUMPL	[JUMPL]
SOPDEF PJMPLE	[JUMPLE]
SOPDEF PJUMPE	[JUMPE]
SOPDEF PJUMPG	[JUMPG]
SOPDEF PJMPGE	[JUMPGE]
SOPDEF PJUMPN	[JUMPN]

;OPDEF TO SET AN AC NON-ZERO AND JUMP (RATHER THAN CALL A SUB)

SOPDEF	SJSP	[JSP]

;OPDEF TO FIND HALTS WHICH SHOULD BE STOPCD'S

OPDEF	HALT	[JRST 4,0]

;INSTRUCTION TO DISPATCH ON ERROR (ILL MEM REF, EXCT?? ASSUMED,
; BUT MAY BE USED ANYWHERE IN MONITOR AFTER PAGE FAULT PROCESSOR
; IS SET UP).

OPDEF	ERJMP	[JUMP 16,]	;JRST TO "E" ON IME (ILL MEM REF)
;OPDEF	ERCAL	[JUMP 17,]	;PUSHJ P, TO "E" ON IME
	SUBTTL	MONITOR/USER SYMBOL PREFIXES

REPEAT	0,<
MONITOR/USER SYMBOLS PREFIXES:

SYMBOLS FOR MONITOR DATA BLOCKS WILL HAVE PERIODS IN THEM
SO THAT AS MANY OF THEM AS DESIRED CAN BE MADE
USER SYMBOLS AS THE NEED ARISES WITHOUT CONFLICTING
WITH ALREADY CODED PROGRAMS.
IT IS POSSIBLE TO DIVIDE DATA SYMBOLS INTO TWO CLASSES:

    A)  NUMBERS
    B)  MASKS

NUMBERS INCLUDE CORE ADDRESSES, FUNCTION CODES, AND ERROR CODES.

MASKS INCLUDE BITS AND FIELDS.

NUMBERS WILL BE 18 BITS AND MASKS WILL BE 36 BIT QUANTITIES.  USE
THE MACRO FEATURE WHICH SWAPS QUANTITIES INSIDE () TO REFERENCE
THE BITS.  AN ERROR WILL RESULT IF () ARE FORGOTTEN (BITS 0-8 ONLY).
BECAUSE OF PAST PRECEDENT, SYMBOLS DEFINING NUMBERS (I.E. ADDRESS,
FUNCTION CODES, AND ERROR CODES) WILL BEGIN WITH A DOT FOLLOWED BY A
TWO-LETTER PREFIX.  MASKS WILL START WITH A TWO-LETTER PREFIX FOLLOWED
BY A DOT.  UUO OPCODES WILL END WITH DOT.

THE FOLLOWING PREFIXES HAVE BEEN USED.  FILENAMES INDICATE WHERE
THEY ARE DEFINED.

A.	WORD ADDRESSES:

	.JB???	ARE JOB DATA AREA SYMBOLS (JOBDAT.MAC)
	?????.	WILL BE CALLI UUO SYMBOLS IMPLEMENTED AFTER
		5.03 (UUOCON.MAC)
	.PD???	WILL BE SYMBOLS IN THE PROCESS DATA BLOCK
		(PDB), USUALLY INDEXED BY W.
	.RB???	FILE EXTENDED ARGS, (LOOKUP, ENTER, RENAME)
		(S.MAC)
	.CP???	RELATIVE LOCATIONS IN CPU DATA BLOCK (CDB) USUALLY
		INDEXED BY P4 (COMMON.MAC)
	.C0???	ABSOLUTE LOCATIONS IN MASTER CDB (COMMON.MAC)
	.C1???	ABSOLUTE LOCATIONS IN SLAVE CDB (COMMON.MAC)
	.GT???	GETTAB TABLE NUMBERS (UUOCON.MAC)
B.	FUNCTION CODES:

	.FS	STRUUO (FILE STRUCTURE) (PRVUUO.RNO)

C.	ERROR CODES:

	.ER	STRUUO ERROR CODES (PRVUUO.RNO)

D.	BITS:  (FIRST FOUR DO NOT FOLLOW ABOVE CONVENTION.)

	.SP???	SPOOL BITS (S.MAC)
	.TY???	DEVTYP UUO BITS (S.MAC)
	.ERMSG	DON'T TYPE ERROR MESSAGE ON ERROR INTERCEPT
	.OK???	INTERCEPT DEVICE OK ERRORS (S.MAC)

	JB.L??	JOB LIMIT BITS (S.MAC)
	SP.???	SECOND PROCESSOR STATUS BITS (S.MAC)
	AP.???	APR CONI/CONO BITS (S.MAC)
	PC.???	PC WORD FLAGS (S.MAC)
	PI.???	PI CONI/CONO BITS (S.MAC)
	JP.???	JOB PRIVILEGE BITS (S.MAC) IN JBTPRV
	JS.???	JOB STATUS BITS IN JBTSTS (S.MAC)
	JW.???	JOB WATCH RTS IF JBTWCH (S.MAC)

IT IS SUGGESTED THAT ??? BE EITHER A PRONOUNCEABLE "WORD" SUCH AS JOB
OR A TWO OR THREE LETTER ALPHABET SOUP SYMBOL WHERE EACH LETTER IS THE
FIRST LETTER OF EACH WORD IN THE MNEMONIC (E.G. LJR FOR LAST JOB RUN,
RATHER THAN, SAY, LSJ FOR LAST JOB.)
>
	SUBTTL DEFINE THE SYMBOLS FOR THE LINK PSEUDO OPERATIONS

	XP	.LKACB,1	;LINK FOR LINKING ALLOCATION CONTROL BLOCKS
	XP	.LKAHB,2	;LINK FOR LINKING ALLOCATION HEADER BLOCKS
	XP	.LKDRV,3	;LINK FOR LINKING DRIVER DISPATCH TABLES
	XP	.LKSAX,4	;LINK FOR LINKING SA10 DISPATCH TABLES


	SUBTTL	KLINIK DEFINITIONS
KPSLEN==26			;LENGTH OF PARAMETER SAVE MESSAGE
	SUBTTL	DIAG. UUO DEFINITIONS


;FUNCTION CODES
	.DICTC==:000	;CONTROL-C ENTRY POINT (MONITOR FUNCTION ONLY)
	.DIASU==:001	;ASSIGN SINGLE UNIT ON CHAN/CTL
	.DIAAU==:002	;ASSIGN ALL UNITS ON CHAN/CTL
	.DIRAU==:003	;RELEASE ALL UNITS ON CHAN/CTL
	.DISCP==:004	;SPECIFY CHANNEL PROGRAM
	.DIRCP==:005	;RELEASE CHANNEL PROGRAM
	.DIGCS==:006	;GET CHANNEL STATUS
	.DIAKU==:007	;RETURN CONTROLLER AND UNIT FOR DEVICE
	.DIACS==:010	;FORCE CPU STATUS BLOCK READ
	.DIADS==:011	;FORCE DEVICE STATUS BLOCK READ
	.DISCR==:012	;SPECIFY CHANNEL PROGRAM FOR READ REVERSE
	.DIANL==:013	;ENABLE/DISABLE AUTO RELOAD OF DX20 MICROCODE
	.DIGUI==:014	;GET USER I/O
	.DIASM==:015	;SEIZE MAGTAPE CONTROLLER(S)
	.DIARM==:016	;RELEASE MAGTAPE CONTROLLER(S)
	.DIELD==:017	;ENABLE MICROCODE LOADING
	.DIDLD==:020	;DISABLE MICROCODE LOADING
	.DILOD==:021	;LOAD MICROCODE
	.DIISM==:022	;SET IPA CHANNEL MAINTENANCE MODE
	.DIICM==:023	;CLEAR IPA CHANNEL MAINTENANCE MODE
	.DISBD==:024	;EXECUTE S-BUS DIAGNOSTIC FUNCTION
	.DIDSN==:025	;READ DEVICE SERIAL NUMBER
	.DIRUR==:026	;READ KS10 UNIBUS REGISTER
	.DIADB==:027	;ALLOCATE BUFFER FOR DUMPING IPA20 DRAM
	.DIOKI==:030	;OBTAIN KONTROLLER INFORMATION
	.DIOUI==:031	;OBTAIN UNIT INFORMATION
	.DILKU==:032	;LIST KONTROLLER'S UNITS
	.DISDS==:033	;SET DEVICE STATUS
	.DIDVR==:034	;READ DEVICE REGISTERS
	.DIGTM==:100	;GET MOS MEMORY
	.DIGVM==:101	;GIVE MOS MEMORY
	.DIRRS==:105	;RESET REMOTE CI NODE
	.DISRS==:106	;START REMOTE CI NODE
	.DIACC==:107	;MANIPULATE CI PORT COUNTERS
	.DIWCM==:112	;WRITE CI MAINTENANCE DATA
	.DIRCM==:113	;READ CI MAINTENANCE DATA
;ERROR CODES
DEFINE	DIAECD,<

X	(ANP,01)	;NOT PRIVILEGED
X	(AIA,02)	;ILLEGAL NUMBER OF ARGS
X	(AIC,03)	;ILLEGAL CONTROLLER
X	(AIU,04)	;ILLEGAL UNIT
X	(AAA,05)	;SOME UNITS ALREADY ASSIGNED
X	(ADM,06)	;UNIT NOT IN DIAG MODE
X	(AAJ,07)	;UNIT ASSIGNED TO ANOTHER JOB
X	(AFC,10)	;NO FREE CORE
X	(AAU,11)	;NO ASSIGNED UNITS
X	(ACP,12)	;IOWD CROSSES PAGE
X	(AIF,13)	;ILLEGAL FUNCTION
X	(AVC,14)	;JOB CANNOT BE VIRTUAL
X	(ANC,15)	;NO SUCH CPU
X	(ANR,16)	;CPU NOT RUNNING
X	(ABA,17)	;BAD ARGUMENT LIST
X	(ACI,20)	;NO CI PORT ON SPECIFIED CPU
X	(ATO,21)	;READ PORT COUNTERS FUNCTION TIMED OUT
X	(ANK,22)	;NO NI PORT ON SPECIFIED CPU
X	(ARF,23)	;MICROCODE RELOAD FAILED
X	(ANM,24)	;NO MICROCODE AVAILABLE
X	(APN,25)	;CI/NI PORT NOT RUNNING
X	(ANU,26)	;NON-EXISTANT UNIBUS ADDRESS
X	(AAF,27)	;ATTACH FAILED
X	(ADF,30)	;DETACH FAILED

> ;END DEFINE DIAECD

DEFINE	X	(COD,VAL),<DI'COD'%==:VAL>
	DIAECD
;THIS MACRO WILL DEFINE A DIAG. UUO DISPATCH TABLE CONTAINING ONLY THOSE
;ENTRIES WHICH ARE NEEDED BY THE PARTICULAR DRIVER.  UUOCON DIAG DISPATCH
;WILL BE RESPONSIBLE FOR DETERMINING IF THE DRIVER CAN SUPPORT A GIVEN
;FUNCTION.  THE MACRO TAKES THREE ARGUMENTS:
;	CODE	- THREE CHARACTER MNEMONIC FOR THE FUNCTION
;	KL10	- DISPATCH ADDRESS FOR A KL10 MONITOR
;	KS10	- DISPATCH ADDRESS FOR A KS10 MONITOR

DEFINE	DIAFNC	(CODE,KL10,KS10),<
	XLIST					;;NO ONE WANTS TO SEE THIS JUNK

IFB  <CODE>,<EXP	0>			;;TERMINATE TABLE
IFNB <CODE>,<
	IFN FTKL10,<XWD	.DI'CODE,KL10>		;;KL10 DISPATCH ADDRESS
	IFN FTKS10,<XWD	.DI'CODE,KS10>		;;KS10 DISPATCH ADDRESS
> ;;END IFNB <CODE>

	LIST					;;TURN LISTING BACK ON
> ;END DEFINE DIAFNC
	SUBTTL	MICROLOADER DEFINITIONS


	  PHASE	0

.ULIDX::! BLOCK	1	;(RH) MICROCODE OFFSET INTO THE BOOTSTRAP VECTOR
UE.DAE==377777B17	;(LH) RANDOM BITS IN ERROR.SYS (BITS 1-17)
   UE.USR==1B1		   ;MICROCODE LOAD INVOKED BY USER (DIAG. UUO)
			;MIROCODE LOAD ERROR CODE (BITS 12-17)
   .UEDIS==1		   ;LOADING DISABLED
   .UENOM==2		   ;NO MICROCODE AVAILABLE
   .UEWVR==3		   ;WRONG MICROCODE VERSION
   .UELOD==4		   ;LOAD ERROR
   .UEVFY==5		   ;VERIFY ERROR
   .UEMPC==6		   ;MICROPROCESSOR CHECK
   .UECRL==7		   ;CRAM LOAD ERROR
   .UECRV==10		   ;CRAM VERIFY ERROR
   .UEDRL==11		   ;DRAM LOAD ERROR
   .UEDRV==12		   ;DRAM VERIFY ERROR
.ULDEV::! BLOCK	1	;XWD DEVICE CODE,UNIT NUMBER
			; IF NOT A MULTI-UNIT DEVICE SUCH AS A DX20,
			; THEN THE UNIT NUMBER IS  -1
			;  NOTE: PRIOR TO MAKING A DAEMON ENTRY, THE
			;        CPU NUMBER IS STORED INTO BITS 6-8.
.ULINM::! BLOCK	1	;SIXBIT INTERFACE NAME
			;  (I.E. TX01, TX02, RP20, KLIPA, KLNI, ETC.)
.ULDNM::! BLOCK	1	;SIXBIT CHANNEL NAME
			;  (I.E. DX10, DX20, CI20, NIA20, ETC.)
.ULMVR::! BLOCK	1	;MINIMUM MICROCODE VERSION NUMBER ALLOWED
.ULDTM::! BLOCK	1	;DATE/TIME OF LOAD SUCCESS OR FAILURE
.ULVER::! BLOCK	1	;MICROCODE VERSION NUMBER IN STANDARD DECSYSTEM-10
			;  FORMAT (FILLED IN BY MONBTS)
.ULDAE::!		;LENGTH OF BLOCK WRITTEN INTO ERROR.SYS BY DAEMON
.ULMAG::! BLOCK	1	;ADDRESS OF TABLE CONTAINING MAGIC LOCATIONS AND
			;  CONSTANTS.  EACH WORD CONTAINS A CONSTANT IN THE
			;  LEFT HALF AND A MICROPROCESSOR ADDRESS IN THE
			;  RIGHT HALF.
.ULWDS::! BLOCK	1	;MICROCODE LENGTH IN PDP-10 WORDS (FILLED IN
			;  BY MONBTS)
.ULADR::! BLOCK	1	;30-BIT MICROCODE ADDRESS (FILLED IN BY MONBTS)
.ULLEN::!		;LENGTH OF LOADER BLOCK

	  DEPHASE
	SUBTTL	END


	END
